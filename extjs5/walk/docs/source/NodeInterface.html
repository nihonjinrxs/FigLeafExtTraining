<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-data-NodeInterface'>/** 
</span> * This class is used as a set of methods that are applied to the prototype of a
 * Model to decorate it with a Node API. This means that models used in conjunction with a tree
 * will have all of the tree related methods available on the model. In general this class will
 * not be used directly by the developer. This class also creates extra fields on the model if
 * they do not exist, to help maintain the tree state and UI. These fields are documented as
 * config options.
 */
Ext.define(&#39;Ext.data.NodeInterface&#39;, {
    requires: [
        &#39;Ext.data.field.Boolean&#39;,
        &#39;Ext.data.field.Integer&#39;,
        &#39;Ext.data.field.String&#39;,
        &#39;Ext.data.writer.Json&#39;,
        &#39;Ext.mixin.Observable&#39;
    ],

<span id='Ext-data-NodeInterface-cfg-parentId'>    /**
</span>     * @cfg {String} parentId
     * ID of parent node.
     */

<span id='Ext-data-NodeInterface-cfg-index'>    /**
</span>     * @cfg {Number} index
     * The position of the node inside its parent. When parent has 4 children and the node is third amongst them,
     * index will be 2.
     */

<span id='Ext-data-NodeInterface-cfg-depth'>    /**
</span>     * @cfg {Number} depth
     * The number of parents this node has. A root node has depth 0, a child of it depth 1, and so on...
     */

<span id='Ext-data-NodeInterface-cfg-expanded'>    /**
</span>     * @cfg {Boolean} [expanded=false]
     * True if the node is expanded.
     */

<span id='Ext-data-NodeInterface-cfg-expandable'>    /**
</span>     * @cfg {Boolean} [expandable=false]
     * Set to true to allow for expanding/collapsing of this node.
     */

<span id='Ext-data-NodeInterface-cfg-checked'>    /**
</span>     * @cfg {Boolean} [checked=null]
     * Set to true or false to show a checkbox alongside this node.
     */

<span id='Ext-data-NodeInterface-cfg-leaf'>    /**
</span>     * @cfg {Boolean} [leaf=false]
     * Set to true to indicate that this child can have no children. The expand icon/arrow will then not be
     * rendered for this node.
     */

<span id='Ext-data-NodeInterface-cfg-cls'>    /**
</span>     * @cfg {String} cls
     * CSS class to apply for this node.
     */

<span id='Ext-data-NodeInterface-cfg-iconCls'>    /**
</span>     * @cfg {String} iconCls
     * CSS class to apply for this node&#39;s icon.
     *
     * There are no default icon classes that come with Ext JS.
     */

<span id='Ext-data-NodeInterface-cfg-icon'>    /**
</span>     * @cfg {String} icon
     * URL for this node&#39;s icon.
     *
     * There are no default icons that come with Ext JS.
     */

<span id='Ext-data-NodeInterface-cfg-root'>    /**
</span>     * @cfg {Boolean} root
     * True if this is the root node.
     */

<span id='Ext-data-NodeInterface-cfg-isLast'>    /**
</span>     * @cfg {Boolean} isLast
     * True if this is the last node.
     */

<span id='Ext-data-NodeInterface-cfg-isFirst'>    /**
</span>     * @cfg {Boolean} isFirst
     * True if this is the first node.
     */

<span id='Ext-data-NodeInterface-cfg-allowDrop'>    /**
</span>     * @cfg {Boolean} [allowDrop=true]
     * Set to false to deny dropping on this node.
     */

<span id='Ext-data-NodeInterface-cfg-allowDrag'>    /**
</span>     * @cfg {Boolean} [allowDrag=true]
     * Set to false to deny dragging of this node.
     */

<span id='Ext-data-NodeInterface-cfg-loaded'>    /**
</span>     * @cfg {Boolean} [loaded=false]
     * True if the node has finished loading.
     */

<span id='Ext-data-NodeInterface-cfg-loading'>    /**
</span>     * @cfg {Boolean} [loading=false]
     * True if the node is currently loading.
     */

<span id='Ext-data-NodeInterface-cfg-href'>    /**
</span>     * @cfg {String} href
     * An URL for a link that&#39;s created when this config is specified.
     */

<span id='Ext-data-NodeInterface-cfg-hrefTarget'>    /**
</span>     * @cfg {String} hrefTarget
     * Target for link. Only applicable when {@link #href} also specified.
     */

<span id='Ext-data-NodeInterface-cfg-qtip'>    /**
</span>     * @cfg {String} qtip
     * Tooltip text to show on this node.
     */

<span id='Ext-data-NodeInterface-cfg-qtitle'>    /**
</span>     * @cfg {String} qtitle
     * Tooltip title.
     */

<span id='Ext-data-NodeInterface-cfg-qshowDelay'>    /**
</span>     * @cfg {Number} qshowDelay
     * Tooltip showDelay.
     */

<span id='Ext-data-NodeInterface-cfg-text'>    /**
</span>     * @cfg {String} text
     * The text to show on node label.
     */

<span id='Ext-data-NodeInterface-cfg-children'>    /**
</span>     * @cfg {Ext.data.NodeInterface[]} children
     * Array of child nodes.
     */


<span id='Ext-data-NodeInterface-property-nextSibling'>    /**
</span>     * @property {Ext.data.NodeInterface} nextSibling
     * A reference to this node&#39;s next sibling node. `null` if this node does not have a next sibling.
     */

<span id='Ext-data-NodeInterface-property-previousSibling'>    /**
</span>     * @property {Ext.data.NodeInterface} previousSibling
     * A reference to this node&#39;s previous sibling node. `null` if this node does not have a previous sibling.
     */

<span id='Ext-data-NodeInterface-property-parentNode'>    /**
</span>     * @property {Ext.data.NodeInterface} parentNode
     * A reference to this node&#39;s parent node. `null` if this node is the root node.
     */

<span id='Ext-data-NodeInterface-property-lastChild'>    /**
</span>     * @property {Ext.data.NodeInterface} lastChild
     * A reference to this node&#39;s last child node. `null` if this node has no children.
     */

<span id='Ext-data-NodeInterface-property-firstChild'>    /**
</span>     * @property {Ext.data.NodeInterface} firstChild
     * A reference to this node&#39;s first child node. `null` if this node has no children.
     */

<span id='Ext-data-NodeInterface-property-childNodes'>    /**
</span>     * @property {Ext.data.NodeInterface[]} childNodes
     * An array of this nodes children.  Array will be empty if this node has no chidren.
     */

    statics: {
<span id='Ext-data-NodeInterface-static-method-decorate'>        /**
</span>         * This method allows you to decorate a Model&#39;s class to implement the NodeInterface.
         * This adds a set of methods, new events, new properties and new fields on every Record.
         * @param {Ext.Class/Ext.data.Model} model The Model class or an instance of the Model class you want to
         * decorate the prototype of.
         * @static
         */
        decorate: function (modelClass) {
            var model = Ext.data.schema.Schema.lookupEntity(modelClass),
                proto = model.prototype,
                idName, idField, idType;
            
            if (!model.prototype.isObservable) {
                model.mixin(Ext.mixin.Observable.prototype.mixinId, Ext.mixin.Observable);
            }
            if (proto.isNode) { // if (already decorated)
                return;
            }

            idName  = proto.idProperty;
            idField = model.getField(idName);
            idType  = idField.type;

            model.override(this.getPrototypeBody());
            model.addFields([
                { name : &#39;parentId&#39;,   type : idType,    defaultValue : null,  allowNull : idField.allowNull            },
                { name : &#39;index&#39;,      type : &#39;int&#39;,     defaultValue : -1,    persist : false          , convert: null },
                { name : &#39;depth&#39;,      type : &#39;int&#39;,     defaultValue : 0,     persist : false          , convert: null },
                { name : &#39;expanded&#39;,   type : &#39;bool&#39;,    defaultValue : false, persist : false          , convert: null },
                { name : &#39;expandable&#39;, type : &#39;bool&#39;,    defaultValue : true,  persist : false          , convert: null },
                { name : &#39;checked&#39;,    type : &#39;auto&#39;,    defaultValue : null,  persist : false          , convert: null },
                { name : &#39;leaf&#39;,       type : &#39;bool&#39;,    defaultValue : false                            },
                { name : &#39;cls&#39;,        type : &#39;string&#39;,  defaultValue : &#39;&#39;,    persist : false          , convert: null },
                { name : &#39;iconCls&#39;,    type : &#39;string&#39;,  defaultValue : &#39;&#39;,    persist : false          , convert: null },
                { name : &#39;icon&#39;,       type : &#39;string&#39;,  defaultValue : &#39;&#39;,    persist : false          , convert: null },
                { name : &#39;root&#39;,       type : &#39;boolean&#39;, defaultValue : false, persist : false          , convert: null },
                { name : &#39;isLast&#39;,     type : &#39;boolean&#39;, defaultValue : false, persist : false          , convert: null },
                { name : &#39;isFirst&#39;,    type : &#39;boolean&#39;, defaultValue : false, persist : false          , convert: null },
                { name : &#39;allowDrop&#39;,  type : &#39;boolean&#39;, defaultValue : true,  persist : false          , convert: null },
                { name : &#39;allowDrag&#39;,  type : &#39;boolean&#39;, defaultValue : true,  persist : false          , convert: null },
                { name : &#39;loaded&#39;,     type : &#39;boolean&#39;, defaultValue : false, persist : false          , convert: null },
                { name : &#39;loading&#39;,    type : &#39;boolean&#39;, defaultValue : false, persist : false          , convert: null },
                { name : &#39;href&#39;,       type : &#39;string&#39;,  defaultValue : &#39;&#39;,    persist : false          , convert: null },
                { name : &#39;hrefTarget&#39;, type : &#39;string&#39;,  defaultValue : &#39;&#39;,    persist : false          , convert: null },
                { name : &#39;qtip&#39;,       type : &#39;string&#39;,  defaultValue : &#39;&#39;,    persist : false          , convert: null },
                { name : &#39;qtitle&#39;,     type : &#39;string&#39;,  defaultValue : &#39;&#39;,    persist : false          , convert: null },
                { name : &#39;qshowDelay&#39;, type : &#39;int&#39;,     defaultValue : 0,     persist : false          , convert: null },
                { name : &#39;children&#39;,   type : &#39;auto&#39;,    defaultValue : null,  persist : false          , convert: null },
                { name : &#39;visible&#39;,    type : &#39;boolean&#39;, defaultValue : true,  persist : false },
                { name : &#39;text&#39;,       type : &#39;string&#39;,                        persist : false }
            ]);
        },

<span id='Ext-data-NodeInterface-static-method-getPrototypeBody'>        getPrototypeBody: function() {
</span>            var bubbledEvents = {
                idchanged     : true,
                append        : true,
                remove        : true,
                move          : true,
                insert        : true,
                beforeappend  : true,
                beforeremove  : true,
                beforemove    : true,
                beforeinsert  : true,
                expand        : true,
                collapse      : true,
                beforeexpand  : true,
                beforecollapse: true,
                sort          : true
            }, silently = {
                silent: true
            };

            // bulkUpdate usage:
            // This is used in 3 contexts:
            // a) When registering nodes. When bulk updating, we don&#39;t want to descend down the tree
            // recursively making calls to register which is redundant. We do need to call it for each node
            // because they need to be findable via id as soon as append events fire, so we only do the minimum needed.
            // b) When setting a data property on the model. We only need to go through set (and the subsequent event chain)
            // so that the UI can update. If we&#39;re doing a bulk update, the UI will update regardless.
            // c) triggerUIUpdate. This is because we know &quot;something has changed&quot;, but not exactly what, so we allow the UI to redraw itself.
            // It has no purpose as far as data goes, so skip it when we can

            return {
<span id='Ext-data-NodeInterface-property-isNode'>                /**
</span>                 * @property {Boolean} isNode
                 * `true` in this class to identify an object as an instantiated Node, or subclass thereof.
                 */
                isNode: true,

                firstChild: null,
                lastChild: null,
                parentNode: null,
                previousSibling: null,
                nextSibling: null,

                constructor: function() {
                    var me = this;

                    me.mixins.observable.constructor.call(me);
                    me.callParent(arguments);
                    me.childNodes = [];

                    // These events are fired on this node, and programatically bubble up the parentNode axis, ending up 
                    // walking off the top and firing on the owning Ext.data.TreeStore
<span id='Ext-data-NodeInterface-event-append'>                    /**
</span>                     * @event append
                     * Fires when a new child node is appended
                     * @param {Ext.data.NodeInterface} this This node
                     * @param {Ext.data.NodeInterface} node The newly appended node
                     * @param {Number} index The index of the newly appended node
                     */
<span id='Ext-data-NodeInterface-event-remove'>                    /**
</span>                     * @event remove
                     * Fires when a child node is removed
                     * @param {Ext.data.NodeInterface} this This node
                     * @param {Ext.data.NodeInterface} node The removed node
                     * @param {Boolean} isMove `true` if the child node is being removed so it can be moved to another position in the tree.
                     * (a side effect of calling {@link Ext.data.NodeInterface#appendChild appendChild} or
                     * {@link Ext.data.NodeInterface#insertBefore insertBefore} with a node that already has a parentNode)
                     */
<span id='Ext-data-NodeInterface-event-move'>                    /**
</span>                     * @event move
                     * Fires when this node is moved to a new location in the tree
                     * @param {Ext.data.NodeInterface} this This node
                     * @param {Ext.data.NodeInterface} oldParent The old parent of this node
                     * @param {Ext.data.NodeInterface} newParent The new parent of this node
                     * @param {Number} index The index it was moved to
                     */
<span id='Ext-data-NodeInterface-event-insert'>                    /**
</span>                     * @event insert
                     * Fires when a new child node is inserted.
                     * @param {Ext.data.NodeInterface} this This node
                     * @param {Ext.data.NodeInterface} node The child node inserted
                     * @param {Ext.data.NodeInterface} refNode The child node the node was inserted before
                     */
<span id='Ext-data-NodeInterface-event-beforeappend'>                    /**
</span>                     * @event beforeappend
                     * Fires before a new child is appended, return false to cancel the append.
                     * @param {Ext.data.NodeInterface} this This node
                     * @param {Ext.data.NodeInterface} node The child node to be appended
                     */
<span id='Ext-data-NodeInterface-event-beforeremove'>                    /**
</span>                     * @event beforeremove
                     * Fires before a child is removed, return false to cancel the remove.
                     * @param {Ext.data.NodeInterface} this This node
                     * @param {Ext.data.NodeInterface} node The child node to be removed
                     * @param {Boolean} isMove `true` if the child node is being removed so it can be moved to another position in the tree.
                     * (a side effect of calling {@link Ext.data.NodeInterface#appendChild appendChild} or
                     * {@link Ext.data.NodeInterface#insertBefore insertBefore} with a node that already has a parentNode)
                     */
<span id='Ext-data-NodeInterface-event-beforemove'>                    /**
</span>                     * @event beforemove
                     * Fires before this node is moved to a new location in the tree. Return false to cancel the move.
                     * @param {Ext.data.NodeInterface} this This node
                     * @param {Ext.data.NodeInterface} oldParent The parent of this node
                     * @param {Ext.data.NodeInterface} newParent The new parent this node is moving to
                     * @param {Number} index The index it is being moved to
                     */
<span id='Ext-data-NodeInterface-event-beforeinsert'>                    /**
</span>                     * @event beforeinsert
                     * Fires before a new child is inserted, return false to cancel the insert.
                     * @param {Ext.data.NodeInterface} this This node
                     * @param {Ext.data.NodeInterface} node The child node to be inserted
                     * @param {Ext.data.NodeInterface} refNode The child node the node is being inserted before
                     */
<span id='Ext-data-NodeInterface-event-expand'>                    /**
</span>                     * @event expand
                     * Fires when this node is expanded.
                     * @param {Ext.data.NodeInterface} this The expanding node
                     */
<span id='Ext-data-NodeInterface-event-collapse'>                    /**
</span>                     * @event collapse
                     * Fires when this node is collapsed.
                     * @param {Ext.data.NodeInterface} this The collapsing node
                     */
<span id='Ext-data-NodeInterface-event-beforeexpand'>                    /**
</span>                     * @event beforeexpand
                     * Fires before this node is expanded.
                     * @param {Ext.data.NodeInterface} this The expanding node
                     */
<span id='Ext-data-NodeInterface-event-beforecollapse'>                    /**
</span>                     * @event beforecollapse
                     * Fires before this node is collapsed.
                     * @param {Ext.data.NodeInterface} this The collapsing node
                     */
<span id='Ext-data-NodeInterface-event-sort'>                    /**
</span>                     * @event sort
                     * Fires when this node&#39;s childNodes are sorted.
                     * @param {Ext.data.NodeInterface} this This node.
                     * @param {Ext.data.NodeInterface[]} childNodes The childNodes of this node.
                     */
                    return me;
                },

<span id='Ext-data-NodeInterface-method-createNode'>                /**
</span>                 * Ensures that the passed object is an instance of a Record with the NodeInterface applied
                 * @return {Ext.data.NodeInterface}
                 */
                createNode: function (node) {
                    var me = this,
                        childType = me.childType,
                        store,
                        storeReader,
                        nodeProxy,
                        nodeReader,
                        reader,
                        typeProperty,
                        T = me.self;

                    // Passed node&#39;s internal data object
                    if (!node.isModel) {
                        // Check this node type&#39;s childType configuration
                        if (childType) {
                            T = me.schema.getEntity(childType);
                        }
                        // See if the reader has a typeProperty and use it if possible
                        else {
                            store = me.getTreeStore();
                            storeReader = store &amp;&amp; store.getProxy().getReader();
                            nodeProxy = me.getProxy();
                            nodeReader = nodeProxy ? nodeProxy.getReader() : null;

                            // If the node&#39;s proxy&#39;s reader was configured with a special typeProperty (property name which defines the child type name) use that.
                            reader = !storeReader || (nodeReader &amp;&amp; nodeReader.initialConfig.typeProperty) ? nodeReader : storeReader;

                            if (reader) {
                                typeProperty = reader.getTypeProperty();
                                if (typeProperty) {
                                    T = reader.getChildType(me.schema, node, typeProperty);
                                }
                            }
                        }

                        node = new T(node);
                    }

                    // The node may already decorated, but may not have been
                    // so when the model constructor was called. If not,
                    // setup defaults here
                    if (!node.childNodes) {
                        node.firstChild = node.lastChild = node.parentNode =
                                node.previousSibling = node.nextSibling = null;
                        node.childNodes = [];
                    }

                    return node;
                },

<span id='Ext-data-NodeInterface-method-isLeaf'>                /**
</span>                 * Returns true if this node is a leaf
                 * @return {Boolean}
                 */
                isLeaf: function() {
                    return this.get(&#39;leaf&#39;) === true;
                },

<span id='Ext-data-NodeInterface-method-setFirstChild'>                /**
</span>                 * Sets the first child of this node
                 * @private
                 * @param {Ext.data.NodeInterface} node
                 */
                setFirstChild: function(node) {
                    this.firstChild = node;
                },

<span id='Ext-data-NodeInterface-method-setLastChild'>                /**
</span>                 * Sets the last child of this node
                 * @private
                 * @param {Ext.data.NodeInterface} node
                 */
                setLastChild: function(node) {
                    this.lastChild = node;
                },

<span id='Ext-data-NodeInterface-method-updateInfo'>                /**
</span>                 * Updates general data of this node like isFirst, isLast, depth. This
                 * method is internally called after a node is moved. This shouldn&#39;t
                 * have to be called by the developer unless they are creating custom
                 * Tree plugins.
                 * @param {Boolean} commit
                 * @param {Object} info The info to update. May contain any of the following
                 *  @param {Object} info.isFirst
                 *  @param {Object} info.isLast
                 *  @param {Object} info.index
                 *  @param {Object} info.depth
                 *  @param {Object} info.parentId
                 */
                updateInfo: function(commit, info) {
                    var me = this,
                        dataObject = me.data,
                        oldDepth = dataObject.depth,
                        childInfo = {},
                        children = me.childNodes,
                        childCount = children.length,
                        phantom = me.phantom,
                        fields = me.fields,
                        modified = me.modified || (me.modified = {}),
                        propName, newValue,
                        field, currentValue, key,
                        newParentId = info.parentId,
                        settingIndexInNewParent,
                        persistentField, i;

                    //&lt;debug&gt;
                    if (!info) {
                        Ext.Error.raise(&#39;NodeInterface expects update info to be passed&#39;);
                    }
                    //&lt;/debug&gt;

                    // Set the passed field values into the data object.
                    // We do NOT need the expense of Model.set. We just need to ensure
                    // that the dirty flag is set.
                    for (propName in info) {
                        field = fields[me.fieldOrdinals[propName]];
                        newValue = info[propName];
                        persistentField = field &amp;&amp; field.persist;

                        currentValue = dataObject[propName];

                        // If we are setting the index value, and the developer has changed it to be persistent, and the
                        // new parent node is different to the starting one, it must be dirty.
                        // The index may be the same value, but it&#39;s in a different parent.
                        // This is so that a Writer can write the correct persistent fields which must include
                        // the index to insert at if the parentId has changed.
                        settingIndexInNewParent = persistentField &amp;&amp; (propName === &#39;index&#39;) &amp;&amp; (currentValue !== -1) &amp;&amp; (newParentId &amp;&amp; newParentId !== modified.parentId);

                        // If new value is the same (unless we are setting the index in a new parent node), then skip the change.
                        if (!settingIndexInNewParent &amp;&amp; me.isEqual(currentValue, newValue)) {
                            continue;
                        }
                        dataObject[propName] = newValue;

                        // Only flag dirty when persistent fields are modified
                        if (persistentField) {

                            // Already modified, just check if we&#39;ve reverted it back to start value (unless we are setting the index in a new parent node)
                            if (!settingIndexInNewParent &amp;&amp; modified.hasOwnProperty(propName)) {

                                // If we have reverted to start value, possibly clear dirty flag
                                if (me.isEqual(modified[propName], newValue)) {
                                    // The original value in me.modified equals the new value, so
                                    // the field is no longer modified:
                                    delete modified[propName];

                                    // We might have removed the last modified field, so check to
                                    // see if there are any modified fields remaining and correct
                                    // me.dirty:
                                    me.dirty = false;
                                    for (key in modified) {
                                        if (modified.hasOwnProperty(key)){
                                            me.dirty = true;
                                            break;
                                        }
                                    }
                                }
                            }

                            // Not already modified, set dirty flag
                            else {
                                me.dirty = true;
                                modified[propName] = currentValue;
                            }
                        }
                    }
                    if (commit) {
                        me.commit();
                        me.phantom = phantom;
                    }

                    // The only way child data can be influenced is if this node has changed level in this update.
                    if (me.data.depth !== oldDepth) {
                        childInfo = {
                            depth: me.data.depth + 1
                        };
                        for (i = 0; i &lt; childCount; i++) {
                            children[i].updateInfo(commit, childInfo);
                        }
                    }
                },

<span id='Ext-data-NodeInterface-method-isLast'>                /**
</span>                 * Returns true if this node is the last child of its parent
                 * @return {Boolean}
                 */
                isLast: function() {
                   return this.get(&#39;isLast&#39;);
                },

<span id='Ext-data-NodeInterface-method-isFirst'>                /**
</span>                 * Returns true if this node is the first child of its parent
                 * @return {Boolean}
                 */
                isFirst: function() {
                   return this.get(&#39;isFirst&#39;);
                },

<span id='Ext-data-NodeInterface-method-hasChildNodes'>                /**
</span>                 * Returns true if this node has one or more child nodes, else false.
                 * @return {Boolean}
                 */
                hasChildNodes: function() {
                    return !this.isLeaf() &amp;&amp; this.childNodes.length &gt; 0;
                },

<span id='Ext-data-NodeInterface-method-isExpandable'>                /**
</span>                 * Returns true if this node has one or more child nodes, or if the &lt;tt&gt;expandable&lt;/tt&gt;
                 * node attribute is explicitly specified as true, otherwise returns false.
                 * @return {Boolean}
                 */
                isExpandable: function() {
                    var me = this;

                    if (me.get(&#39;expandable&#39;)) {
                        return !(me.isLeaf() || (me.isLoaded() &amp;&amp; !me.phantom &amp;&amp; !me.hasChildNodes()));
                    }
                    return false;
                },
                
                triggerUIUpdate: function() {
                    // This isn&#39;t ideal, however none of the underlying fields have changed
                    // but we still need to update the UI
                    // callJoined calls both the Stores we are joined to, and any TreeStore of which we may be a descendant.
                    this.callJoined(&#39;afterEdit&#39;, []);
                },

<span id='Ext-data-NodeInterface-method-appendChild'>                /**
</span>                 * Inserts node(s) as the last child node of this node.
                 *
                 * If the node was previously a child node of another parent node, it will be removed from that node first.
                 *
                 * @param {Ext.data.NodeInterface/Ext.data.NodeInterface[]/Object} node The node or Array of nodes to append
                 * @param {Boolean} [suppressEvents=false] True to suppress firering of events.
                 * @param {Boolean} [commit=false]
                 * @return {Ext.data.NodeInterface} The appended node if single append, or null if an array was passed
                 */
                appendChild: function(node, suppressEvents, commit) {
                    var me = this,
                        i, ln,
                        index,
                        oldParent,
                        previousSibling,
                        childInfo = {
                            isLast: true,
                            parentId: me.getId(),
                            depth: (me.data.depth||0) + 1
                        },
                        result,
                        treeStore = me.getTreeStore(),
                        bulkUpdate = treeStore &amp;&amp; treeStore.bulkUpdate;

                    // Coalesce all layouts caused by node append
                    Ext.suspendLayouts();

                    // if passed an array do them one by one
                    if (Ext.isArray(node)) {
                        ln = node.length;
                        result = new Array(ln);
                        // Suspend view updating and data syncing during update
                        me.callTreeStore(&#39;beginFill&#39;);
                        for (i = 0; i &lt; ln; i++) {
                            result[i] = me.appendChild(node[i], suppressEvents, commit);
                        }
                        // Resume view updating and data syncing after appending all new children.
                        // This will fire the add event to any views (if its the top level append)
                        me.callTreeStore(&#39;endFill&#39;, [result]);
                    } else {
                        // Make sure it is a record
                        node = me.createNode(node);

                        if (suppressEvents !== true &amp;&amp; me.fireEventArgs(&#39;beforeappend&#39;, [me, node]) === false) {
                            return false;
                        }

                        index = me.childNodes.length;
                        oldParent = node.parentNode;

                        // it&#39;s a move, make sure we move it cleanly
                        if (oldParent) {
                            // Return false if a beforeremove listener vetoed the remove
                            if (oldParent.removeChild(node, false, suppressEvents, oldParent.getTreeStore() === treeStore) === false) {
                                return false;
                            }
                        }

                        // Coalesce sync operations across this operation
                        // Node field setting (loaded, expanded) and node addition both trigger a sync if autoSync is set.
                        treeStore &amp;&amp; treeStore.beginUpdate();

                        index = me.childNodes.length;
                        if (index === 0) {
                            me.setFirstChild(node);
                        }

                        me.childNodes[index] = node;
                        node.parentNode = me;
                        node.nextSibling = null;

                        me.setLastChild(node);

                        previousSibling = me.childNodes[index - 1];
                        if (previousSibling) {
                            node.previousSibling = previousSibling;
                            previousSibling.nextSibling = node;
                            previousSibling.updateInfo(commit, {
                                isLast: false
                            });
                            // No need to trigger a ui update if we&#39;re doing a bulk update
                            if (!bulkUpdate) {
                                previousSibling.triggerUIUpdate();
                            }
                        } else {
                            node.previousSibling = null;
                        }

                        // Update the new child&#39;s info passing in info we already know
                        childInfo.isFirst = index === 0;
                        childInfo.index = index;
                        node.updateInfo(commit, childInfo);

                        // We stop being a leaf as soon as a node is appended
                        if (me.isLeaf()) {
                            me.set(&#39;leaf&#39;, false);
                        }

                        // As soon as we append a child to this node, we are loaded
                        if (!me.isLoaded()) {
                            if (bulkUpdate) {
                                me.data.loaded = true;
                            } else {
                                me.set(&#39;loaded&#39;, true);
                            }
                        } else if (me.childNodes.length === 1 &amp;&amp; !bulkUpdate) {
                            me.triggerUIUpdate();
                        }

                        // Ensure connectors are correct by updating the UI on all intervening nodes (descendants) between last sibling and new node.
                        if (index &amp;&amp; me.childNodes[index - 1].isExpanded() &amp;&amp; !bulkUpdate) {
                            me.childNodes[index - 1].cascadeBy(me.triggerUIUpdate);
                        }

                        // We register the subtree before we proceed so relayed events
                        // (like nodeappend) from our TreeStore (if we have one) will be
                        // able to use getNodeById. The node also needs to be added since 
                        // we&#39;re passing it in the events below. If we&#39;re not bulk updating, it
                        // means we&#39;re just appending a node (with possible children), so do it
                        // deeply here to ensure everything is captured.
                        if (treeStore) {
                            treeStore.registerNode(me, !bulkUpdate);
                            if (bulkUpdate) {
                                treeStore.registerNode(node);
                            }
                        }

                        // This node MUST fire its events first, so that if the TreeStore&#39;s
                        // onNodeAppend loads and appends local children, the events are still in order;
                        // This node appended this child first, before the descendant cascade.
                        if (suppressEvents !== true) {
                            me.fireEventArgs(&#39;append&#39;, [me, node, index]);

                            if (oldParent) {
                                node.fireEventArgs(&#39;move&#39;, [node, oldParent, me, index]);
                            }
                        }

                        // Inform the TreeStore so that the node can be inserted
                        // and registered.
                        me.callTreeStore(&#39;onNodeAppend&#39;, [node, index]);

                        result = node;

                        // Coalesce sync operations across this operation
                        // Node field setting (loaded, expanded) and node addition both trigger a sync if autoSync is set.
                        if (treeStore) {
                            treeStore.endUpdate();
                        }
                    }

                    // Flush layouts caused by updating of the UI
                    Ext.resumeLayouts(true);

                    return result;
                },

<span id='Ext-data-NodeInterface-method-getOwnerTree'>                /**
</span>                * Returns the tree this node is in.
                * @return {Ext.tree.Panel} The tree panel which owns this node.
                */
                getOwnerTree: function() {
                    var store = this.getTreeStore();
                    if (store) {
                        return store.ownerTree;
                    }
                },

<span id='Ext-data-NodeInterface-method-getTreeStore'>                /**
</span>                 * Returns the {@link Ext.data.TreeStore} which owns this node.
                 * @return {Ext.data.TreeStore} The TreeStore which owns this node.
                 */
                getTreeStore: function() {
                    var root = this;

                    while (root &amp;&amp; !root.treeStore) {
                        root = root.parentNode;
                    }
                    return root &amp;&amp; root.treeStore;
                },

<span id='Ext-data-NodeInterface-method-removeChild'>                /**
</span>                 * Removes a child node from this node.
                 * @param {Ext.data.NodeInterface} node The node to remove
                 * @param {Boolean} [erase=false] True to erase the record using the
                 * configured proxy.
                 * @return {Ext.data.NodeInterface} The removed node
                 */
                removeChild: function(node, erase, suppressEvents, isMove) {
                    var me = this,
                        index = me.indexOf(node),
                        i, childCount,
                        previousSibling,
                        treeStore = me.getTreeStore(),
                        bulkUpdate = treeStore &amp;&amp; treeStore.bulkUpdate;

                    if (index === -1 || (suppressEvents !== true &amp;&amp; me.fireEventArgs(&#39;beforeremove&#39;, [me, node, !!isMove]) === false)) {
                        return false;
                    }

                    // Coalesce all layouts caused by node removal
                    Ext.suspendLayouts();

                    // Coalesce sync operations across this operation
                    treeStore &amp;&amp; treeStore.beginUpdate();

                    // remove it from childNodes collection
                    Ext.Array.erase(me.childNodes, index, 1);

                    // update child refs
                    if (me.firstChild === node) {
                        me.setFirstChild(node.nextSibling);
                    }
                    if (me.lastChild === node) {
                        me.setLastChild(node.previousSibling);
                    }

                    // Update previous sibling to point to its new next.
                    previousSibling = node.previousSibling;
                    if (previousSibling) {
                        node.previousSibling.nextSibling = node.nextSibling;
                    }
                    
                    // Update the next sibling to point to its new previous
                    if (node.nextSibling) {
                        node.nextSibling.previousSibling = node.previousSibling;

                        // And if it&#39;s the new first child, let it know
                        if (index === 0) {
                            node.nextSibling.updateInfo(false, {
                                isFirst: true
                            });
                        }

                        // Update subsequent siblings&#39; index values
                        for (i = index, childCount = me.childNodes.length; i &lt; childCount; i++) {
                            me.childNodes[i].updateInfo(false, {
                                index: i
                            });
                        }
                    }

                    // If the removed node had no next sibling, but had a previous,
                    // update the previous sibling so it knows it&#39;s the last
                    else if (previousSibling) {
                        previousSibling.updateInfo(false, {
                            isLast: true
                        });

                        // We&#39;re removing the last child.
                        // Ensure connectors are correct by updating the UI on all intervening nodes (descendants) between previous sibling and new node.
                        if (!bulkUpdate) {
                            if (previousSibling.isExpanded()) {
                                previousSibling.cascadeBy(me.triggerUIUpdate);
                            }
                            // No intervening descendant nodes, just update the previous sibling
                            else {
                                previousSibling.triggerUIUpdate();
                            }
                        }
                    }

                    // If this node suddenly doesnt have childnodes anymore, update myself
                    if (!me.childNodes.length &amp;&amp; !bulkUpdate) {
                        me.triggerUIUpdate();
                    }

                    // Flush layouts caused by updating the UI
                    Ext.resumeLayouts(true);

                    if (suppressEvents !== true) {

                        // Inform the TreeStore so that descendant nodes can be removed.
                        me.callTreeStore(&#39;beforeNodeRemove&#39;, [[node], !!isMove]);

                        node.previousSibling = node.nextSibling = node.parentNode = null;

                        me.fireEventArgs(&#39;remove&#39;, [me, node, !!isMove]);

                        // Inform the TreeStore so that the node unregistered and unjoined.
                        me.callTreeStore(&#39;onNodeRemove&#39;, [[node], !!isMove]);
                    }

                    // Update removed node&#39;s pointers *after* firing event so that listeners
                    // can tell where the removal took place
                    if (erase) {
                        node.erase(true);
                    } else {
                        node.clear();
                    }

                    // Must clear the parentNode silently upon remove from the TreeStore.
                    // Any subsequent append to any node will trigger dirtiness
                    // (It may be added to a deifferent node of the same ID, eg &quot;root&quot;).
                    // lastParentId still needed for TreeStore&#39;s clearRemovedOnLoad functionality to be able to link
                    // nodes in the removed array to nodes under the reloading node&#39;s tree.
                    // to be able to 
                    if (!isMove) {
                        node.set({
                            parentId: null,
                            lastParentId: me.getId()
                        }, silently);
                    }

                    // Coalesce sync operations across this operation
                    if (treeStore) {
                        treeStore.endUpdate();
                    }

                    return node;
                },

<span id='Ext-data-NodeInterface-method-copy'>                /**
</span>                 * Creates a copy (clone) of this Node.
                 * @param {String} [id] A new id, defaults to this Node&#39;s id.
                 * @param {Boolean} [deep=false] True to recursively copy all child Nodes into the new Node.
                 * False to copy without child Nodes.
                 * @return {Ext.data.NodeInterface} A copy of this Node.
                 */
                copy: function(newId, deep) {
                    var me = this,
                        result = me.callParent([newId, deep]),
                        len = me.childNodes ? me.childNodes.length : 0,
                        i;

                    // Move child nodes across to the copy if required
                    if (deep) {
                        for (i = 0; i &lt; len; i++) {
                            result.appendChild(me.childNodes[i].copy(undefined, true));
                        }
                    }
                    return result;
                },

<span id='Ext-data-NodeInterface-method-clear'>                /**
</span>                 * Clears the node.
                 * @private
                 * @param {Boolean} [erase=false] True to erase the node using the configured
                 * proxy.
                 */
                clear: function(erase) {
                    var me = this;

                    // clear any references from the node
                    me.parentNode = me.previousSibling = me.nextSibling = null;
                    if (erase) {
                        me.firstChild = me.lastChild = me.childNodes = null;
                    }
                },

                drop: function() {
                    var me = this,
                        childNodes = me.childNodes,
                        parentNode = me.parentNode,
                        len = childNodes ? childNodes.length : 0,
                        i,
                        node,
                        treeStore;

                    // Ensure Model operations are performed.
                    // Store removal is NOT handled.
                    // TreeStore&#39;s afterDrop does nothing.
                    me.callParent();

                    // If called in recursion from here, there&#39;ll be no parentNode
                    if (parentNode) {
                        treeStore = me.getTreeStore();
                        // TreeStore.onNodeRemove also adds invisible descendant nodes to the remove tracking array.
                        parentNode.removeChild(me);
                    }
                    // If we are the root, there&#39;ll be no parent node. It&#39;s a special case. We must update the TreeStore&#39;s root with a null node.
                    else if (me.get(&#39;root&#39;)) {
                        treeStore = me.getTreeStore();
                        treeStore.setRoot(null);
                    }
                    // Removing a node removes the node and all *VISIBLE* descendant nodes from the Store and
                    // adds them to the remove tracking array.
                    //
                    // After this point, no descendant nodes have a connection to the TreeStore.

                    // Coalesce sync operations across this operation
                    treeStore &amp;&amp; treeStore.beginUpdate();


                    // Recurse down dropping all descendants.
                    // This will NOT remove them from the store&#39;s data collection
                    for (i = 0; i &lt; len; i++) {
                        node = childNodes[i];

                        // Detach descendant nodes so that they do not all attempt to perform removal from the parent.
                        node.clear();

                        // Drop descendant nodes.
                        node.drop();
                    }

                    // Coalesce sync operations across this operation
                    treeStore &amp;&amp; treeStore.endUpdate();
                },

<span id='Ext-data-NodeInterface-method-erase'>                /**
</span>                 * Destroys the node.
                 */
                erase: function(options) {
                    var me = this,
                        childNodes = me.childNodes,
                        len = childNodes &amp;&amp; childNodes.length,
                        i,
                        node;

                    // This unhooks this node from the tree structure
                    // The UI is updated.
                    // Now to recursively erase.
                    me.remove();

                    // Clear removes linkage, so the erase&#39;s call into drop cannot recurse.
                    // this method has to recurse to do all its stuff.
                    me.clear(true);
                    me.callParent([options]);
                    for (i = 0; i &lt; len; i++) {
                        node = childNodes[i];

                        // The top level in the cascade is already removed.
                        // Prevent the recursive erase calls doing further node removal.
                        node.parentNode = null;
                        node.erase(options);
                    }
                },

<span id='Ext-data-NodeInterface-method-insertBefore'>                /**
</span>                 * Inserts the first node before the second node in this nodes childNodes collection.
                 * @param {Ext.data.NodeInterface/Ext.data.NodeInterface[]/Object} node The node to insert
                 * @param {Ext.data.NodeInterface} refNode The node to insert before (if null the node is appended)
                 * @return {Ext.data.NodeInterface} The inserted node
                 */
                insertBefore: function(node, refNode, suppressEvents) {
                    var me = this,
                        index     = me.indexOf(refNode),
                        oldParent = node.parentNode,
                        refIndex  = index,
                        childCount, previousSibling, i,
                        treeStore = me.getTreeStore(),
                        bulkUpdate = treeStore &amp;&amp; treeStore.bulkUpdate;

                    if (!refNode) { // like standard Dom, refNode can be null for append
                        return me.appendChild(node);
                    }

                    // nothing to do
                    if (node === refNode) {
                        return false;
                    }

                    // Make sure it is a record with the NodeInterface
                    node = me.createNode(node);

                    if (suppressEvents !== true &amp;&amp; me.fireEventArgs(&#39;beforeinsert&#39;, [me, node, refNode]) === false) {
                        return false;
                    }

                    // when moving internally, indexes will change after remove
                    if (oldParent === me &amp;&amp; me.indexOf(node) &lt; index) {
                        refIndex--;
                    }

                    // it&#39;s a move, make sure we move it cleanly
                    if (oldParent) {
                        // Return false if a beforeremove listener vetoed the remove
                        if (oldParent.removeChild(node, false, suppressEvents, oldParent.getTreeStore() === treeStore) === false) {
                            return false;
                        }
                    }

                    // Coalesce sync operations across this operation
                    // Node field setting (loaded, expanded) and node addition both trigger a sync if autoSync is set.
                    // Nodes acquire a treeStore early now by virtue of getting a parentNode, so set operations on them will
                    // arrive to this Store&#39;s onCollectionUpdate
                    treeStore &amp;&amp; treeStore.beginUpdate();

                    if (refIndex === 0) {
                        me.setFirstChild(node);
                    }

                    Ext.Array.splice(me.childNodes, refIndex, 0, node);
                    node.parentNode = me;

                    node.nextSibling = refNode;
                    refNode.previousSibling = node;

                    previousSibling = me.childNodes[refIndex - 1];
                    if (previousSibling) {
                        node.previousSibling = previousSibling;
                        previousSibling.nextSibling = node;
                    } else {
                        node.previousSibling = null;
                    }

                    // Integrate the new node into its new position.
                    node.updateInfo(false, {
                        parentId: me.getId(),
                        index: refIndex,
                        isFirst: refIndex === 0,
                        isLast: false,
                        depth: (me.data.depth||0) + 1
                    });

                    // Update the index for all following siblings.
                    for (i = refIndex + 1, childCount = me.childNodes.length; i &lt; childCount; i++) {
                        me.childNodes[i].updateInfo(false, {
                            index: i
                        });
                    }

                    if (!me.isLoaded()) {
                        if (bulkUpdate) {
                            me.data.loaded = true;
                        } else {
                            me.set(&#39;loaded&#39;, true);
                        }
                    }
                    // If this node didnt have any childnodes before, update myself
                    else if (me.childNodes.length === 1 &amp;&amp; !bulkUpdate) {
                        me.triggerUIUpdate();
                    }

                    // We register the subtree before we proceed so relayed events
                    // (like nodeappend) from our TreeStore (if we have one) will be
                    // able to use getNodeById.
                    if (treeStore) {
                        treeStore.registerNode(me, !bulkUpdate);
                    }

                    // This node MUST fire its events first, so that if the TreeStore&#39;s
                    // onNodeInsert loads and appends local children, the events are still in order;
                    // This node appended this child first, before the descendant cascade.
                    if (suppressEvents !== true) {
                        me.fireEventArgs(&#39;insert&#39;, [me, node, refNode]);

                        if (oldParent) {
                            node.fireEventArgs(&#39;move&#39;, [node, oldParent, me, refIndex, refNode]);
                        }
                    }

                    // Inform the TreeStore so that the node can be registered and added
                    me.callTreeStore(&#39;onNodeInsert&#39;, [node, refIndex]);

                    // Coalesce sync operations across this operation
                    // Node field setting (loaded, expanded) and node addition both trigger a sync if autoSync is set.
                    if (treeStore) {
                        treeStore.endUpdate();
                    }

                    return node;
                },

<span id='Ext-data-NodeInterface-method-insertChild'>                /**
</span>                 * Inserts a node into this node.
                 * @param {Number} index The zero-based index to insert the node at
                 * @param {Ext.data.NodeInterface/Object} node The node to insert
                 * @return {Ext.data.NodeInterface} The node you just inserted
                 */
                insertChild: function(index, node) {
                    var sibling = this.childNodes[index];
                    if (sibling) {
                        return this.insertBefore(node, sibling);
                    }
                    else {
                        return this.appendChild(node);
                    }
                },

<span id='Ext-data-NodeInterface-method-isLastVisible'>                /**
</span>                 * @private
                 * Used by {@link Ext.tree.Column#initTemplateRendererData} to determine whether a node is the last *visible*
                 * sibling.
                 * 
                 */
                isLastVisible: function() {
                    var me = this,
                        result = me.data.isLast,
                        next = me.nextSibling;

                    // If it is not the true last and the store is filtered
                    // we need to see if any following siblings are visible.
                    // If any are, return false.
                    if (!result &amp;&amp; me.getTreeStore().isFiltered()) {
                        while (next) {
                            if (next.data.visible) {
                                return false;
                            }
                            next = next.nextSibling;
                        }
                        return true;
                    }
                    return result;
                },

<span id='Ext-data-NodeInterface-method-remove'>                /**
</span>                 * Removes this node from its parent.
                 *
                 * **If** the node is not phantom (only added in the client side), then it may be marked for removal.
                 *
                 * If the owning {@link Ext.data.TreeStore tree store} is set to {@link Ext.data.ProxyStore#trackRemoved track removed}
                 * then the node will be added to the stack of nodes due to be removed the next time the store is synced with the server.
                 *
                 * If the owning {@link Ext.data.TreeStore tree store} is set to {@link Ext.data.ProxyStore#autoSync auto synchronize}
                 * then the synchronize request will be initiated immediately.
                 *
                 * @param {Boolean} [erase=false] True to erase the node using the configured proxy. This is only needed when the
                 * owning {@link Ext.data.TreeStore tree store} is not taking care of synchronization operations.
                 *
                 * @return {Ext.data.NodeInterface} this
                 */
                remove: function(erase, suppressEvents) {
                    var me = this,
                        parentNode = me.parentNode;

                    if (parentNode) {
                        parentNode.removeChild(me, erase, suppressEvents);
                    } else if (erase) {
                        // If we don&#39;t have a parent, just erase it
                        me.erase(true);
                    }
                    return me;
                },

<span id='Ext-data-NodeInterface-method-removeAll'>                /**
</span>                 * Removes all child nodes from this node.
                 * @param {Boolean} [erase=false] True to erase the node using the configured
                 * proxy.
                 * @return {Ext.data.NodeInterface} this
                 * @return {Ext.data.NodeInterface} this
                 */
                removeAll: function(erase, suppressEvents, fromParent) {
                    // This method duplicates logic from removeChild for the sake of
                    // speed since we can make a number of assumptions because we&#39;re
                    // getting rid of everything
                    var me = this,
                        childNodes = me.childNodes,
                        i = 0,
                        len = childNodes.length,
                        node,
                        treeStore;

                    // Avoid all this if nothing to remove
                    if (!len) {
                        return;
                    }

                    // Inform the TreeStore so that descendant nodes can be removed.
                    if (!fromParent) {
                        treeStore = me.getTreeStore();

                        // Coalesce sync operations across this operation
                        treeStore &amp;&amp; treeStore.beginUpdate();

                        // The remove of visible descendants is handled by the top level
                        // call to onNodeRemove, so suspend firing the remove event so
                        // that every descendant remove does not update the UI.
                        treeStore.suspendEvent(&#39;remove&#39;);

                        me.callTreeStore(&#39;beforeNodeRemove&#39;, [childNodes, false]);
                    }

                    for (; i &lt; len; ++i) {
                        node = childNodes[i];

                        node.previousSibling = node.nextSibling = node.parentNode = null;

                        me.fireEventArgs(&#39;remove&#39;, [me, node, false]);

                        if (erase) {
                            node.erase(true);
                        }
                        // Otherwise.... apparently, removeAll is always recursive.
                        else {
                            node.removeAll(false, suppressEvents, true);
                        }
                    }

                    // Inform the TreeStore so that all descendants are unregistered and unjoined.
                    if (!fromParent) {
                        treeStore.resumeEvent(&#39;remove&#39;);
                        me.callTreeStore(&#39;onNodeRemove&#39;, [childNodes, false]);

                        // Coalesce sync operations across this operation
                        treeStore &amp;&amp; treeStore.endUpdate();
                    }

                    me.firstChild = me.lastChild = null;

                    me.childNodes.length = 0;
                    if (!fromParent) {
                        me.triggerUIUpdate();
                    }
                    
                    return me;
                },

<span id='Ext-data-NodeInterface-method-getChildAt'>                /**
</span>                 * Returns the child node at the specified index.
                 * @param {Number} index
                 * @return {Ext.data.NodeInterface}
                 */
                getChildAt: function(index) {
                    return this.childNodes[index];
                },

<span id='Ext-data-NodeInterface-method-replaceChild'>                /**
</span>                 * Replaces one child node in this node with another.
                 * @param {Ext.data.NodeInterface} newChild The replacement node
                 * @param {Ext.data.NodeInterface} oldChild The node to replace
                 * @return {Ext.data.NodeInterface} The replaced node
                 */
                replaceChild: function(newChild, oldChild, suppressEvents) {
                    var s = oldChild ? oldChild.nextSibling : null;

                    this.removeChild(oldChild, false, suppressEvents);
                    this.insertBefore(newChild, s, suppressEvents);
                    return oldChild;
                },

<span id='Ext-data-NodeInterface-method-indexOf'>                /**
</span>                 * Returns the index of a child node
                 * @param {Ext.data.NodeInterface} node
                 * @return {Number} The index of the node or -1 if it was not found
                 */
                indexOf: function(child) {
                    return Ext.Array.indexOf(this.childNodes, child);
                },
                
<span id='Ext-data-NodeInterface-method-indexOfId'>                /**
</span>                 * Returns the index of a child node that matches the id
                 * @param {String} id The id of the node to find
                 * @return {Number} The index of the node or -1 if it was not found
                 */
                indexOfId: function(id) {
                    var childNodes = this.childNodes,
                        len = childNodes.length,
                        i = 0;
                        
                    for (; i &lt; len; ++i) {
                        if (childNodes[i].getId() === id) {
                            return i;
                        }    
                    }
                    return -1;
                },

<span id='Ext-data-NodeInterface-method-getPath'>                /**
</span>                 * Gets the hierarchical path from the root of the current node.
                 * @param {String} [field] The field to construct the path from. Defaults to the model idProperty.
                 * @param {String} [separator=&#39;/&#39;] A separator to use.
                 * @return {String} The node path
                 */
                getPath: function(field, separator) {
                    field = field || this.idProperty;
                    separator = separator || &#39;/&#39;;

                    var path = [this.get(field)],
                        parent = this.parentNode;

                    while (parent) {
                        path.unshift(parent.get(field));
                        parent = parent.parentNode;
                    }
                    return separator + path.join(separator);
                },

<span id='Ext-data-NodeInterface-method-getDepth'>                /**
</span>                 * Returns depth of this node (the root node has a depth of 0)
                 * @return {Number}
                 */
                getDepth: function() {
                    return this.get(&#39;depth&#39;);
                },

<span id='Ext-data-NodeInterface-method-bubble'>                /**
</span>                 * Bubbles up the tree from this node, calling the specified function with each node. The arguments to the function
                 * will be the args provided or the current node. If the function returns false at any point,
                 * the bubble is stopped.
                 * @param {Function} fn The function to call
                 * @param {Object} [scope] The scope (this reference) in which the function is executed. Defaults to the current Node.
                 * @param {Array} [args] The args to call the function with. Defaults to passing the current Node.
                 */
                bubble: function(fn, scope, args) {
                    var p = this;
                    while (p) {
                        if (fn.apply(scope || p, args || [p]) === false) {
                            break;
                        }
                        p = p.parentNode;
                    }
                },

                //&lt;deprecated since=0.99&gt;
                cascade: function() {
                    if (Ext.isDefined(Ext.global.console)) {
                        Ext.global.console.warn(&#39;Ext.data.Node: cascade has been deprecated. Please use cascadeBy instead.&#39;);
                    }
                    return this.cascadeBy.apply(this, arguments);
                },
                //&lt;/deprecated&gt;

<span id='Ext-data-NodeInterface-method-cascadeBy'>                /**
</span>                 * Cascades down the tree from this node, calling the specified functions with each node. The arguments to the function
                 * will be the args provided or the current node. If the `before` function returns false at any point,
                 * the cascade is stopped on that branch.
                 *
                 * Note that the 3 argument form passing `fn, scope, args` is still supported. The `fn` function is as before, called
                 * *before* cascading down into child nodes. If it returns `false`, the child nodes are not traversed.
                 *
                 * @param {Object} spec An object containing before and after functions, scope and an argument list.
                 * @param {Function} [spec.before] A function to call on a node *before* cascading down into child nodes.
                 * If it returns `false`, the child nodes are not traversed.
                 * @param {Function} [spec.after] A function to call on a node *after* cascading down into child nodes.
                 * @param {Object} [spec.scope] The scope (this reference) in which the functions are executed. Defaults to the current Node.
                 * @param {Array} [spec.args] The args to call the function with. Defaults to passing the current Node.
                 */
                cascadeBy: function(before, scope, args, after) {
                    var me = this;

                    if (arguments.length === 1 &amp;&amp; !Ext.isFunction(before)) {
                        after = before.after;
                        scope = before.scope;
                        args = before.args;
                        before = before.before;
                    }
                    if (!before || before.apply(scope || me, args || [me]) !== false) {
                        var childNodes = me.childNodes,
                            length     = childNodes.length,
                            i;

                        for (i = 0; i &lt; length; i++) {
                            childNodes[i].cascadeBy.call(childNodes[i], before, scope, args, after);
                        }

                        if (after) {
                            after.apply(scope || me, args || [me]);
                        }
                    }
                },

<span id='Ext-data-NodeInterface-method-eachChild'>                /**
</span>                 * Interates the child nodes of this node, calling the specified function with each node. The arguments to the function
                 * will be the args provided or the current node. If the function returns false at any point,
                 * the iteration stops.
                 * @param {Function} fn The function to call
                 * @param {Object} [scope] The scope (this reference) in which the function is executed. Defaults to the current Node in iteration.
                 * @param {Array} [args] The args to call the function with. Defaults to passing the current Node.
                 */
                eachChild: function(fn, scope, args) {
                    var childNodes = this.childNodes,
                        length     = childNodes.length,
                        i;

                    for (i = 0; i &lt; length; i++) {
                        if (fn.apply(scope || this, args || [childNodes[i]]) === false) {
                            break;
                        }
                    }
                },

<span id='Ext-data-NodeInterface-method-findChild'>                /**
</span>                 * Finds the first child that has the attribute with the specified value.
                 * @param {String} attribute The attribute name
                 * @param {Object} value The value to search for
                 * @param {Boolean} [deep=false] True to search through nodes deeper than the immediate children
                 * @return {Ext.data.NodeInterface} The found child or null if none was found
                 */
                findChild: function(attribute, value, deep) {
                    return this.findChildBy(function() {
                        return this.get(attribute) == value;
                    }, null, deep);
                },

<span id='Ext-data-NodeInterface-method-findChildBy'>                /**
</span>                 * Finds the first child by a custom function. The child matches if the function passed returns true.
                 * @param {Function} fn A function which must return true if the passed Node is the required Node.
                 * @param {Object} [scope] The scope (this reference) in which the function is executed. Defaults to the Node being tested.
                 * @param {Boolean} [deep=false] True to search through nodes deeper than the immediate children
                 * @return {Ext.data.NodeInterface} The found child or null if none was found
                 */
                findChildBy: function(fn, scope, deep) {
                    var cs = this.childNodes,
                        len = cs.length,
                        i = 0, n, res;

                    for (; i &lt; len; i++) {
                        n = cs[i];
                        if (fn.call(scope || n, n) === true) {
                            return n;
                        }
                        else if (deep) {
                            res = n.findChildBy(fn, scope, deep);
                            if (res !== null) {
                                return res;
                            }
                        }
                    }

                    return null;
                },

<span id='Ext-data-NodeInterface-method-contains'>                /**
</span>                 * Returns true if this node is an ancestor (at any point) of the passed node.
                 * @param {Ext.data.NodeInterface} node
                 * @return {Boolean}
                 */
                contains: function(node) {
                    return node.isAncestor(this);
                },

<span id='Ext-data-NodeInterface-method-isAncestor'>                /**
</span>                 * Returns true if the passed node is an ancestor (at any point) of this node.
                 * @param {Ext.data.NodeInterface} node
                 * @return {Boolean}
                 */
                isAncestor: function(node) {
                    var p = this.parentNode;
                    while (p) {
                        if (p === node) {
                            return true;
                        }
                        p = p.parentNode;
                    }
                    return false;
                },

<span id='Ext-data-NodeInterface-method-sort'>                /**
</span>                 * Sorts this nodes children using the supplied sort function.
                 * @param {Function} [sortFn] A function which, when passed two Nodes, returns -1, 0 or 1 depending upon required sort order.
                 *
                 * It omitted, the node is sorted according to the existing sorters in the owning {@link Ext.data.TreeStore TreeStore}.
                 * @param {Boolean} [recursive=false] True to apply this sort recursively
                 * @param {Boolean} [suppressEvent=false] True to not fire a sort event.
                 */
                sort: function(sortFn, recursive, suppressEvent) {
                    var me = this,
                        childNodes  = me.childNodes,
                        ln = childNodes.length,
                        i, n, info = {
                            isFirst: true
                        };

                    if (ln &gt; 0) {
                        if (!sortFn) {
                            sortFn = me.getTreeStore().getSortFn();
                        }
                        Ext.Array.sort(childNodes, sortFn);
                        me.setFirstChild(childNodes[0]);
                        me.setLastChild(childNodes[ln - 1]);

                        for (i = 0; i &lt; ln; i++) {
                            n = childNodes[i];
                            n.previousSibling = childNodes[i-1];
                            n.nextSibling = childNodes[i+1];
                            
                            // Update the index and first/last status of children
                            info.isLast = (i === ln - 1);
                            info.index = i;
                            n.updateInfo(false, info);
                            info.isFirst = false;

                            if (recursive &amp;&amp; !n.isLeaf()) {
                                n.sort(sortFn, true, true);
                            }
                        }

                        // The suppressEvent flag is basically used to indicate a recursive sort
                        if (suppressEvent !== true) {
                            me.fireEventArgs(&#39;sort&#39;, [me, childNodes]);

                            // Inform the TreeStore that this node is sorted
                            me.callTreeStore(&#39;onNodeSort&#39;, [childNodes]);
                        }
                    }
                },

<span id='Ext-data-NodeInterface-method-isExpanded'>                /**
</span>                 * Returns `true` if this node is expanded.
                 * @return {Boolean}
                 */
                isExpanded: function() {
                    return this.get(&#39;expanded&#39;);
                },

<span id='Ext-data-NodeInterface-method-isLoaded'>                /**
</span>                 * Returns true if this node is loaded
                 * @return {Boolean}
                 */
                isLoaded: function() {
                    return this.get(&#39;loaded&#39;);
                },
                
<span id='Ext-data-NodeInterface-method-isBranchLoaded'>                /**
</span>                 * Returns true if this node is a branch node, and the entire branch is fully loaded.
                 *
                 * Using this method, it is possible to ascertain whether an {@link #expandAll} call
                 * will have access to all descendant nodes without incurring a store load.
                 * @return {Boolean}
                 */
                isBranchLoaded: function() {
                    var isBranchLoaded = !this.isLeaf() &amp;&amp; this.isLoaded();

                    if (isBranchLoaded) {
                        this.cascadeBy(function(node) {
                            if (!node.isLeaf()) {
                                isBranchLoaded = isBranchLoaded || node.isBranchLoaded();
                            }
                            return isBranchLoaded;
                        });
                    }
                    return isBranchLoaded;
                },

<span id='Ext-data-NodeInterface-method-isLoading'>                /**
</span>                 * Returns true if this node is loading
                 * @return {Boolean}
                 */
                isLoading: function() {
                    return this.get(&#39;loading&#39;);
                },

<span id='Ext-data-NodeInterface-method-isRoot'>                /**
</span>                 * Returns true if this node is the root node
                 * @return {Boolean}
                 */
                isRoot: function() {
                    return !this.parentNode;
                },

<span id='Ext-data-NodeInterface-method-isVisible'>                /**
</span>                 * Returns true if this node is visible. Note that visibility refers to
                 * the structure of the tree, the {@link Ext.tree.Panel#rootVisible}
                 * configuration is not taken into account here. If this method is called
                 * on the root node, it will always be visible.
                 * @return {Boolean}
                 */
                isVisible: function() {
                    var parent = this.parentNode;
                    while (parent) {
                        if (!parent.isExpanded()) {
                            return false;
                        }
                        parent = parent.parentNode;
                    }
                    return true;
                },

<span id='Ext-data-NodeInterface-method-expand'>                /**
</span>                 * Expand this node.
                 * @param {Boolean} [recursive=false] True to recursively expand all the children
                 * @param {Function} [callback] The function to execute once the expand completes
                 * @param {Object} [scope] The scope to run the callback in
                 */
                expand: function(recursive, callback, scope) {
                    var me = this,
                        treeStore,
                        resumeAddEvent;

                    // all paths must call the callback (eventually) or things like
                    // selectPath fail

                    // First we start by checking if this node is a parent
                    if (!me.isLeaf()) {
                        // If it&#39;s loading, wait until it loads before proceeding
                        if (me.isLoading()) {
                            me.on(&#39;expand&#39;, function() {
                                me.expand(recursive, callback, scope);
                            }, me, {single: true});
                        } else {
                            // Now we check if this record is already expanding or expanded
                            if (!me.isExpanded()) {

                                if (me.fireEventArgs(&#39;beforeexpand&#39;, [me]) !== false) {

                                    // Here we are testing if all the descendant nodes required by a recursive expansion
                                    // are available without an asynchronous store load.
                                    //
                                    // That is either all branch nodes are loaded, or the store loads synchronously.
                                    //
                                    // If that is the case, then we do not want the TreeStore to fire add events
                                    // and update the UI (and layout) for every batch of child nodes inserted.
                                    // Instead, we suspend the add event, and at the end, fire a data refresh
                                    // so that the UI gets only one update. It will be a view refresh, but will
                                    // still be more efficient.
                                    if (recursive) {
                                        // Only the topmost node in a recursive expand should suspend the add event
                                        // and fire the refresh event, so if our parent is synchronously, recursively expanding,
                                        // we just flag that we are doing likewise.
                                        if (me.parentNode &amp;&amp; me.parentNode.isSynchronousRecursiveExpand) {
                                            me.isSynchronousRecursiveExpand = true;
                                        }
                                        else {
                                            treeStore = me.getTreeStore();
                                            if (treeStore.getProxy().isSynchronous || me.isBranchLoaded()) {
                                                me.isSynchronousRecursiveExpand = true;
                                                treeStore.suspendEvent(&#39;add&#39;);
                                                resumeAddEvent = true;
                                            }
                                        }
                                    }

                                    // Inform the TreeStore that we intend to expand, and that it should call onChildNodesAvailable
                                    // when the child nodes are available
                                    me.callTreeStore(&#39;onBeforeNodeExpand&#39;, [me.onChildNodesAvailable, me, [recursive, callback, scope]]);

                                    // If we suspended the add event so that all additions of descendant nodes
                                    // did not update the UI, then resume the event here, and refresh the data
                                    if (resumeAddEvent) {
                                        treeStore.resumeEvent(&#39;add&#39;);
                                        treeStore.fireEvent(&#39;refresh&#39;, treeStore);
                                    }
                                    me.isSynchronousRecursiveExpand = false;
                                }

                            } else if (recursive) {
                                // If it is is already expanded but we want to recursively expand then call expandChildren
                                me.expandChildren(true, callback, scope);
                            } else {
                                Ext.callback(callback, scope || me, [me.childNodes]);
                            }
                        }
                    } else {
                        // If it&#39;s not then we fire the callback right away
                        Ext.callback(callback, scope || me); // leaf = no childNodes
                    }
                },

<span id='Ext-data-NodeInterface-method-onChildNodesAvailable'>                /**
</span>                 * @private
                 * Called as a callback from the beforeexpand listener fired by {@link #method-expand} when the child nodes have been loaded and appended.
                 */
                onChildNodesAvailable: function(records, recursive, callback, scope) {
                    var me = this,
                        treeStore = me.getTreeStore(),
                        bulkUpdate = treeStore &amp;&amp; treeStore.bulkUpdate,
                        ancestor,
                        i,
                        collapsedAncestors;

                    // Bracket expansion with layout suspension.
                    // In optimum case, when recursive, child node data are loaded and expansion is synchronous within the suspension.
                    Ext.suspendLayouts();

                    // Collect collapsed ancestors.
                    // We are going to expand the topmost one while ensuring that
                    // any intervening collapsed nodes have their expanded state as true.
                    for (ancestor = me.parentNode; ancestor; ancestor = ancestor.parentNode) {
                        if (!ancestor.isExpanded()) {
                            (collapsedAncestors || (collapsedAncestors = [])).unshift(ancestor);
                        }
                    }

                    // Not structural. The TreeView&#39;s onUpdate listener just updates the [+] icon to [-] in response.
                    
                    if (bulkUpdate) {
                        me.data.expanded = true;
                    } else {
                        me.set(&#39;expanded&#39;, true);
                    }

                    // Set the intervening collapsed nodes to expanded state, then expand the topmost.
                    // The whole descendant tree will be inserted into the collection below the topmost ancestor.
                    if (collapsedAncestors) {
                        // Ensure intervening collapsed nodes have their status set to expanded
                        // Not structural. The TreeView&#39;s onUpdate listener just updates the [+] icon to [-] in response.
                        for (i = 1; i &lt; collapsedAncestors.length; i++) {
                            ancestor = collapsedAncestors[i];
                            if (bulkUpdate) {
                                ancestor.data.expanded = true;
                            } else {
                                ancestor.set(&#39;expanded&#39;, true);
                            }
                        }

                        // Expand the topmost collapeed one.
                        // The correctly set expanded states all the way down will ensure that
                        // All nodes needed are inserted into the Store.
                        collapsedAncestors[0].expand();

                        // Fire the expand event on all those intervening collapsed nodes
                        for (i = 1; i &lt; collapsedAncestors.length; i++) {
                            ancestor = collapsedAncestors[i];
                            ancestor.fireEventArgs(&#39;expand&#39;, [ancestor, ancestor.childNodes]);
                        }
                    } else {
                        // TreeStore&#39;s onNodeExpand inserts the child nodes below the parent
                        me.callTreeStore(&#39;onNodeExpand&#39;, [records, false]);
                    }

                    me.fireEventArgs(&#39;expand&#39;, [me, records]);

                    // Call the expandChildren method if recursive was set to true
                    if (recursive) {
                        me.expandChildren(true, callback, scope);
                    } else {
                        Ext.callback(callback, scope || me, [me.childNodes]);
                    }

                    Ext.resumeLayouts(true);
                },

<span id='Ext-data-NodeInterface-method-expandChildren'>                /**
</span>                 * Expand all the children of this node.
                 * @param {Boolean} [recursive=false] True to recursively expand all the children
                 * @param {Function} [callback] The function to execute once all the children are expanded
                 * @param {Object} [scope] The scope to run the callback in
                 */
                expandChildren: function(recursive, callback, scope, /* private */ singleExpand) {
                    var me = this,
                        origCallback, i, allNodes, expandNodes, ln, node, treeStore;

                    // Ext 4.2.0 broke the API for this method by adding a singleExpand argument
                    // at index 1. As of 4.2.3 The method signature has been reverted back
                    // to its original pre-4.2.0 state, however, we must check to see if
                    // the 4.2.0 version is being used for compatibility reasons.
                    if (Ext.isBoolean(callback)) {
                        origCallback = callback;
                        callback = scope;
                        scope = singleExpand;
                        singleExpand = origCallback;
                    }

                    if (singleExpand === undefined) {
                        treeStore = me.getTreeStore();
                        singleExpand = treeStore &amp;&amp; treeStore.singleExpand;
                    }
                    allNodes = me.childNodes;
                    expandNodes = [];
                    ln = singleExpand ? Math.min(allNodes.length, 1) : allNodes.length;

                    for (i = 0; i &lt; ln; ++i) {
                        node = allNodes[i];
                        if (!node.isLeaf()) {
                            expandNodes[expandNodes.length] = node;
                        }
                    }
                    ln = expandNodes.length;

                    for (i = 0; i &lt; ln; ++i) {
                        expandNodes[i].expand(recursive);
                    }

                    if (callback) {
                        Ext.callback(callback, scope || me, [me.childNodes]);
                    }
                },

<span id='Ext-data-NodeInterface-method-collapse'>                /**
</span>                 * Collapse this node.
                 * @param {Boolean} [recursive=false] True to recursively collapse all the children
                 * @param {Function} [callback] The function to execute once the collapse completes
                 * @param {Object} [scope] The scope to run the callback in
                 */
                collapse: function(recursive, callback, scope) {
                    var me = this,
                        expanded = me.isExpanded(),
                        treeStore = me.getTreeStore(),
                        bulkUpdate = treeStore &amp;&amp; treeStore.bulkUpdate,
                        len = me.childNodes.length,
                        i, collapseChildren;

                    // If this is a parent and
                    //      already collapsed but the recursive flag is passed to target child nodes
                    //   or
                    //      the collapse is not vetoed by a listener
                    if (!me.isLeaf() &amp;&amp; ((!expanded &amp;&amp; recursive) || me.fireEventArgs(&#39;beforecollapse&#39;, [me]) !== false)) {
                        // Bracket collapsing with layout suspension.
                        // Collapsing is synchronous within the suspension.
                        Ext.suspendLayouts();

                        // Inform listeners of a collapse event if we are still expanded.
                        if (me.isExpanded()) {
                            
                            // Set up the callback to set non-leaf descendants to collapsed if necessary.
                            // If recursive, we just need to set all non-leaf descendants to collapsed state.
                            // We *DO NOT* call collapse on them. That would attempt to remove their descendants
                            // from the UI, and that is done: THIS node is collapsed - ALL descendants are removed from the UI.
                            // Descendant non-leaves just silently change state.
                            if (recursive) {
                                collapseChildren = function() {
                                    for (i = 0; i &lt; len; i++) {
                                        me.childNodes[i].setCollapsed(true);
                                    }
                                };
                                if (callback) {
                                    callback = Ext.Function.createSequence(collapseChildren, Ext.Function.bind(callback, scope, [me.childNodes]));
                                } else {
                                    callback = collapseChildren;
                                }
                            } else if (callback) {
                                callback = Ext.Function.bind(callback, scope, [me.childNodes]);
                            }

                            // Not structural. The TreeView&#39;s onUpdate listener just updates the [+] icon to [-] in response.
                            if (bulkUpdate) {
                                me.data.expanded = false;
                            } else {
                                me.set(&#39;expanded&#39;, false);
                            }

                            // Call the TreeStore&#39;s onNodeCollapse which removes all descendant nodes to achieve UI collapse
                            // and passes callback on in its beforecollapse event which is poked into the animWrap for
                            // final calling in the animation callback.
                            me.callTreeStore(&#39;onNodeCollapse&#39;, [me.childNodes, callback, scope]);

                            me.fireEventArgs(&#39;collapse&#39;, [me, me.childNodes]);

                            // So that it&#39;s not called at the end
                            callback = null;
                        }

                        // If recursive, we just need to set all non-leaf descendants to collapsed state.
                        // We *DO NOT* call collapse on them. That would attempt to remove their descendants
                        // from the UI, and that is done: THIS node is collapsed - ALL descendants are removed from the UI.
                        // Descendant non-leaves just silently change state.
                        else if (recursive) {
                            for (i = 0; i &lt; len; i++) {
                                me.childNodes[i].setCollapsed(true);
                            }
                        }

                        Ext.resumeLayouts(true);
                    }

                    // Call the passed callback
                    Ext.callback(callback, scope || me, [me.childNodes]);
                },

<span id='Ext-data-NodeInterface-method-setCollapsed'>                /**
</span>                 * @private Sets the node into the collapsed state without affecting the UI.
                 * 
                 * This is called when a node is collapsed with the recursive flag. All the descendant
                 * nodes will have been removed from the store, but descendant non-leaf nodes still
                 * need to be set to the collapsed state without affecting the UI.
                 */
                setCollapsed: function(recursive) {
                    var me = this,
                        len = me.childNodes.length,
                        i;

                    // Only if we are not a leaf node and the collapse was not vetoed by a listener.
                    if (!me.isLeaf() &amp;&amp; me.fireEventArgs(&#39;beforecollapse&#39;, [me]) !== false) {

                        // Update the state directly.
                        me.data.expanded = false;

                        // Listened for by NodeStore.onNodeCollapse, but will do nothing except pass on the
                        // documented events because the records have already been removed from the store when
                        // the ancestor node was collapsed.
                        me.fireEventArgs(&#39;collapse&#39;, [me, me.childNodes]);

                        if (recursive) {
                            for (i = 0; i &lt; len; i++) {
                                me.childNodes[i].setCollapsed(true);
                            }
                        }
                    }
                },

<span id='Ext-data-NodeInterface-method-collapseChildren'>                /**
</span>                 * Collapse all the children of this node.
                 * @param {Function} [recursive=false] True to recursively collapse all the children
                 * @param {Function} [callback] The function to execute once all the children are collapsed
                 * @param {Object} [scope] The scope to run the callback in
                 */
                collapseChildren: function(recursive, callback, scope) {
                    var me = this,
                        i,
                        allNodes = me.childNodes,
                        ln = allNodes.length,
                        collapseNodes = [],
                        node;

                    // Only bother with loaded, expanded, non-leaf nodes
                    for (i = 0; i &lt; ln; ++i) {
                        node = allNodes[i];
                        if (!node.isLeaf() &amp;&amp; node.isLoaded() &amp;&amp; node.isExpanded()) {
                            collapseNodes.push(node);
                        }
                    }
                    ln = collapseNodes.length;

                    if (ln) {
                        // Collapse the collapsible children.
                        // Pass our callback to the last one.
                        for (i = 0; i &lt; ln; ++i) {
                            node = collapseNodes[i];
                            if (i === ln - 1) {
                                node.collapse(recursive, callback, scope);
                            } else {
                                node.collapse(recursive);
                            }
                        }
                    } else {
                        // Nothing to collapse, so fire the callback
                        Ext.callback(callback, scope);
                    }
                },

<span id='Ext-data-NodeInterface-method-fireEvent'>                /**
</span>                * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
                * to {@link Ext.mixin.Observable#addListener addListener}).
                *
                * An event may be set to bubble up an Observable parent hierarchy (See {@link Ext.Component#getBubbleTarget}) by
                * calling {@link Ext.mixin.Observable#enableBubble enableBubble}.
                *
                * @param {String} eventName The name of the event to fire.
                * @param {Object...} args Variable number of parameters are passed to handlers.
                * @return {Boolean} returns false if any of the handlers return false otherwise it returns true.
                */
                fireEvent: function(eventName) {
                    return this.fireEventArgs(eventName, Ext.Array.slice(arguments, 1));
                },

                // Node events always bubble, but events which bubble are always created, so bubble in a loop and
                // only fire when there are listeners at each level.
                // bubbled events always fire because they cannot tell if there is a listener at each level.
                fireEventArgs: function(eventName, args) {
                    // Use the model prototype directly. If we have a BaseModel and then a SubModel,
                    // if we access the superclass fireEventArgs it will just refer to the same method
                    // and we end up in an infinite loop.
                    var fireEventArgs = Ext.mixin.Observable.prototype.fireEventArgs,
                        result, eventSource, topNode;

                    // The event bubbles (all native NodeInterface events do)...
                    if (bubbledEvents[eventName]) {
                        for (eventSource = this; result !== false &amp;&amp; eventSource; eventSource = (topNode = eventSource).parentNode) {
                            if (eventSource.hasListeners &amp;&amp; eventSource.hasListeners[eventName]) {
                                result = fireEventArgs.call(eventSource, eventName, args);
                            }
                        }

                        // We hit the topmost node in the loop above.
                        // Fire the event on its TreeStore if any (might be a disembodied tree fragment with no TreeStore)
                        if (result !== false) {
                            eventSource = topNode.getTreeStore();
                            if (eventSource &amp;&amp; eventSource.hasListeners &amp;&amp; eventSource.hasListeners[eventName = &#39;node&#39; + eventName]) {
                                result = eventSource.fireEventArgs(eventName, args);
                            }
                        }
                        return result;
                    }
                    // Event does not bubble - call superclass fireEventArgs method
                    else {
                        return fireEventArgs.apply(this, arguments);
                    }
                },

<span id='Ext-data-NodeInterface-method-serialize'>                /**
</span>                 * Creates an object representation of this node including its children.
                 */
                serialize: function() {
                    var result = Ext.data.writer.Json.prototype.getRecordData(this),
                        childNodes = this.childNodes,
                        len = childNodes.length,
                        children, i;

                    if (len &gt; 0) {
                        children = [];
                        for (i = 0; i &lt; len; i++) {
                            children.push(childNodes[i].serialize());
                        }
                        result.children = children;
                    }
                    return result;
                },

                // Used to inform the TreeStore that we belong to about some event which requires its participation.
                callTreeStore: function(funcName, args) {
                    var me = this,
                        target = me.getTreeStore(),
                        fn = target &amp;&amp; target[funcName];

                    if (target &amp;&amp; fn) {
                        args = args || [];
                        if (args[0] !== me) {
                            args.unshift(me);
                        }
                        fn.apply(target, args);
                    }
                },

                // Override private methods from Model superclass
                privates: {
                    
                    join: function(store) {

                        // Only the root node is linked to the TreeStore
                        if (store.isTreeStore) {
                            if (this.isRoot()) {
                                this.treeStore = this.store = store;
                            }
                        }

                        // Other stores are always joined.
                        // So a tree node could also be used by a flat store linked to a DataView
                        else {
                            this.callParent([store]);
                        }
                    },

                    // Used by Model base class methods to inform all interested Stores that the record has been mutated.
                    callJoined: function(funcName, args) {
                        this.callParent([funcName, args]);
                        this.callTreeStore(funcName, args);
                    }
                }
            };
        }
    }
});
</pre>
</body>
</html>
