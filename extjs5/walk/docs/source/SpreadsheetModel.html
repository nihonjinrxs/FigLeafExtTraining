<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-grid-selection-SpreadsheetModel'>/**
</span> * A selection model for {@link Ext.grid.Panel grids} which allows you to select data in
 * a spreadsheet-like manner.
 *
 * Supported features:
 *
 *  - Single / Range / Multiple individual row selection.
 *  - Single / Range cell selection.
 *  - Column selection by click selecting column headers.
 *  - Select / deselect all by clicking in the top-left, header.
 *  - Adds row number column to enable row selection.
 *  - Optionally you can enable row selection using checkboxes
 *
 * # Example usage
 *
 *     @example
 *     var store = Ext.create(&#39;Ext.data.Store&#39;, {
 *         fields: [ &#39;name&#39;, &#39;email&#39;, &#39;phone&#39; ],
 *
 *         data: {
 *             items: [
 *                 { name: &#39;Lisa&#39;,  email: &#39;lisa@simpsons.com&#39;,  phone: &#39;555-111-1224&#39; },
 *                 { name: &#39;Bart&#39;,  email: &#39;bart@simpsons.com&#39;,  phone: &#39;555-222-1234&#39; },
 *                 { name: &#39;Homer&#39;, email: &#39;homer@simpsons.com&#39;, phone: &#39;555-222-1244&#39; },
 *                 { name: &#39;Marge&#39;, email: &#39;marge@simpsons.com&#39;, phone: &#39;555-222-1254&#39; }
 *             ]
 *         },
 *
 *         proxy: {
 *             type: &#39;memory&#39;,
 *             reader: {
 *                 type: &#39;json&#39;,
 *                 root: &#39;items&#39;
 *             }
 *         }
 *     });
 *
 *     Ext.create(&#39;Ext.grid.Panel&#39;, {
 *         title: &#39;Simpsons&#39;,
 *         store: store,
 *         width: 400,
 *         renderTo: Ext.getBody(),
 *
 *         columns: [
 *             { text: &#39;Name&#39;,  dataIndex: &#39;name&#39;  },
 *             { text: &#39;Email&#39;, dataIndex: &#39;email&#39;, flex: 1 },
 *             { text: &#39;Phone&#39;, dataIndex: &#39;phone&#39; }
 *         ],
 *
 *         selModel: {
 *            type: &#39;spreadsheet&#39;
 *         }
 *     });
 *
 * @since 5.1.0
 */
Ext.define(&#39;Ext.grid.selection.SpreadsheetModel&#39;, {
    extend: &#39;Ext.selection.Model&#39;,
    requires: [
        &#39;Ext.grid.selection.Selection&#39;,
        &#39;Ext.grid.selection.Cells&#39;,
        &#39;Ext.grid.selection.Rows&#39;,
        &#39;Ext.grid.selection.Columns&#39;
    ],

    alias: &#39;selection.spreadsheet&#39;,

<span id='Ext-grid-selection-SpreadsheetModel-property-isSpreadsheetModel'>    isSpreadsheetModel: true,
</span>
    config: {
<span id='Ext-grid-selection-SpreadsheetModel-cfg-columnSelect'>        /**
</span>         * @cfg {Boolean} [columnSelect=false]
         * Set to `true` to enable selection of columns.
         *
         * **NOTE**: This will remove sorting on header click and instead provide column
         * selection and deselection. Sorting is still available via column header menu.
         */
        columnSelect: {
            $value: false,
            lazy: true
        },

<span id='Ext-grid-selection-SpreadsheetModel-cfg-cellSelect'>        /**
</span>         * @cfg {Boolean} [cellSelect=true]
         * Set to `true` to enable selection of individual cells or a single rectangular
         * range of cells. This will provide cell range selection using click, and
         * potentially drag to select a rectangular range. You can also use &quot;SHIFT + arrow&quot;
         * key navigation to select a range of cells.
         */
        cellSelect: {
            $value: true,
            lazy: true
        },

<span id='Ext-grid-selection-SpreadsheetModel-cfg-rowSelect'>        /**
</span>         * @cfg {Boolean} [rowSelect=true]
         * Set to `true` to enable selection of rows by clicking on a row number column.
         *
         * *Note*: This feature will add the row number as the first column.
         */
        rowSelect: {
            $value: true,
            lazy: true
        },

<span id='Ext-grid-selection-SpreadsheetModel-cfg-dragSelect'>        /**
</span>        * @cfg {Boolean} [dragSelect=true]
        * Set to `true` to enables cell range selection by cell dragging.
        */
        dragSelect: {
            $value: true,
            lazy: true
        },

<span id='Ext-grid-selection-SpreadsheetModel-cfg-selected'>        /**
</span>        * @cfg {Ext.grid.selection.Selection} [selected]
        * Pass an instance of one of the subclasses of {@link Ext.grid.selection.Selection}.
        */
        selected: null
    },

<span id='Ext-grid-selection-SpreadsheetModel-event-selectionchange'>    /**
</span>     * @event selectionchange
     * Fired *by the grid* after the selection changes.
     * @param {Ext.grid.Panel} grid The grid whose selection has changed.
     * @param {Ext.grid.selection.Selection} selection A subclass of
     * {@link Ext.grid.selection.Selection} describing the new selection.
     */

<span id='Ext-grid-selection-SpreadsheetModel-cfg-checkboxSelect'>    /**
</span>     * @cfg {Boolean} checkboxSelect [checkboxSelect=false]
     * Enables selection of the row via clicking on checkbox. Note: this feature will add
     * new column at position specified by {@link #checkboxColumnIndex}.
     */
    checkboxSelect: false,

<span id='Ext-grid-selection-SpreadsheetModel-cfg-checkboxColumnIndex'>    /**
</span>     * @cfg {Number/String} [checkboxColumnIndex=0]
     * The index at which to insert the checkbox column.
     * Supported values are a numeric index, and the strings &#39;first&#39; and &#39;last&#39;. Only valid when set
     * *before* render.
     */
    checkboxColumnIndex: 0,

<span id='Ext-grid-selection-SpreadsheetModel-cfg-showHeaderCheckbox'>    /**
</span>     * @cfg {Boolean} [showHeaderCheckbox=true]
     * Configure as `false` to not display the header checkbox at the top of the checkbox column
     * when {@link #checkboxSelect} is set.
     */
    showHeaderCheckbox: true,

<span id='Ext-grid-selection-SpreadsheetModel-cfg-checkboxHeaderWidth'>    /**
</span>     * @cfg {Number/String} [checkboxHeaderWidth=24]
     * Width of checkbox column.
     */
    checkboxHeaderWidth: 24,

<span id='Ext-grid-selection-SpreadsheetModel-cfg-rowNumbererHeaderWidth'>    /**
</span>     * @cfg {Number/String} [rowNumbererHeaderWidth=46]
     * Width of row numbering column.
     */
    rowNumbererHeaderWidth: 46,

<span id='Ext-grid-selection-SpreadsheetModel-property-columnSelectCls'>    columnSelectCls: Ext.baseCSSPrefix + &#39;ssm-column-select&#39;,
</span><span id='Ext-grid-selection-SpreadsheetModel-property-rowNumbererHeaderCls'>    rowNumbererHeaderCls: Ext.baseCSSPrefix + &#39;ssm-row-numberer-hd&#39;,
</span><span id='Ext-grid-selection-SpreadsheetModel-property-rowNumbererTdCls'>    rowNumbererTdCls: Ext.grid.column.RowNumberer.prototype.tdCls + &#39; &#39; + Ext.baseCSSPrefix + &#39;ssm-row-numberer-cell&#39;,
</span>
<span id='Ext-grid-selection-SpreadsheetModel-property-checkerOnCls'>    // private
</span>    checkerOnCls: Ext.baseCSSPrefix + &#39;grid-hd-checker-on&#39;,

<span id='Ext-grid-selection-SpreadsheetModel-property-tdCls'>    tdCls: Ext.baseCSSPrefix + &#39;grid-cell-special &#39; + Ext.baseCSSPrefix + &#39;grid-cell-row-checker&#39;,
</span>
<span id='Ext-grid-selection-SpreadsheetModel-method-getCount'>    /**
</span>     * @method getCount
     * This method is not supported by SpreadsheetModel.
     *
     * To interrogate the selection use {@link #getSelected} which will return an instance of one
     * of the three selection types, or `null` if no selection.
     *
     * The three selection types are:
     *
     *    * {@link Ext.grid.selection.Rows}
     *    * {@link Ext.grid.selection.Columns}
     *    * {@link Ext.grid.selection.Cells}
     */

<span id='Ext-grid-selection-SpreadsheetModel-method-getSelectionMode'>    /**
</span>     * @method getSelectionMode
     * This method is not supported by SpreadsheetModel.
     */

<span id='Ext-grid-selection-SpreadsheetModel-method-setSelectionMode'>    /**
</span>     * @method setSelectionMode
     * This method is not supported by SpreadsheetModel.
     */

<span id='Ext-grid-selection-SpreadsheetModel-method-setLocked'>    /**
</span>     * @method setLocked
     * This method is not currently supported by SpreadsheetModel.
     */

<span id='Ext-grid-selection-SpreadsheetModel-method-isLocked'>    /**
</span>     * @method isLocked
     * This method is not currently supported by SpreadsheetModel.
     */

<span id='Ext-grid-selection-SpreadsheetModel-method-isRangeSelected'>    /**
</span>     * @method isRangeSelected
     * This method is not supported by SpreadsheetModel.
     *
     * To interrogate the selection use {@link #getSelected} which will return an instance of one
     * of the three selection types, or `null` if no selection.
     *
     * The three selection types are:
     *
     *    * {@link Ext.grid.selection.Rows}
     *    * {@link Ext.grid.selection.Columns}
     *    * {@link Ext.grid.selection.Cells}
     */

<span id='Ext-grid-selection-SpreadsheetModel-method-bindComponent'>    /**
</span>     * @private
     */
    bindComponent: function(view) {
        var me = this,
            viewListeners,
            lockedGrid;

        if (me.view !== view) {
            if (me.view) {
                me.navigationModel = null;
                Ext.destroy(me.viewListeners, me.navigationListeners);
            }
            me.view = view;
            if (view) {
                // We need to realize our lazy configs now that we have the view...
                me.getCellSelect();

                lockedGrid = view.ownerGrid.lockedGrid;
                // If there is a locked grid, process it now
                if (lockedGrid) {
                    me.hasLockedHeader = true;
                    me.onViewCreated(lockedGrid, lockedGrid.getView());
                } 
                // Otherwise, get back to us when the view is fully created so that we can tweak its headerCt
                else {
                    view.grid.on({
                        viewcreated: me.onViewCreated,
                        scope: me,
                        single: true
                    });
                }
                me.gridListeners = view.ownerGrid.on({
                    columnschanged: me.onColumnsChanged,
                    scope: me,
                    destroyable: true
                });

                viewListeners = me.getViewListeners();
                viewListeners.scope = me;
                viewListeners.destroyable = true;
                me.viewListeners = view.on(viewListeners);
                me.navigationModel = view.getNavigationModel();
                me.navigationListeners = me.navigationModel.on({
                    navigate: me.onNavigate,
                    scope: me,
                    destroyable: true
                });

                // Add class to add special cursor pointer to column headers
                if (me.getColumnSelect()) {
                    view.ownerGrid.addCls(me.columnSelectCls);
                }
            }
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-getCheckboxHeaderConfig'>    /**
</span>     * Retrieve a configuration to be used in a HeaderContainer.
     * This should be used when checkboxSelect is set to false.
     * @protected
     */
    getCheckboxHeaderConfig: function() {
        var me = this,
            showCheck = me.showHeaderCheckbox !== false;

        return {
            isCheckerHd: showCheck,
            text : &#39;&amp;#160;&#39;,
            clickTargetName: &#39;el&#39;,
            width: me.checkboxHeaderWidth,
            sortable: false,
            draggable: false,
            resizable: false,
            hideable: false,
            menuDisabled: true,
            dataIndex: &#39;&#39;,
            tdCls: me.tdCls,
            cls: showCheck ? Ext.baseCSSPrefix + &#39;column-header-checkbox &#39; : &#39;&#39;,
            defaultRenderer: me.checkboxRenderer.bind(me),
            editRenderer:  &#39;&amp;#160;&#39;,
            locked: me.hasLockedHeader
        };
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-checkboxRenderer'>    /**
</span>     * Generates the HTML to be rendered in the injected checkbox column for each row.
     * Creates the standard checkbox markup by default; can be overridden to provide custom rendering.
     * See {@link Ext.grid.column.Column#renderer} for description of allowed parameters.
     * @private
     */
    checkboxRenderer: function () {
        return &#39;&lt;div class=&quot;&#39; + Ext.baseCSSPrefix + &#39;grid-row-checker&quot; role=&quot;presentation&quot;&gt;&amp;#160;&lt;/div&gt;&#39;;
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-onHeaderClick'>    /**
</span>     * @private
     */
    onHeaderClick: function(headerCt, header, e) {
    // Template method. See base class
        var me = this,
            sel = me.selected;

        if (header === me.numbererColumn || header === me.checkColumn) {
            e.stopEvent();
            // Not all selected, select all
            if (!sel || !sel.isAllSelected()) {
                me.selectAll(headerCt.view);
            } else {
                me.deselectAll();
            }
            me.updateHeaderState();
        } else if (me.columnSelect) {
            if (me.isColumnSelected(header)) {
                me.deselectColumn(header);
            } else {
                me.selectColumn(header, e.ctrlKey);
            }
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-updateHeaderState'>    /**
</span>     * @private
     */
    updateHeaderState: function() {
        // check to see if all records are selected
        var me = this,
            store = me.view.dataSource,
            storeCount = store.getCount(),
            views = me.views,
            sel = me.selected,
            isChecked = sel &amp;&amp; sel.isRows &amp;&amp; !store.isBufferedStore &amp;&amp; storeCount &gt; 0 &amp;&amp; (storeCount === sel.getCount()),
            checkHd  = me.checkColumn,
            cls = me.checkerOnCls;

        if (views &amp;&amp; views.length) {
            if (checkHd) {
                if (isChecked) {
                    checkHd.addCls(cls);
                } else {
                    checkHd.removeCls(cls);
                }
            }
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-onReconfigure'>    /**
</span>     * Handles the grid&#39;s reconfigure event.  Adds the checkbox header if the columns have been reconfigured.
     * @param {Ext.panel.Table} grid
     * @param {Ext.data.Store} store
     * @param {Object[]} columns
     * @private
     */
    onReconfigure: function(grid, store, columns) {
        if (columns) {
            this.addCheckbox(this.views[0]);
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-getCellContext'>    /**
</span>     * This is a helper method to create a cell context which encapsulates one cell in a grid view.
     *
     * It will contain the following properties:
     *  colIdx - column index
     *  rowIdx - row index
     *  column - {@link Ext.grid.column.Column Column} under which the cell is located.
     *  record - {@link Ext.data.Model} Record from which the cell derives its data.
     *  view - The view. If this selection model is for a locking grid, this will be the outermost view, the {@link Ext.grid.loacking.View}
     *  which encapsulates the sub grids. Column indices are relatibve to the outermost view&#39;s visible column set.
     *
     * @param {Number} record Record for which to select the cell, or row index.
     * @param {Number} column Grid column header, or column index.
     * @return {Ext.grid.CellContext} A context object describing the cell. Note that the `rowidx` and `colIdx` properties are only valid
     * at the time the context object is created. Column movement, sorting or filtering might changed where the cell is.
     * @private
     */
    getCellContext: function(record, column) {
        return new Ext.grid.CellContext(this.view.ownerGrid.getView()).setPosition(record, column);
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-select'>    select: function(records, keepExisting, suppressEvent) {
</span>        // API docs re inherited
        var me = this,
            sel = me.selected,
            view = me.view,
            store = view.dataSource,
            len,
            i,
            record,
            changed = false;

        // Ensure selection object is of the correct type
        if (!sel || !sel.isRows || sel.view !== view) {
            me.resetSelection(true);
            sel = me.selected = new Ext.grid.selection.Rows(view);
        } else if (!keepExisting) {
            sel.clear();
        }
        
        if (!Ext.isArray(records)) {
            records = [records];
        }
        len = records.length;
        for (i = 0; i &lt; len; i++) {
            record = records[i];
            if (typeof record === &#39;number&#39;) {
                record = store.getAt(record);
            }
            if (!sel.contains(record)) {
                sel.add(record);
                changed = true;
            }
        }
        if (changed) {
            me.updateHeaderState();
            if (suppressEvent) {
                me.fireSelectionChange();
            }
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-deselect'>    deselect: function(records, suppressEvent) {
</span>        // API docs are inherited
        var me = this,
            sel = me.selected,
            store = me.view.dataSource,
            len,
            i,
            record,
            changed = false;

        if (sel &amp;&amp; sel.isRows) {
            if (!Ext.isArray(records)) {
                records = [records];
            }
            len = records.length;
            for (i = 0; i &lt; len; i++) {
                record = records[i];
                if (typeof record === &#39;number&#39;) {
                    record = store.getAt(record);
                }
                changed = changed || sel.remove(record);
            }
        }
        if (changed) {
            me.updateHeaderState();
            if (!suppressEvent) {
                me.fireSelectionChange();
            }
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-selectCells'>    /**
</span>     * This method allows programmatic selection of the cell range.
     *
     *     @example
     *     var store = Ext.create(&#39;Ext.data.Store&#39;, {
     *         fields  : [&#39;name&#39;, &#39;email&#39;, &#39;phone&#39;],
     *         data    : {
     *             items : [
     *                 { name : &#39;Lisa&#39;,  email : &#39;lisa@simpsons.com&#39;,  phone : &#39;555-111-1224&#39; },
     *                 { name : &#39;Bart&#39;,  email : &#39;bart@simpsons.com&#39;,  phone : &#39;555-222-1234&#39; },
     *                 { name : &#39;Homer&#39;, email : &#39;homer@simpsons.com&#39;, phone : &#39;555-222-1244&#39; },
     *                 { name : &#39;Marge&#39;, email : &#39;marge@simpsons.com&#39;, phone : &#39;555-222-1254&#39; }
     *             ]
     *         },
     *         proxy   : {
     *             type   : &#39;memory&#39;,
     *             reader : {
     *                 type : &#39;json&#39;,
     *                 root : &#39;items&#39;
     *             }
     *         }
     *     });
     *
     *     vaar grid = Ext.create(&#39;Ext.grid.Panel&#39;, {
     *         title    : &#39;Simpsons&#39;,
     *         store    : store,
     *         width    : 400,
     *         renderTo : Ext.getBody(),
     *         columns  : [
     *            columns: [
     *               { text: &#39;Name&#39;,  dataIndex: &#39;name&#39; },
     *               { text: &#39;Email&#39;, dataIndex: &#39;email&#39;, flex: 1 },
     *               { text: &#39;Phone&#39;, dataIndex: &#39;phone&#39;, width:120 },
     *               {
     *                   text:&#39;Combined&#39;, dataIndex: &#39;name&#39;, width : 300,
     *                   renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {
     *                       console.log(arguments);
     *                       return value + &#39; has email: &#39; + record.get(&#39;email&#39;);
     *                   }
     *               }
     *           ],
     *         ],
     *         selType: &#39;spreadsheet&#39;
     *     });
     *
     *     var model = grid.getSelectionModel();  // get selection model
     *
     *     // We will create range of 4 cells.
     *
     *     // Now set the range  and prevent rangeselect event from being fired.
     *     // We can use a simple array when we have no locked columns.
     *     model.selectCells([0, 0], [1, 1], true);
     *
     * @param rangeStart {Ext.grid.CellContext/Number[]} Range starting position. Can be either Cell context or a `[rowIndex, columnIndex]` numeric array.
     *
     * Note that when a numeric array is used in a locking grid, the column indices are relative to the outermost grid, encompassing locked *and* normal sides.
     * @param rangeEnd {Ext.grid.CellContext/Number[]} Range end position. Can be either Cell context or a `[rowIndex, columnIndex]` numeric array.
     *
     * Note that when a numeric array is used in a locking grid, the column indices are relative to the outermost grid, encompassing locked *and* normal sides.
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    selectCells: function(rangeStart, rangeEnd, suppressEvent) {
        var me = this,
            view = me.view.ownerGrid.view,
            sel;

        rangeStart = rangeStart.isCellContext ? rangeStart.clone() : new Ext.grid.CellContext(view).setPosition(rangeStart);
        rangeEnd   = rangeEnd.isCellContext   ? rangeEnd.clone()   : new Ext.grid.CellContext(view).setPosition(rangeEnd);

        me.resetSelection(true);

        me.selected = sel = new Ext.grid.selection.Cells(rangeStart.view);
        sel.setRangeStart(rangeStart);
        sel.setRangeEnd(rangeEnd);

        if (!suppressEvent) {
            me.fireSelectionChange();
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-selectAll'>    /**
</span>     * Select all the data if possible.
     *
     * If {@link #rowSelect} is `true`, then all *records* will be selected.
     *
     * If {@link #cellSelect} is `true`, then all *rendered cells* will be selected.
     *
     * If {@link #columnSelect} is `true`, then all *columns* will be selected.
     *
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    selectAll: function (suppressEvent) {
        var me = this,
            sel = me.selected,
            doSelect,
            view = me.view;

        if (me.rowSelect) {
            if (!sel || !sel.isRows) {
                me.resetSelection(true);
                me.selected = sel = new Ext.grid.selection.Rows(view);
            }
            doSelect = true;
        }
        else if (me.cellSelect) {
            if (!sel || !sel.isCells) {
                me.resetSelection(true);
                me.selected = sel = new Ext.grid.selection.Cells(view);
            }
            doSelect = true;
        }
        else if (me.columnSelect) {
            if (!sel || !sel.isColumns) {
                me.resetSelection(true);
                me.selected = sel = new Ext.grid.selection.Columns(view);
            }
            doSelect = true;
        }

        if (doSelect) {
            sel.selectAll();
            me.updateHeaderState();
            if (!suppressEvent) {
                me.fireSelectionChange();
            }
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-deselectAll'>    /**
</span>     * Clears the selection.
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    deselectAll: function (suppressEvent) {
        var sel = this.selected;
        
        if (sel &amp;&amp; sel.getCount()) {
            sel.clear();
            if (!suppressEvent) {
                this.fireSelectionChange();
            }
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-selectRows'>    /**
</span>     * Select one or more rows.
     * @param rows {Ext.data.Model[]} Records to select.
     * @param {Boolean} [keepSelection=false] Pass `true` to leep previous selection.
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    selectRows: function(rows, keepSelection, suppressEvent) {
        var me = this,
            sel = me.selected,
            isSelectingRows = sel &amp;&amp; !sel.isRows,
            len = rows.length,
            i;

        if (!keepSelection || isSelectingRows) {
            me.resetSelection(true);
        }
        if (!isSelectingRows) {
            me.selected = sel = new Ext.grid.selection.Rows(me.view);
        }

        for (i = 0; i &lt; len; i++) {
            sel.add(rows[i]);
        }

        if (!suppressEvent) {
            me.fireSelectionChange();
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-isSelected'>    isSelected: function(record) {
</span>        // API docs are inherited.
        return this.isRowSelected(record);
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-selectColumn'>    /**
</span>     * Selects a column.
     * @param {Ext.grid.column.Column} column Column to select.
     * @param {Boolean} [keepSelection=false] Pass `true` to leep previous selection.
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    selectColumn: function(column, keepSelection, suppressEvent) {
        var me = this,
            selData = me.selected,
            view = column.getView();

        // Clear other selection types
        if (!selData || !selData.isColumns || selData.view !== view.ownerGrid.view) {
            me.resetSelection(true);
            me.selected = selData = new Ext.grid.selection.Columns(view);
        }

        if (!selData.contains(column)) {
            if (!keepSelection) {
                selData.clear();
            }
            selData.add(column);

            me.updateHeaderState();
            if (!suppressEvent) {
                me.fireSelectionChange();
            }
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-deselectColumn'>    /**
</span>     * Deselects a column.
     * @param {Ext.grid.column.Column} column Column to deselect.
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    deselectColumn: function(column, suppressEvent) {
        var me = this,
            selData = me.getSelected();

        if (selData &amp;&amp; selData.isColumns &amp;&amp; selData.contains(column)) {
            selData.remove(column);
            me.updateHeaderState();
            if (!suppressEvent) {
                me.fireSelectionChange();
            }
        }
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-getSelection'>    getSelection: function() {
</span>        // API docs are inherited.
        // Superclass returns array of selected records
        var selData = this.selected;

        if (selData &amp;&amp; selData.isRows) {
            return selData.getRecords();
        }
        return [];
    },

<span id='Ext-grid-selection-SpreadsheetModel-method-destroy'>    destroy: function() {
</span>        var me = this,
            scrollEls = me.scrollEls;

        Ext.destroy(me.gridListeners, me.viewListeners, me.selected, me.navigationListeners);
        if (scrollEls) {
            Ext.dd.ScrollManager.unregister(scrollEls);
        }
        me.selected = me.gridListeners = me.viewListeners = me.selectionData = me.navigationListeners = me.scrollEls = null;
        me.callParent();
    },

<span id='Ext-grid-selection-SpreadsheetModel-property-privates'>    //-------------------------------------------------------------------------
</span>
    privates: {
<span id='Ext-grid-selection-SpreadsheetModel-method-getViewListeners'>        /**
</span>         * @return {Object}
         * @private
         */
        getViewListeners: function() {
            return {
                beforerefresh: this.onBeforeViewRefresh,
                keyup: {
                    element: &#39;el&#39;,
                    fn: this.onViewKeyUp,
                    scope: this
                }
            };
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onViewKeyUp'>        /**
</span>         * @private
         */
        onViewKeyUp: function(e) {
            var sel = this.selected;

            // Released the shift key, terminate a keyboard based range selection
            if (e.keyCode === e.SHIFT &amp;&amp; sel &amp;&amp; sel.isRows &amp;&amp; sel.getRangeSize()) {
                // Copy the drag range into the selected records collection
                sel.addRange();
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onColumnsChanged'>        /**
</span>         * @private
         */
        onColumnsChanged: function() {
            var selData = this.selected,
                rowRange,
                colCount,
                colIdx,
                rowIdx,
                view,
                context;

            // When columns have changed, we have to deselect *every* cell in the row range because we do not know where the
            // columns have gone to.
            if (selData &amp;&amp; selData.isCells) {
                view = selData.view;
                context = new Ext.grid.CellContext(view);
                rowRange = selData.getRowRange();
                colCount = view.getVisibleColumnManager().getColumns().length;
                for (rowIdx = rowRange[0]; rowIdx &lt;= rowRange[1]; rowIdx++) {
                    context.setRow(rowIdx);
                    for (colIdx = 0; colIdx &lt; colCount; colIdx++) {
                        context.setColumn(colIdx);
                        view.onCellDeselect(context);
                    }
                }
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onBeforeViewRefresh'>        /**
</span>         * @private
         */
        onBeforeViewRefresh: function(view) {
            var selData = this.selected;

            // Allow cell preselection to survive, but not cell selection from a prior refresh
            if (view.refreshCounter) {
                if (selData &amp;&amp; selData.isCells) {
                    this.resetSelection();
                }
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-resetSelection'>        /**
</span>         * @private
         */
        resetSelection: function(suppressEvent) {
            var sel = this.selected;

            if (sel) {
                sel.clear();
                if (!suppressEvent) {
                    this.fireSelectionChange();
                }
            }
        },

        onViewCreated: function(grid, view) {
            var me = this,
                ownerGrid = view.ownerGrid,
                headerCt = view.headerCt,
                shrinkwrapLocked = ownerGrid.shrinkWrapLocked;

            // Only add columns to the locked view, or only view if there is no twin
            if (!ownerGrid.lockable || view.isLockedView) {
                // if there is no row number column and we ask for it, then it should be added here
                if (me.getRowSelect() &amp;&amp; !headerCt.down(&#39;rownumberer&#39;)) {
                    // Add rownumber column
                    me.numbererColumn = headerCt.add(0, {
                        xtype: &#39;rownumberer&#39;,
                        width: me.rowNumbererHeaderWidth,
                        editRenderer:  &#39;&amp;#160;&#39;,
                        tdCls: me.rowNumbererTdCls,
                        cls: me.rowNumbererHeaderCls,
                        locked: me.hasLockedHeader
                    });
                    if (shrinkwrapLocked) {
                        grid.width += me.numbererColumn.width;
                    }
                }

                if (me.checkboxSelect) {
                    me.addCheckbox(view, true);
                    me.mon(view.ownerGrid, &#39;reconfigure&#39;, me.onReconfigure, me);
                    if (shrinkwrapLocked) {
                        grid.width += me.checkColumn.width;
                    }
                }
            }

            // Disable sortOnClick if we&#39;re columnSelecting
            headerCt.sortOnClick = !me.getColumnSelect();

            if (me.getDragSelect()) {
                view.on(&#39;render&#39;, me.onViewRender, me, {
                    single: true
                });
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onViewRender'>        /**
</span>         * Initialize drag selection support
         * @private
         */
        onViewRender: function(view) {
            var me = this,
                el = view.getEl();

            el.ddScrollConfig = {
                vthresh: 50,
                hthresh: 50,
                frequency: 300,
                increment: 100
            };
            Ext.dd.ScrollManager.register(el);

            // Possible two child views to register as scrollable on drag
            (me.scrollEls || (me.scrollEls = [])).push(el);

            view.on(&#39;cellmousedown&#39;, me.handleMouseDown, me);

            // In a locking situation, we need a mousedown listener on both sides.
            if (view.lockingPartner) {
                view.lockingPartner.on(&#39;cellmousedown&#39;, me.handleMouseDown, me);
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-handleMouseDown'>        /**
</span>         * Plumbing for drag selection of cell range
         * @private
         */
        handleMouseDown: function(view, td, cellIndex, record, tr, rowIdx, e) {
            var me = this,
                sel = me.selected,
                header = e.position.column,
                isCheckClick,
                startDragSelect;

            // Ignore right click and shit and alt modifiers.
            // Also ignore touchstart. We cannot drag select using touches.
            if (e.button || e.shiftKey || e.altKey || e.pointerType ===&#39;touch&#39;) {
                return;
            }

            if (header) {
                isCheckClick = header === me.checkColumn;

                // Differentiate between row and cell selections.
                if (header === me.numbererColumn || isCheckClick || !me.cellSelect) {
                    // Enforce rowSelect setting
                    if (me.rowSelect) {
                        if (sel &amp;&amp; sel.isRows) {
                            if (!e.ctrlKey &amp;&amp; !isCheckClick) {
                                sel.clear();
                            }
                        } else {
                            if (sel) {
                                sel.clear();
                            }
                            sel = me.selected = new Ext.grid.selection.Rows(view);
                        }
                        startDragSelect = true;
                    }
                } else {
                    if (sel) {
                        sel.clear();
                    }
                    if (!sel || !sel.isCells) {
                        sel = me.selected = new Ext.grid.selection.Cells(view);
                    }
                    startDragSelect = true;
                }

                me.lastOverRecord = me.lastOverColumn = null;

                // Add the listener after the view has potentially been corrected
                Ext.getBody().on(&#39;mouseup&#39;, me.onMouseUp, me, { single: true, view: sel.view });

                // Only begin the drag process if configured to select what they asked for
                if (startDragSelect) {
                    sel.view.el.on(&#39;mousemove&#39;, me.onMouseMove, me, {view: sel.view});
                }
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onMouseMove'>        /**
</span>         * Selects range based on mouse movements
         * @param e
         * @param cell
         * @param opts
         * @private
         */
        onMouseMove: function(e, target, opts) {
            var me = this,
                view = opts.view,
                record,
                rowIdx,
                cell = e.getTarget(view.cellSelector),
                header = opts.view.getHeaderByCell(cell),
                selData = me.selected,
                pos,
                recChange,
                colChange;

            if (header) {
                record = view.getRecord(cell.parentNode);
                rowIdx = me.store.indexOf(record);
                recChange = record !== me.lastOverRecord;
                colChange = header !== me.lastOverColumn;

                if (recChange || colChange) {
                    pos = me.getCellContext(record, header);
                }

                // Initial mousedown was in rownumberer or checkbox column
                if (selData.isRows) {
                    // Only react if we&#39;ve changed row
                    if (recChange) {
                        if (me.lastOverRecord) {
                            selData.setRangeEnd(rowIdx);
                        } else {
                            selData.setRangeStart(rowIdx);
                        }
                    }
                }
                // Selecting cells
                else {
                    // Only react if we&#39;ve changed row or column
                    if (recChange || colChange) {
                        if (me.lastOverRecord) {
                            selData.setRangeEnd(pos);
                        } else {
                            selData.setRangeStart(pos);
                        }
                    }
                }

                // Focus MUST follow the mouse.
                // Otherwise the focus may scroll out of the rendered range and revert to document
                if (recChange || colChange) {
                    // We MUST pass local view into NavigationModel, not the potentially outermost locking view.
                    // TODO: When that&#39;s fixed, use setPosition(pos).
                    view.getNavigationModel().setPosition(new Ext.grid.CellContext(header.getView()).setPosition(record, header));
                }
                me.lastOverColumn = header;
                me.lastOverRecord = record;
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onMouseUp'>        /**
</span>         * Clean up mousemove event
         * @param e
         * @param target
         * @param opts
         * @private
         */
        onMouseUp: function(e, target, opts) {
            var me = this,
                view = opts.view;

            if (view &amp;&amp; !view.isDestroyed) {
                view.el.un(&#39;mousemove&#39;, me.onMouseMove, me);

                // Copy the records encompassed by the drag range into the record collection
                if (me.selected.isRows) {
                    me.selected.addRange();
                }
                me.fireSelectionChange();
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-addCheckbox'>        /**
</span>         * Add the header checkbox to the header row
         * @param view
         * @param {Boolean} initial True if we&#39;re binding for the first time.
         * @private
         */
        addCheckbox: function(view, initial) {
            var me = this,
                checkbox = me.checkboxColumnIndex,
                headerCt = view.headerCt;

            // Preserve behaviour of false, but not clear why that would ever be done.
            if (checkbox !== false) {
                if (checkbox === &#39;first&#39;) {
                    checkbox = 0;
                } else if (checkbox === &#39;last&#39;) {
                    checkbox = headerCt.getColumnCount();
                }
                me.checkColumn = headerCt.add(checkbox, me.getCheckboxHeaderConfig());
            }

            if (initial !== true) {
                view.refresh();
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onNavigate'>        /**
</span>         * Called when the grid&#39;s Navigation model detects navigation events (`mousedown`, `click` and certain `keydown` events).
         * @param {Ext.event.EVent} navigateEvent The event which caused navigation.
         * @private
         */
        onNavigate: function(navigateEvent) {
            var me = this,
                // Use outermost view. May be lockable
                view = navigateEvent.view.ownerGrid.view,
                record = navigateEvent.record,
                sel = me.selected,

                // Create a new Context based upon the outermost View.
                // NavigationModel works on local views. TODO: remove this step when NavModel is fixed to use outermost view in locked grid.
                // At that point, we can use navigateEvent.position
                pos = new Ext.grid.CellContext(view).setPosition(record, navigateEvent.column),
                keyEvent = navigateEvent.keyEvent,
                keyCode = keyEvent.getKey(),
                selectionChanged;

            // CTRL/Arrow just navigates, does not select
            if (keyEvent.ctrlKey &amp;&amp; (keyCode === keyEvent.UP || keyCode === keyEvent.LEFT || keyCode === keyEvent.RIGHT || keyCode === keyEvent.DOWN)) {
                return;
            }

            // If all selection types are disabled, or it&#39;s not a selecting event, return
            if (!(me.cellSelect || me.columnSelect || me.rowSelect) || !navigateEvent.record || keyEvent.type === &#39;mousedown&#39;) {
                return;
            }

            // Ctrl/A key - Deselect current selection, or select all if no selection
            if (keyEvent.ctrlKey &amp;&amp; keyEvent.keyCode === keyEvent.A ) {
                // No selection, or only one, select all
                if (!sel || sel.getCount() &lt; 2) {
                    me.selectAll();
                } else {
                    me.deselectAll();
                }
                me.updateHeaderState();
                return;
            }

            if (keyEvent.shiftKey) {
                // If the event is in one of the row selecting cells, or cell selecting is turned off
                if (pos.column === me.numbererColumn || pos.column === me.checkColumn || !me.cellSelect || (sel &amp;&amp; sel.isRows)) {
                    if (me.rowSelect) {
                        // Ensure selection object is of the correct type
                        if (!sel || !sel.isRows || sel.view !== view) {
                            me.resetSelection(true);
                            sel = me.selected = new Ext.grid.selection.Rows(view);
                        }
                        // First shift
                        if (!sel.getRangeSize()) {
                            sel.setRangeStart(navigateEvent.previousRecordIndex || 0);
                        }
                        sel.setRangeEnd(navigateEvent.recordIndex);
                        selectionChanged = true;
                    }
                }
                // Navigate event in a normal cell
                else {
                    if (me.cellSelect) {
                        // Ensure selection object is of the correct type
                        if (!sel || !sel.isCells || sel.view !== view) {
                            me.resetSelection(true);
                            sel = me.selected = new Ext.grid.selection.Cells(view);
                        }
                        // First shift
                        if (!sel.getRangeSize()) {
                            sel.setRangeStart(navigateEvent.previousPosition || me.getCellContext(0, 0));
                        }
                        sel.setRangeEnd(pos);
                        selectionChanged = true;
                    }
                }
            } else {
                // If the event is in one of the row selecting cells, or cell selecting is turned off
                if (pos.column === me.numbererColumn || pos.column === me.checkColumn || !me.cellSelect) {
                    if (me.rowSelect) {
                        // Ensure selection object is of the correct type
                        if (!sel || !sel.isRows || sel.view !== view) {
                            me.resetSelection(true);
                            sel = me.selected = new Ext.grid.selection.Rows(view);
                        }

                        if (keyEvent.ctrlKey ||  pos.column === me.checkColumn) {
                            if (sel.contains(record)) {
                                sel.remove(record);
                            } else {
                                sel.add(record);
                            }
                        } else {
                            sel.clear();
                            sel.add(record);
                        }
                        selectionChanged = true;
                    }
                }
                // Navigate event in a normal cell
                else {
                    if (me.cellSelect) {
                        // Ensure selection object is of the correct type
                        if (!sel || !sel.isCells || sel.view !== view) {
                            me.resetSelection(true);
                            me.selected = sel = new Ext.grid.selection.Cells(view);
                        } else {
                            sel.clear();
                        }
                        sel.setRangeStart(pos);
                        selectionChanged = true;
                    }
                }
            }

            // If our configuration allowed selection changes, update check header and fire event
            if (selectionChanged) {
                if (sel.isRows) {
                    me.updateHeaderState();
                }
                me.fireSelectionChange();
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-isRowSelected'>        /**
</span>         * Check if given record is currently selected.
         *
         * Used in {@link Ext.view.Table view} rendering to decide upon cell UI treatment.
         * @param {Ext.data.Model} record
         * @return {Boolean}
         * @private
         */
        isRowSelected: function(record) {
            var me = this,
                sel = me.selected;

            if (sel &amp;&amp; sel.isRows) {
                record = Ext.isNumber(record) ? me.store.getAt(record) : record;
                return sel.contains(record);
            } else {
                return false;
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-isColumnSelected'>        /**
</span>         * Check if given column is currently selected.
         *
         * @param {Ext.grid.column.Column} column
         * @return {Boolean}
         * @private
         */
        isColumnSelected: function(column) {
            var me = this,
                sel = me.selected;

            if (sel &amp;&amp; sel.isColumns) {
                return sel.contains(column);
            } else {
                return false;
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-isCellSelected'>        /**
</span>         * Returns true if specified cell within specified view is selected
         *
         * Used in {@link Ext.view.Table view} rendering to decide upon row UI treatment.
         * @param {Ext.grid.View} view - impactful when locked columns are used
         * @param {Number} row - row index
         * @param {Number} column - column index, within the current view
         *
         * @return {Boolean}
         * @private
         */
        isCellSelected: function(view, row, column) {
            var me = this,
                testPos,
                sel = me.selected;

            // view MUST be outermost (possible locking) view
            view = view.ownerGrid.view;
            if (sel) {
                if (sel.isColumns) {
                    if (typeof column === &#39;number&#39;) {
                        column = view.getVisibleColumnManager().getColumns()[column];
                    }
                    return sel.contains(column);
                }

                if (sel.isCells) {
                    testPos = new Ext.grid.CellContext(view).setPosition({
                        row: row,
                        // IMPORTANT: The historic API for columns has been to include hidden columns
                        // in the index. So we must index into the &quot;all&quot; ColumnManager.
                        column: column
                    });

                    return sel.contains(testPos);
                }
            }

            return false;
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-applySelected'>        /**
</span>         * @private
         */
        applySelected: function(selected) {
            // Must override base class&#39;s applier which creates a Collection
            //&lt;debug&gt;
            if (selected &amp;&amp; !(selected.isRows || selected.isCells || selected.isColumns)) {
                Ext.error.raise(&#39;SpreadsheelModel#setSelected must be passed an instance of Ext.grid.selection.Selection&#39;);
            }
            //&lt;/debug&gt;
            return selected;
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-updateSelected'>        /**
</span>         * @private
         */
        updateSelected: function(selected, oldSelected) {
            var view,
                columns,
                len,
                i,
                cell;

            // Clear old selection.
            if (oldSelected) {
                oldSelected.clear();
            }

            // Update the UI to match the new selection
            if (selected &amp;&amp; selected.getCount()) {
                view = selected.view;

                // Rows; update each selected row
                if (selected.isRows) {
                    selected.eachRow(view.onRowSelect, view);
                }
                // Columns; update the selected columns for all rows
                else if (selected.isColumns) {
                    columns = selected.getColumns();
                    len = columns.length;

                    if (len) {
                        cell = new Ext.grid.CelContext(view);
                        view.store.each(function(rec) {
                            cell.setRow(rec);
                            for (i = 0; i &lt; len; i++) {
                                cell.setColumn(columns[i]);
                                view.onCellSelect(cell);
                            }
                        });
                    }
                }
                // Cells; update each selected cell
                else if (selected.isCells) {
                    selected.eachCell(view.onCellSelect, view);
                }
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-updateRowSelect'>        /**
</span>         * Show/hide the extra column headers depending upon rowSelection.
         * @private
         */
        updateRowSelect: function(rowSelect) {
            var me = this,
                sel = me.selected,
                view = me.view;

            if (view &amp;&amp; view.rendered) {
                // Always put row selection columns in the locked side if there is one.
                if (view.isNormalView) {
                    view = view.lockingPartner;
                }

                if (rowSelect) {
                    if (me.checkColumn) {
                        me.checkColumn.show();
                    }
                    if (me.numbererColumn) {
                        me.numbererColumn.show();
                    } else {
                        me.numbererColumn = view.headerCt.add(0, {
                            xtype: &#39;rownumberer&#39;,
                            width: me.rowNumbererHeaderWidth,
                            editRenderer:  &#39;&amp;#160;&#39;,
                            tdCls: me.rowNumbererTdCls,
                            cls: me.rowNumbererHeaderCls,
                            locked: me.hasLockedHeader
                        });
                    }
                } else {
                    if (me.checkColumn) {
                        me.checkColumn.hide();
                    }
                    if (me.numbererColumn) {
                        me.numbererColumn.hide();
                    }
                }
                if (!rowSelect &amp;&amp; sel &amp;&amp; sel.isRows) {
                    sel.clear();
                }
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-updateColumnSelect'>        /**
</span>         * Enable/disable the HeaderContainer&#39;s sortOnClick in line with column select on
         * column click.
         * @private
         */
        updateColumnSelect: function(columnSelect) {
            var me = this,
                sel = me.selected,
                views = me.views,
                len = views ? views.length : 0,
                i;

            for (i = 0; i &lt; len; i++) {
                views[i].headerCt.sortOnClick = !columnSelect;
            }
            if (!columnSelect &amp;&amp; sel &amp;&amp; sel.isColumns) {
                sel.clear();
            }
            if (columnSelect) {
                me.view.ownerGrid.addCls(me.columnSelectCls);
            } else {
                me.view.ownerGrid.removeCls(me.columnSelectCls);
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-updateCellSelect'>        /**
</span>         * @private
         */
        updateCellSelect: function(cellSelect) {
            var me = this,
                sel = me.selected;

            if (!cellSelect &amp;&amp; sel &amp;&amp; sel.isCells) {
                sel.clear();
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-fireSelectionChange'>        /**
</span>         * @private
         */
        fireSelectionChange: function () {
            var grid = this.view.ownerGrid;
            grid.fireEvent(&#39;selectionchange&#39;, grid, this.selected);
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onIdChanged'>        /**
</span>         * @private
         */
        onIdChanged: function(store, rec, oldId, newId) {
            var sel = this.selected;

            if (sel &amp;&amp; sel.isRows &amp;&amp; sel.selectedRecords) {
                sel.selectedRecords.updateKey(rec, oldId);
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onPageAdd'>        /**
</span>         * Called when a page is added to BufferedStore.
         * @private
         */
        onPageAdd: function(pageMap, pageNumber, records) {
            var sel = this.selected,
                len = records.length,
                i,
                record,
                selected = sel.selectedRecords;

            // Check for return of already selected records
            if (sel &amp;&amp; sel.isRows &amp;&amp; selected) {
                for (i = 0; i &lt; len; i++) {
                    record = records[i];
                    if (selected.get(record.id)) {
                        selected.replace(record);
                    }
                }
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-refresh'>        /**
</span>         * @private
         */
        refresh: function() {
            var sel = this.getSelected();

            // Refreshing the selected record Collection based upon a possible
            // store mutation is only valid if we are selecting records.
            if (sel &amp;&amp; sel.isRows) {
                this.callParent();
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onStoreAdd'>        /**
</span>         * @private
         */
        onStoreAdd: function() {
            var sel = this.getSelected();

            // Updating on store mutation is only valid if we are selecting records.
            if (sel &amp;&amp; sel.isRows) {
                this.callParent(arguments);
                this.updateHeaderState();
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onStoreClear'>        /**
</span>         * @private
         */
        onStoreClear: function() {
            this.resetSelection();
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onStoreLoad'>        /**
</span>         * @private
         */
        onStoreLoad: function() {
            var sel = this.getSelected();

            // Updating on store mutation is only valid if we are selecting records.
            if (sel &amp;&amp; sel.isRows) {
                this.callParent(arguments);
                this.updateHeaderState();
            }
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onStoreRefresh'>        /**
</span>         * @private
         */
        onStoreRefresh: function() {
            var sel = this.selected;

            // Ensure that records which are no longer in the new store are pruned if configured to do so.
            // Ensure that selected records in the collection are the correct instance.
            if (sel &amp;&amp; sel.isRows &amp;&amp; sel.selectedRecords) {
                this.updateSelectedInstances(sel.selectedRecords);
            }
            this.updateHeaderState();
        },

<span id='Ext-grid-selection-SpreadsheetModel-method-onStoreRemove'>        /**
</span>         * @private
         */
        onStoreRemove: function() {
            var sel = this.getSelected();

            // Updating on store mutation is only valid if we are selecting records.
            if (sel &amp;&amp; sel.isRows) {
                this.callParent(arguments);
            }
        }
    }
});
</pre>
</body>
</html>
