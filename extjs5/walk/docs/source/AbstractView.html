<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-view-AbstractView'>/**
</span> * @class Ext.view.AbstractView
 * This is an abstract superclass and should not be used directly. Please see {@link Ext.view.View}.
 * @private
 */
Ext.define(&#39;Ext.view.AbstractView&#39;, {
    extend: &#39;Ext.Component&#39;,
    requires: [
        &#39;Ext.LoadMask&#39;,
        &#39;Ext.CompositeElementLite&#39;,
        &#39;Ext.selection.DataViewModel&#39;,
        &#39;Ext.view.NavigationModel&#39;
    ],
    mixins: [
        &#39;Ext.util.StoreHolder&#39;
    ],

    inheritableStatics: {
<span id='Ext-view-AbstractView-static-method-getRecord'>        getRecord: function(node) {
</span>            return this.getBoundView(node).getRecord(node);
        },

<span id='Ext-view-AbstractView-static-method-getBoundView'>        getBoundView: function(node) {
</span>            return Ext.getCmp(node.getAttribute(&#39;data-boundView&#39;));
        }
    },
    
<span id='Ext-view-AbstractView-property-defaultBindProperty'>    defaultBindProperty: &#39;store&#39;,
</span>
<span id='Ext-view-AbstractView-property-renderBuffer'>    /// Private used for buffered rendering
</span>    renderBuffer: document.createElement(&#39;div&#39;),

    statics: {

<span id='Ext-view-AbstractView-static-cfg-updateDelay'>        /**
</span>         * @cfg {Number} [updateDelay=200] Global config for use when using {@link #throttledUpdate throttled view updating} if the data in the backing {@link Ext.data.Store store}
         * is being changed rapidly, for example receiving changes from the server through a WebSocket connection.
         *
         * To avoid too-frequent view updates overloading the browser with style recalculation, layout and paint requests, updates can be {@link #throttledUpdate throttled} to 
         * coalesced, and applied at the interval specified in milliseconds.
         */
        updateDelay: 200,

<span id='Ext-view-AbstractView-static-method-queueRecordChange'>        // @private
</span>        queueRecordChange: function(view, store, record, operation, modifiedFieldNames) {
            var me = this,
                changeQueue = me.changeQueue || (me.changeQueue = {}),
                recId = record.internalId,
                recChange,
                updated,
                len, i, fieldName, value,
                checkForReversion;

            recChange = changeQueue[recId] || (changeQueue[recId] = {
                operation: operation,
                record: record,
                data: {},
                views: []
            });

            // Hash of original values
            updated = recChange.data;

            // Make sure this view is among those updated when record changes are flushed
            Ext.Array.include(recChange.views, view);

            // Note the following condition tests the result of an assignment statement.
            // If we have been informed that specific fields have changed.
            if (modifiedFieldNames &amp;&amp; (len = modifiedFieldNames.length)) {
                for (i = 0; i &lt; len; i++) {
                    fieldName = modifiedFieldNames[i];
                    value = record.data[fieldName];

                    // More than one update is being performed...
                    if (updated.hasOwnProperty(fieldName)) {

                        // If the update is back to the original value, this may have reverted the record to original state
                        if (record.isEqual(updated[fieldName], value)) {
                            delete updated[fieldName];
                            checkForReversion = true;
                        }
                    }

                    // On first update, cache the original value
                    else {
                        updated[fieldName] = value;
                    }
                }

                // If the record has been returned to its original state, delete the queue entry.
                // checkForReversion flag saves the expensive (on legacy browsers) call to Ext.Object.getKeys
                if (checkForReversion &amp;&amp; !Ext.Object.getKeys(updated).length) {
                    delete changeQueue[recId];
                }
            }

            // Unpsecified fields have changed. We have to collect the whole data object.
            else {
                Ext.apply(updated, record.data);
            }

            // Create a task which will call on to the onFlushTick every updateDelay milliseconds.
            if (!me.flushQueueTask) {
                me.flushQueueTask = Ext.util.TaskManager.newTask({
                    // Queue the actual render flush on the next animation frame if available.
                    run: Ext.global.requestAnimationFrame ? Ext.Function.createAnimationFrame(me.onFlushTick, me) : Ext.Function.bind(me.onFlushTick, me),
                    interval: Ext.view.AbstractView.updateDelay,
                    repeat: 1
                });
            }
            me.flushQueueTask.start();
        },

<span id='Ext-view-AbstractView-static-method-onFlushTick'>        // @private
</span>        // On every flush (determined by updateDelay setting), ask the animation system to schedule a call to flushChangeQueue at the next animation frame.
        onFlushTick: function() {
            Ext.AnimationQueue.start(this.flushChangeQueue, this);
        },

<span id='Ext-view-AbstractView-static-method-flushChangeQueue'>        /**
</span>        * @private
        * Flushes all queued field updates to the UI.
        *
        * Called in the context of the AbstractView class.
        *
        * The queue is shared across all Views so that there is only one global flush operation.
        */
        flushChangeQueue: function() {
            // Maintainer: Note that &quot;me&quot; references AbstractView class
            var me = this,
                dirtyViews,
                len,
                changeQueue,
                recChange,
                recId,
                i, view;

            // If there is scrolling going on anywhere, requeue the flush operation.
            if (Ext.isScrolling) {
                me.flushQueueTask.start();
                return;
            }

            changeQueue = me.changeQueue;

            // Empty the view&#39;s changeQueue
            this.changeQueue = {};

            for (recId in changeQueue) {
                recChange = changeQueue[recId];
                dirtyViews = recChange.views;
                len = dirtyViews.length;

                // Loop through all the views which have outstanding changes.
                for (i = 0; i &lt; len; i++) {
                    view = dirtyViews[i];

                    // View may have been destroyed during the buffered phase.
                    if (!view.isDestroyed) {
                        view.handleUpdate(view.dataSource, recChange.record, recChange.operation, Ext.Object.getKeys(recChange.data));
                    }
                }
            }
            Ext.AnimationQueue.stop(me.flushChangeQueue, me);
        }
    },

    config: {
<span id='Ext-view-AbstractView-cfg-selection'>        /**
</span>         * @cfg {Ext.data.Model} selection
         * The selected model. Typically used with {@link #bind binding}.
         */
        selection: null,

<span id='Ext-view-AbstractView-cfg-store'>        /*
</span>         * @cfg {Ext.data.Store} store
         * The {@link Ext.data.Store} to bind this DataView to.
         * @since 2.3.0
         */
        store: &#39;ext-empty-store&#39;,

        // @cmd-auto-dependency { aliasPrefix: &#39;view.navigation.&#39; }
<span id='Ext-view-AbstractView-cfg-navigationModel'>        /**
</span>         * @private
         * The {@link Ext.view.NavigationModel} [default] alias to use.
         * @since 5.0.1
         */
        navigationModel: {
            type: &#39;default&#39;
        },

        // @cmd-auto-dependency { aliasPrefix: &#39;selection.&#39; }
<span id='Ext-view-AbstractView-cfg-selectionModel'>        /**
</span>         * @cfg {Object/Ext.selection.DataViewModel} selectionModel
         * The {@link Ext.selection.Model selection model} [dataviewmodel] config or alias to use.
         * @since 5.1.0
         */
        selectionModel: {
            type: &#39;dataviewmodel&#39;
        }
    },

<span id='Ext-view-AbstractView-cfg-publishes'>    publishes: [&#39;selection&#39;],
</span><span id='Ext-view-AbstractView-cfg-twoWayBindable'>    twoWayBindable: [&#39;selection&#39;],
</span>
<span id='Ext-view-AbstractView-cfg-throttledUpdate'>    /**
</span>     * @cfg {Boolean} [throttledUpdate=false]
     * Configure as `true` to have this view participate in the global throttled update queue which flushes store changes to the UI at a maximum rate
     * determined by the {@link #updateDelay} setting.
     */
    throttledUpdate: false,

<span id='Ext-view-AbstractView-cfg-tpl'>    /**
</span>     * @cfg {String/String[]/Ext.XTemplate} tpl (required)
     * The HTML fragment or an array of fragments that will make up the template used by this DataView.  This should
     * be specified in the same format expected by the constructor of {@link Ext.XTemplate}. When a `tpl` is specified,
     * this class assumes that records are rendered in the order they appear in the `{@link #store}`. If a custom `tpl`
     * does not conform to this assumption, index values will be incorrect which may cause the view to misbehave.
     * @since 2.3.0
     */

<span id='Ext-view-AbstractView-cfg-deferInitialRefresh'>    /**
</span>     * @cfg {Boolean} [deferInitialRefresh=false]
     * Configure as &#39;true` to defer the initial refresh of the view.
     *
     * This allows the View to execute its render and initial layout more quickly because the process will not be encumbered
     * by the update of the view structure.
     */
    deferInitialRefresh: false,

<span id='Ext-view-AbstractView-cfg-itemSelector'>    /**
</span>     * @cfg {String} itemSelector (required)
     * &lt;b&gt;This is a required setting&lt;/b&gt;. A simple CSS selector (e.g. `div.some-class` or
     * `span:first-child`) that will be used to determine what nodes this DataView will be
     * working with. The itemSelector is used to map DOM nodes to records. As such, there should
     * only be one root level element that matches the selector for each record. The itemSelector
     * will be automatically configured if the {@link #itemTpl} config is used.
     * 
     *     new Ext.view.View({
     *         renderTo: Ext.getBody(),
     *         store: {
     *             fields: [&#39;name&#39;],
     *             data: [
     *                 {name: &#39;Item 1&#39;},
     *                 {name: &#39;Item 2&#39;}
     *             ]
     *         },
     *         tpl: [
     *             &#39;&lt;ul&gt;&#39;,
     *             &#39;&lt;tpl for=&quot;.&quot;&gt;&#39;,
     *                 &#39;&lt;li&gt;{name}&lt;/li&gt;&#39;,
     *             &#39;&lt;/tpl&gt;&#39;,
     *             &#39;&lt;/ul&gt;&#39;
     *         ],
     *         // Match the li, since each one maps to a record
     *         itemSelector: &#39;li&#39;
     *     });
     * 
     * @since 2.3.0
     */

<span id='Ext-view-AbstractView-cfg-itemCls'>    /**
</span>     * @cfg {String} itemCls
     * Specifies the class to be assigned to each element in the view when used in conjunction with the
     * {@link #itemTpl} configuration.
     * @since 2.3.0
     */
    itemCls: Ext.baseCSSPrefix + &#39;dataview-item&#39;,

<span id='Ext-view-AbstractView-cfg-itemTpl'>    /**
</span>     * @cfg {String/String[]/Ext.XTemplate} itemTpl
     * The inner portion of the item template to be rendered. Follows an XTemplate
     * structure and will be placed inside of a tpl.
     */

<span id='Ext-view-AbstractView-cfg-overItemCls'>    /**
</span>     * @cfg {String} overItemCls
     * A CSS class to apply to each item in the view on mouseover.
     * Setting this will automatically set {@link #trackOver} to `true`.
     */

    //&lt;locale&gt;
<span id='Ext-view-AbstractView-cfg-loadingText'>    /**
</span>     * @cfg {String} loadingText
     * A string to display during data load operations.  If specified, this text will be
     * displayed in a loading div and the view&#39;s contents will be cleared while loading, otherwise the view&#39;s
     * contents will continue to display normally until the new data is loaded and the contents are replaced.
     * @since 2.3.0
     */
    loadingText: &#39;Loading...&#39;,
    //&lt;/locale&gt;

<span id='Ext-view-AbstractView-cfg-loadMask'>    /**
</span>     * @cfg {Boolean/Object} loadMask
     * False to disable a load mask from displaying while the view is loading. This can also be a
     * {@link Ext.LoadMask} configuration object.
     */
    loadMask: true,

<span id='Ext-view-AbstractView-cfg-loadingCls'>    /**
</span>     * @cfg {String} loadingCls
     * The CSS class to apply to the loading message element. Defaults to Ext.LoadMask.prototype.msgCls &quot;x-mask-loading&quot;.
     */

<span id='Ext-view-AbstractView-cfg-loadingUseMsg'>    /**
</span>     * @cfg {Boolean} loadingUseMsg
     * Whether or not to use the loading message.
     * @private
     */
    loadingUseMsg: true,


<span id='Ext-view-AbstractView-cfg-loadingHeight'>    /**
</span>     * @cfg {Number} loadingHeight
     * If specified, gives an explicit height for the data view when it is showing the {@link #loadingText},
     * if that is specified. This is useful to prevent the view&#39;s height from collapsing to zero when the
     * loading mask is applied and there are no other contents in the data view.
     */

<span id='Ext-view-AbstractView-cfg-selectedItemCls'>    /**
</span>     * @cfg {String} selectedItemCls
     * A CSS class to apply to each selected item in the view.
     */
    selectedItemCls: Ext.baseCSSPrefix + &#39;item-selected&#39;,

    //&lt;locale&gt;
<span id='Ext-view-AbstractView-cfg-emptyText'>    /**
</span>     * @cfg {String} emptyText
     * The text to display in the view when there is no data to display.
     * Note that when using local data the emptyText will not be displayed unless you set
     * the {@link #deferEmptyText} option to false.
     * @since 2.3.0
     */
    emptyText: &quot;&quot;,
    //&lt;/locale&gt;

<span id='Ext-view-AbstractView-cfg-deferEmptyText'>    /**
</span>     * @cfg {Boolean} deferEmptyText
     * True to defer emptyText being applied until the store&#39;s first load.
     * @since 2.3.0
     */
    deferEmptyText: true,

<span id='Ext-view-AbstractView-cfg-trackOver'>    /**
</span>     * @cfg {Boolean} trackOver
     * When `true` the {@link #overItemCls} will be applied to rows when hovered over.
     * This in return will also cause {@link Ext.view.View#highlightitem highlightitem} and
     * {@link Ext.view.View#unhighlightitem unhighlightitem} events to be fired.
     *
     * Enabled automatically when the {@link #overItemCls} config is set.
     *
     * @since 2.3.0
     */
    trackOver: false,

<span id='Ext-view-AbstractView-cfg-blockRefresh'>    /**
</span>     * @cfg {Boolean} blockRefresh
     * Set this to true to ignore refresh events on the bound store. This is useful if
     * you wish to provide custom transition animations via a plugin
     * @since 3.4.0
     */
    blockRefresh: false,

<span id='Ext-view-AbstractView-cfg-disableSelection'>    /**
</span>     * @cfg {Boolean} [disableSelection=false]
     * True to disable selection within the DataView. This configuration will lock the selection model
     * that the DataView uses.
     */

<span id='Ext-view-AbstractView-cfg-preserveScrollOnRefresh'>    /**
</span>     * @cfg {Boolean} preserveScrollOnRefresh
     * True to preserve scroll position across refresh operations.
     */
    preserveScrollOnRefresh: false,

<span id='Ext-view-AbstractView-property-ariaRole'>    ariaRole: &#39;listbox&#39;,
</span><span id='Ext-view-AbstractView-property-itemAriaRole'>    itemAriaRole: &#39;option&#39;,
</span>    
<span id='Ext-view-AbstractView-property-last'>    //private
</span>    last: false,
<span id='Ext-view-AbstractView-property-focusable'>    focusable: true,
</span><span id='Ext-view-AbstractView-cfg-tabIndex'>    tabIndex: 0,
</span>
<span id='Ext-view-AbstractView-property-triggerEvent'>    triggerEvent: &#39;itemclick&#39;,
</span><span id='Ext-view-AbstractView-property-triggerCtEvent'>    triggerCtEvent: &#39;containerclick&#39;,
</span>
<span id='Ext-view-AbstractView-property-refreshNeeded'>    // Starts as true by default so that pn the leading edge of the first layout a refresh will be triggered.
</span>    // A refresh opereration sets this flag to false.
    // When a refresh is requested using refreshView, the request may be deferred because of hidden or collapsed state.
    // This is done by setting the refreshNeeded flag to true, and the the next layout will trigger  refresh.
    refreshNeeded: true,

<span id='Ext-view-AbstractView-method-addCmpEvents'>    addCmpEvents: Ext.emptyFn,
</span>
<span id='Ext-view-AbstractView-event-beforerefresh'>    /**
</span>     * @event beforerefresh
     * Fires before the view is refreshed
     * @param {Ext.view.View} this The DataView object
     */

<span id='Ext-view-AbstractView-event-refresh'>    /**
</span>     * @event refresh
     * Fires when the view is refreshed
     * @param {Ext.view.View} this The DataView object
     */

<span id='Ext-view-AbstractView-event-viewready'>    /**
</span>     * @event viewready
     * Fires when the View&#39;s item elements representing Store items has been rendered. No items will be available
     * for selection until this event fires.
     * @param {Ext.view.View} this
     */

<span id='Ext-view-AbstractView-event-itemupdate'>    /**
</span>     * @event itemupdate
     * Fires when the node associated with an individual record is updated
     * @param {Ext.data.Model} record The model instance
     * @param {Number} index The index of the record
     * @param {HTMLElement} node The node that has just been updated
     */

<span id='Ext-view-AbstractView-event-itemadd'>    /**
</span>     * @event itemadd
     * Fires when the nodes associated with an recordset have been added to the underlying store
     * @param {Ext.data.Model[]} records The model instance
     * @param {Number} index The index at which the set of records was inserted
     * @param {HTMLElement[]} node The node that has just been updated
     */

<span id='Ext-view-AbstractView-event-itemremove'>    /**
</span>     * @event itemremove
     * Fires when the node associated with an individual record is removed
     * @param {Ext.data.Model} record The model instance
     * @param {Number} index The index from which the record was removed
     * @param {HTMLElement} item The view item removed
     * @param {Ext.view.View} view The view removing the item
     */

    constructor: function(config) {
        if (config &amp;&amp; config.selModel) {
            config.selectionModel = config.selModel;
        }
        this.callParent([config]);
    },

<span id='Ext-view-AbstractView-method-initComponent'>    // private
</span>    initComponent: function(){
        var me = this,
            isDef = Ext.isDefined,
            itemTpl = me.itemTpl,
            memberFn = {};

        if (itemTpl) {
            if (Ext.isArray(itemTpl)) {
                // string array
                itemTpl = itemTpl.join(&#39;&#39;);
            } else if (Ext.isObject(itemTpl)) {
                // tpl instance
                memberFn = Ext.apply(memberFn, itemTpl.initialConfig);
                itemTpl = itemTpl.html;
            }

            if (!me.itemSelector) {
                me.itemSelector = &#39;.&#39; + me.itemCls;
            }

            itemTpl = Ext.String.format(&#39;&lt;tpl for=&quot;.&quot;&gt;&lt;div class=&quot;{0}&quot; role=&quot;{2}&quot;&gt;{1}&lt;/div&gt;&lt;/tpl&gt;&#39;, me.itemCls, itemTpl, me.itemAriaRole);
            me.tpl = new Ext.XTemplate(itemTpl, memberFn);
        }

        //&lt;debug&gt;
        if (!isDef(me.tpl) || !isDef(me.itemSelector)) {
            Ext.Error.raise({
                sourceClass: &#39;Ext.view.View&#39;,
                tpl: me.tpl,
                itemSelector: me.itemSelector,
                msg: &quot;DataView requires both tpl and itemSelector configurations to be defined.&quot;
            });
        }
        //&lt;/debug&gt;

        me.callParent();
        me.tpl = me.getTpl(&#39;tpl&#39;);

        //&lt;debug&gt;
        // backwards compat alias for overClass/selectedClass
        // TODO: Consider support for overCls generation Ext.Component config
        if (isDef(me.overCls) || isDef(me.overClass)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn(&#39;Ext.view.View: Using the deprecated overCls or overClass configuration. Use overItemCls instead.&#39;);
            }
            me.overItemCls = me.overCls || me.overClass;
            delete me.overCls;
            delete me.overClass;
        }

        if (isDef(me.selectedCls) || isDef(me.selectedClass)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn(&#39;Ext.view.View: Using the deprecated selectedCls or selectedClass configuration. Use selectedItemCls instead.&#39;);
            }
            me.selectedItemCls = me.selectedCls || me.selectedClass;
            delete me.selectedCls;
            delete me.selectedClass;
        }
        //&lt;/debug&gt;

        if (me.overItemCls) {
            me.trackOver = true;
        }

        me.addCmpEvents();

        // Look up the configured Store. If none configured, use the fieldless, empty Store defined in Ext.data.Store.
        me.store = Ext.data.StoreManager.lookup(me.store || &#39;ext-empty-store&#39;);
        
        // Use the provided store as the data source unless a Feature or plugin has injected a special one
        if (!me.dataSource) {
            me.dataSource = me.store;
        }

        // Must exist before the selection model.
        // Selection model listens to this for navigation events.
        me.getNavigationModel().bindComponent(this);

        // Bind to the data source. Cache it by the property name &quot;dataSource&quot;.
        // The store property is public and must reference the provided store.
        // The selection model is configured and bound to the store at the top of bindStore.
        me.bindStore(me.dataSource, true, &#39;dataSource&#39;);

        if (!me.all) {
            me.all = new Ext.CompositeElementLite();
        }

        // We track the scroll position
        me.scrollState = {
            top: 0,
            left: 0
        };

        me.savedTabIndexAttribute = &#39;data-savedtabindex-&#39; + me.id;
    },
    
<span id='Ext-view-AbstractView-method-getElConfig'>    getElConfig: function() {
</span>        var result = this.mixins.renderable.getElConfig.call(this);

        // Subclasses may set focusable to false (BoundList is not focusable)
        if (this.focusable) {
            result.tabIndex = 0;
        }
        return result;
    },

<span id='Ext-view-AbstractView-method-onRender'>    onRender: function() {
</span>        var mask = this.loadMask;

        this.callParent(arguments);
        if (mask) {
            this.createMask(mask);
        }
    },

<span id='Ext-view-AbstractView-method-beforeLayout'>    beforeLayout: function() {
</span>        var me = this;

        me.callParent(arguments);

        // If a refresh is needed, just before the layout is the time to apply it.
        // If there is a deferred refresh timer running, allow that to do the refresh.
        if (me.refreshNeeded &amp;&amp; !me.pendingRefresh) {
            // If we have refreshed before, just call a refresh now.
            if (me.refreshCounter) {
                me.refresh();
            }
            else {
                me.doFirstRefresh(me.dataSource);
            }
        }
    },

<span id='Ext-view-AbstractView-method-getMaskStore'>    getMaskStore: function(){
</span>        return this.store;
    },

<span id='Ext-view-AbstractView-method-onMaskBeforeShow'>    onMaskBeforeShow: function(){
</span>        var me = this,
            loadingHeight = me.loadingHeight;

        if (loadingHeight &amp;&amp; loadingHeight &gt; me.getHeight()) {
            me.hasLoadingHeight = true;
            me.oldMinHeight = me.minHeight;
            me.minHeight = loadingHeight;
            me.updateLayout();
        }
    },

<span id='Ext-view-AbstractView-method-onMaskHide'>    onMaskHide: function(){
</span>        var me = this;

        if (!me.destroying &amp;&amp; me.hasLoadingHeight) {
            me.minHeight = me.oldMinHeight;
            me.updateLayout();
            delete me.hasLoadingHeight;
        }
    },

<span id='Ext-view-AbstractView-method-beforeRender'>    beforeRender: function() {
</span>        this.callParent(arguments);
        this.getSelectionModel().beforeViewRender(this);
    },

<span id='Ext-view-AbstractView-method-afterRender'>    afterRender: function() {
</span>        this.callParent(arguments);

        // Subclasses may set focusable to false.
        // BoundList is not focusable.
        // BoundList processes key events from its boundField.
        if (this.focusable) {
            this.focusEl = this.el;
        }
    },

<span id='Ext-view-AbstractView-method-getRefItems'>    getRefItems: function() {
</span>        var mask = this.loadMask,
            result = [];

        if (mask &amp;&amp; mask.isComponent) {
            result.push(mask);
        }
        return result;
    },

<span id='Ext-view-AbstractView-method-getSelection'>    getSelection: function() {
</span>        return this.getSelectionModel().getSelection();
    },

<span id='Ext-view-AbstractView-method-updateSelection'>    updateSelection: function(selection) {
</span>        var me = this,
            sm;

        if (!me.ignoreNextSelection) {
            me.ignoreNextSelection = true;
            sm = me.getSelectionModel();
            if (selection) {
                sm.select(selection);
            } else {
                sm.deselectAll();
            }
            me.ignoreNextSelection = false;
        }
    },

<span id='Ext-view-AbstractView-method-updateBindSelection'>    updateBindSelection: function(selModel, selection) {
</span>        var me = this,
            selected = null;

        if (!me.ignoreNextSelection) {
            me.ignoreNextSelection = true;
            if (selection.length) {
                selected = selModel.getLastSelected();
                me.hasHadSelection = true;
            }
            if (me.hasHadSelection) {
                me.setSelection(selected);
            }
            me.ignoreNextSelection = false;
        }
    },

<span id='Ext-view-AbstractView-method-applySelectionModel'>    applySelectionModel: function(selModel, oldSelModel) { 
</span>        var me = this,
            mode;

        if (oldSelModel) {
            oldSelModel.un(&#39;selectionchange&#39;, me.updateBindSelection, me);
            Ext.destroy(me.selModelRelayer);
            selModel = Ext.Factory.selection(selModel);
        }
        // If this is the initial configuration, pull overriding configs in from this view
        else {
            if (selModel &amp;&amp; selModel.isSelectionModel) {
                selModel.locked = me.disableSelection;
            } else {
                if (me.simpleSelect) {
                    mode = &#39;SIMPLE&#39;;
                } else if (me.multiSelect) {
                    mode = &#39;MULTI&#39;;
                } else {
                    mode = &#39;SINGLE&#39;;
                }

                if (typeof selModel === &#39;string&#39;) {
                    selModel = {
                        type: selModel
                    };
                }
                selModel = Ext.Factory.selection(Ext.apply({
                    allowDeselect: me.allowDeselect || me.multiSelect,
                    mode: mode,
                    locked: me.disableSelection
                }, selModel));
            }
        }

        me.selModelRelayer = me.relayEvents(selModel, [
            &#39;selectionchange&#39;, &#39;beforeselect&#39;, &#39;beforedeselect&#39;, &#39;select&#39;, &#39;deselect&#39;, &#39;focuschange&#39;
        ]);
        selModel.on(&#39;selectionchange&#39;, me.updateBindSelection, me);

        return selModel;
    },

<span id='Ext-view-AbstractView-method-updateSelectionModel'>    updateSelectionModel: function(selectionModel) {
</span>        // Keep the legacy property correct
        this.selModel = selectionModel;
    },

<span id='Ext-view-AbstractView-method-applyNavigationModel'>    applyNavigationModel: function (navigationModel) {
</span>        return Ext.Factory.viewNavigation(navigationModel);
    },

<span id='Ext-view-AbstractView-method-onFocusEnter'>    onFocusEnter: function(e) {
</span>        var me = this,
            navigationModel = me.getNavigationModel(),
            focusPosition;

        if (!me.itemFocused &amp;&amp; me.all.getCount()) {
            focusPosition = navigationModel.getLastFocused();
            navigationModel.setPosition(focusPosition || 0, e.event, null, !focusPosition);

            // We now contain focus is that was successful
            me.itemFocused = navigationModel.getPosition() != null;
        }

        if (me.itemFocused) {
            this.el.dom.setAttribute(&#39;tabindex&#39;, &#39;-1&#39;);
        }
    },

<span id='Ext-view-AbstractView-method-onFocusLeave'>    onFocusLeave: function(e) {
</span>        var me = this;

        // Ignore this event if we do not actually contain focus.
        if (me.itemFocused) {

            // Blur the focused cell
            me.getNavigationModel().setPosition(null, e.event, null, true);

            me.itemFocused = false;
            me.el.dom.setAttribute(&#39;tabindex&#39;, 0);
        }
    },

<span id='Ext-view-AbstractView-method-onRemoved'>    onRemoved: function(isDestroying) {
</span>        this.callParent([isDestroying]);

        // IE does not fire focusleave on removal from DOM
        this.onFocusLeave({});
    },
    
<span id='Ext-view-AbstractView-method-refresh'>    /**
</span>     * Refreshes the view by reloading the data from the store and re-rendering the template.
     * @since 2.3.0
     */
    refresh: function() {
        var me = this,
            rows = me.all,
            prevRowCount = rows.getCount(),
            refreshCounter = me.refreshCounter,
            targetEl,
            overflowEl,
            dom,
            records,
            hasFirstRefresh,
            selModel = me.getSelectionModel(),
            navModel = me.getNavigationModel(),
            lastFocusPosition = navModel.getPosition(),

            // If there are items in the view, and there isn&#39;t a scroll range stretcher (bufferedRenderer), then honour preserveScrollOnRefresh
            preserveScroll = refreshCounter &amp;&amp; rows.getCount() &amp;&amp; me.preserveScrollOnRefresh &amp;&amp; !me.bufferedRenderer,
            scrollPos;

        if (!me.rendered || me.isDestroyed || me.preventRefresh) {
            return;
        }

        if (!me.hasListeners.beforerefresh || me.fireEvent(&#39;beforerefresh&#39;, me) !== false) {

            // So that listeners to itemremove events know that its because of a refresh
            me.refreshing = true;

            // Allow the NavigationModel to cache the focus position.
            navModel.beforeViewRefresh();

            targetEl = me.getTargetEl();
            records = me.getViewRange();
            dom = targetEl.dom;

            if (preserveScroll) {
                overflowEl = me.getOverflowEl();
                scrollPos = overflowEl.getScroll();
            }

            if (refreshCounter) {
                hasFirstRefresh = true;
                me.clearViewEl();
                me.refreshCounter++;
            } else {
                me.refreshCounter = 1;
            }

            // Usually, for an empty record set, this would be blank, but when the Template
            // Creates markup outside of the record loop, this must still be honoured even if there are no
            // records.
            me.tpl.append(targetEl, me.collectData(records, rows.startIndex || 0));

            // The emptyText is now appended to the View&#39;s element
            // after nodes outside the tpl block.
            if (records.length &lt; 1) {
                // Process empty text unless the store is being cleared.
                if (me.emptyText &amp;&amp; !me.getStore().isLoading() &amp;&amp; (!me.deferEmptyText || hasFirstRefresh)) {
                    me.emptyEl = Ext.core.DomHelper.insertHtml(&#39;beforeEnd&#39;, targetEl.dom, me.emptyText);
                }
                rows.clear();
            } else {
                me.collectNodes(targetEl.dom);
                me.updateIndexes(0);
            }

            // Allow the NavigationModel to restore lost focus into the view
            navModel.onViewRefresh();

            // Some subclasses do not need to do this. TableView does not need to do this - it renders selected class using its tenmplate.
            if (me.refreshSelmodelOnRefresh !== false) {
                selModel.refresh();
            }

            me.refreshNeeded = false;

            // Ensure layout system knows about new content size.
            // If number of rows have changed, force a layout.
            me.refreshSize(rows.getCount() !== prevRowCount);

            me.fireEvent(&#39;refresh&#39;, me, records);

            if (preserveScroll) {
                overflowEl.setScrollLeft(scrollPos.left);
                overflowEl.setScrollTop(scrollPos.top);
            }

            // Upon first refresh, fire the viewready event.
            // Reconfiguring the grid &quot;renews&quot; this event.
            if (!me.viewReady) {
                // Fire an event when deferred content becomes available.
                me.viewReady = true;
                me.fireEvent(&#39;viewready&#39;, me);
            }
            me.refreshing = false;
            me.refreshScroll();
        }
    },
    
<span id='Ext-view-AbstractView-method-toggleChildrenTabbability'>    // @private
</span>    toggleChildrenTabbability: function(enableTabbing) {
        var attr = this.savedTabIndexAttribute,
            focusEl = this.getTargetEl();
        
        if (enableTabbing) {
            focusEl.restoreChildrenTabbableState(attr);
        }
        else {
            focusEl.saveChildrenTabbableState(attr);
        }
    },

<span id='Ext-view-AbstractView-method-collectNodes'>    // Private
</span>    // Called by refresh to collect the view item nodes.
    collectNodes: function(targetEl) {
        var all = this.all;

        all.fill(Ext.fly(targetEl).query(this.getItemSelector()), all.startIndex || 0);

        // Subclasses may set focusable to false (BoundList is not focusable)
        if (this.focusable) {
            all.set({tabindex: &#39;-1&#39;});
        }
    },

<span id='Ext-view-AbstractView-method-getViewRange'>    getViewRange: function() {
</span>        return this.dataSource.getRange();
    },

<span id='Ext-view-AbstractView-method-refreshSize'>    /**
</span>     * @private
     * Called by the framework when the view is refreshed, or when rows are added or deleted.
     *
     * These operations may cause the view&#39;s dimensions to change, and if the owning container
     * is shrinkwrapping this view, then the layout must be updated to accommodate these new dimensions.
     */
    refreshSize: function(forceLayout) {
        var me = this,
            sizeModel = me.getSizeModel(),
            scroller = me.getScrollable();

        if (sizeModel.height.shrinkWrap || sizeModel.width.shrinkWrap || forceLayout) {
            me.updateLayout();
        }

        // We need to refresh the Scroller (BufferedRenderer has to do this if present).
        // But the first refresh takes place on the leading edge of the first layout
        // before the Scroller has been initialized, so do it as soon
        // as we reach boxready.
        else if (me.touchScroll &amp;&amp; !me.bufferedRenderer) {
            if (scroller) {
                scroller.refresh();
            } else {
                me.on({
                    boxready: me.refreshScroll,
                    scope: me,
                    single: true
                });
            }
        }
    },

<span id='Ext-view-AbstractView-method-onResize'>    onResize: function() {
</span>        var me = this,
            scroller = me.getScrollable();

        if (scroller &amp;&amp; !me._hasScrollListener) {
            scroller.on({
                scroll: me.onViewScroll,
                scope: me,
                onFrame: !!Ext.global.requestAnimationFrame
            });
            me._hasScrollListener = true;
        }
        this.callParent(arguments);
    },

<span id='Ext-view-AbstractView-method-clearViewEl'>    clearViewEl: function() {
</span>        var me = this,
            targetEl = me.getTargetEl(),
            nodeContainerIsTarget = me.getNodeContainer() === targetEl;

        me.clearEmptyEl();
        // If nodeContainer is the el, just clear the innerHTML. Otherwise, we need
        // to manually remove each node we know about.
        me.all.clear(!nodeContainerIsTarget);
        if (nodeContainerIsTarget) {
            targetEl.dom.innerHTML = &#39;&#39;;
        }
    },

<span id='Ext-view-AbstractView-method-clearEmptyEl'>    clearEmptyEl: function() {
</span>        var emptyEl = this.emptyEl;

        // emptyEl is likely to be a TextNode if emptyText is not HTML code.
        // Use native DOM to remove it.
        if (emptyEl) {
            emptyEl.parentNode.removeChild(emptyEl);
        }
        this.emptyEl = null;
    },

<span id='Ext-view-AbstractView-method-onViewScroll'>    onViewScroll: function(scroller, x, y) {
</span>        this.fireEvent(&#39;scroll&#39;, this, x, y);
    },

<span id='Ext-view-AbstractView-method-saveScrollState'>    /**
</span>     * Saves the scrollState in a private variable. Must be used in conjunction with restoreScrollState.
     * @private
     */
    saveScrollState: function() {
        var me = this,
            state = me.scrollState;

        if (me.rendered) {
            state.left = me.getScrollX();
            state.top = me.getScrollY();
        }
    },

<span id='Ext-view-AbstractView-method-restoreScrollState'>    /**
</span>     * Restores the scrollState.
     * Must be used in conjunction with saveScrollState
     * @private
     */
    restoreScrollState: function() {
        var me = this,
            state = me.scrollState;

        if (me.rendered) {
            me.setScrollX(state.left);
            me.setScrollY(state.top);
        }
    },

<span id='Ext-view-AbstractView-method-prepareData'>    /**
</span>     * Function which can be overridden to provide custom formatting for each Record that is used by this
     * DataView&#39;s {@link #tpl template} to render each node.
     * @param {Object/Object[]} data The raw data object that was used to create the Record.
     * @param {Number} recordIndex the index number of the Record being prepared for rendering.
     * @param {Ext.data.Model} record The Record being prepared for rendering.
     * @return {Array/Object} The formatted data in a format expected by the internal {@link #tpl template}&#39;s overwrite() method.
     * (either an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: &#39;bar&#39;}))
     * @since 2.3.0
     */
    prepareData: function(data, index, record) {
        var associatedData, attr, hasCopied;
        if (record) {
            associatedData = record.getAssociatedData();
            for (attr in associatedData) {
                if (associatedData.hasOwnProperty(attr)) {
                    // This would be better done in collectData, however
                    // we only need to copy the data object if we have any associations,
                    // so we optimize it by only copying if we must.
                    // We do this so we don&#39;t mutate the underlying record.data
                    if (!hasCopied) {
                        data = Ext.Object.chain(data);
                        hasCopied = true;
                    }
                    data[attr] = associatedData[attr];
                }
            }
        }
        return data;
    },

<span id='Ext-view-AbstractView-method-collectData'>    /**
</span>     * Function which can be overridden which returns the data object passed to this
     * DataView&#39;s {@link #cfg-tpl template} to render the whole DataView.
     *
     * This is usually an Array of data objects, each element of which is processed by an
     * {@link Ext.XTemplate XTemplate} which uses `&#39;&amp;lt;tpl for=&quot;.&quot;&amp;gt;&#39;` to iterate over its supplied
     * data object as an Array. However, &lt;i&gt;named&lt;/i&gt; properties may be placed into the data object to
     * provide non-repeating data such as headings, totals etc.
     *
     * @param {Ext.data.Model[]} records An Array of {@link Ext.data.Model}s to be rendered into the DataView.
     * @param {Number} startIndex the index number of the Record being prepared for rendering.
     * @return {Object[]} An Array of data objects to be processed by a repeating XTemplate. May also
     * contain &lt;i&gt;named&lt;/i&gt; properties.
     * @since 2.3.0
     */
    collectData: function(records, startIndex){
        var data = [],
            i = 0,
            len = records.length,
            record;

        for (; i &lt; len; i++) {
            record = records[i];
            data[i] = this.prepareData(record.data, startIndex + i, record);
        }
        return data;
    },

<span id='Ext-view-AbstractView-method-bufferRender'>    // private
</span>    bufferRender: function(records, index) {
        var me = this,
            div = me.renderBuffer,
            result = document.createDocumentFragment(),
            nodes, len, i;

        me.tpl.overwrite(div, me.collectData(records, index));
        nodes = Ext.fly(div).query(me.getItemSelector());
        for (i = 0, len = nodes.length; i &lt; len; i++) {
            result.appendChild(nodes[i]);
        }
        result.childrenArray = nodes;
        return result;
    },

<span id='Ext-view-AbstractView-property-nodeContainerSelector'>    // Element which contains rows
</span>    nodeContainerSelector: null,

<span id='Ext-view-AbstractView-method-getNodeContainer'>    getNodeContainer: function() {
</span>        var target = this.getTargetEl(),
            selector = this.nodeContainerSelector;
        return selector ? target.down(selector, true) : target;
    },

<span id='Ext-view-AbstractView-method-getNodeContainerSelector'>    /**
</span>     * Returns a CSS selector which selects the element which contains record nodes.
     */
    getNodeContainerSelector: function() {
        return this.nodeContainerSelector;
    },

<span id='Ext-view-AbstractView-method-onUpdate'>    // private
</span>    onUpdate: function(store, record, operation, modifiedFieldNames, details) {
        var me = this,
            isFiltered = details &amp;&amp; details.filtered;

        // If, due to filtering or buffered rendering, or node collapse, the updated record is not
        // represented in the rendered structure, this is a no-op.
        // The correct, new values will be rendered the next time the record becomes visible and is rendered.
        if (!isFiltered &amp;&amp; me.getNode(record)) {

            // If we are throttling UI updates (See the updateDelay global config), ensure there&#39;s a change entry
            // queued for the record in the global queue.
            if (me.throttledUpdate) {
                me.statics().queueRecordChange(me, store, record, operation, modifiedFieldNames);
            } else {
                me.handleUpdate.apply(me, arguments);
            }
        }
    },

<span id='Ext-view-AbstractView-method-handleUpdate'>    // private
</span>    handleUpdate: function(store, record){
        var me = this,
            index,
            node,
            selModel = me.getSelectionModel();

        if (me.viewReady) {
            index = me.dataSource.indexOf(record);

            // If the record has been removed from the data source since the changes were made, do nothing
            if (index &gt; -1) {
                // ensure the node actually exists in the DOM
                if (me.getNode(record)) {
                    node = me.bufferRender([record], index).childrenArray[0];
                    me.all.replaceElement(index, node, true);
                    me.updateIndexes(index, index);
                    // Maintain selection after update
                    selModel.onUpdate(record);
                    me.refreshSizePending = true;
                    if (selModel.isSelected(record)) {
                        me.onItemSelect(record);
                    }
                    if (me.hasListeners.itemupdate) {
                        me.fireEvent(&#39;itemupdate&#39;, record, index, node);
                    }
                    return node;
                }
            }
        }
    },

<span id='Ext-view-AbstractView-method-onReplace'>    // Private.
</span>    // Respond to store replace event which is fired by GroupStore group expand/collapse operations.
    // This saves a layout because a remove and add operation are coalesced in this operation.
    onReplace: function(store, startIndex, oldRecords, newRecords) {
        var me = this,
            endIndex,
            rows = me.all,
            nodes, item,
            i, j,
            selModel = me.getSelectionModel();

        if (me.rendered) {

            // Insert the new rows before the remove block
            nodes = me.bufferRender(newRecords, startIndex, true);
            item = rows.item(startIndex);
            if (item) {
                rows.item(startIndex).insertSibling(nodes, &#39;before&#39;, true);
            } else {
                me.appendNodes(nodes); 
            }
            rows.insert(startIndex, nodes.childrenArray);

            startIndex += newRecords.length;
            endIndex = startIndex + oldRecords.length - 1;

            // Remove the items which correspond to old records
            rows.removeRange(startIndex, endIndex, true);

            // Some subclasses do not need to do this. TableView does not need to do this.
            if (me.refreshSelmodelOnRefresh !== false) {
                selModel.refresh();
            }

            // Update the row indices (TableView) doesn&#39;t do this.
            me.updateIndexes(startIndex);

            // Fire the itemremove event for each removed item
            if (me.hasListeners.itemremove) {
                for (i = oldRecords.length, j = endIndex; i &gt;= 0; --i, --j) {
                    me.fireEvent(&#39;itemremove&#39;, oldRecords[i], j, me);
                }
            }

            if (me.hasListeners.itemadd) {
                me.fireEvent(&#39;itemadd&#39;, newRecords, startIndex, nodes.childrenArray);
            }
            me.refreshSize();
        }
    },

<span id='Ext-view-AbstractView-method-onAdd'>    // private
</span>    onAdd: function(store, records, index) {
        var me = this,
            nodes,
            selModel = me.getSelectionModel();

        if (me.rendered) {
            // If we are adding into an empty view, we must refresh in order that the *full tpl* is applied
            // which might create boilerplate content *around* the record nodes.
            if (me.all.getCount() === 0) {
                me.refresh();
                nodes = me.all.slice();
            } else {
                nodes = me.doAdd(records, index);
                // Some subclasses do not need to do this. TableView does not need to do this.
                if (me.refreshSelmodelOnRefresh !== false) {
                    selModel.refresh();
                }
                me.updateIndexes(index);

                // Ensure layout system knows about new content size
                me.refreshSizePending = true;
            }

            if (me.hasListeners.itemadd) {
                me.fireEvent(&#39;itemadd&#39;, records, index, nodes);
            }
        }

    },
    
<span id='Ext-view-AbstractView-method-appendNodes'>    appendNodes: function(nodes) {
</span>        this.getNodeContainer().appendChild(nodes);
    },

<span id='Ext-view-AbstractView-method-doAdd'>    doAdd: function(records, index) {
</span>        var me = this,
            nodes = me.bufferRender(records, index, true),
            all = me.all,
            count = all.getCount(),
            firstRowIndex = all.startIndex || 0,
            lastRowIndex = all.endIndex || count - 1;

        // If we are empty, or add index after last node, then simply append
        if (count === 0 || index &gt; lastRowIndex) {
            me.appendNodes(nodes);
        }

        // Adding before the start index, prepend new nodes
        else if (index &lt;= firstRowIndex) {
            all.item(firstRowIndex).insertSibling(nodes, &#39;before&#39;, true);
        }

        // Insert the new nodes into place inside the existing nodes
        else {
            all.item(index).insertSibling(nodes, &#39;before&#39;, true);
        }

        all.insert(index, nodes.childrenArray);
        return nodes.childrenArray;
    },

<span id='Ext-view-AbstractView-method-onRemove'>    // private
</span>    onRemove: function(ds, records, index) {
        var me = this,
            rows = me.all,
            fireItemRemove = me.hasListeners.itemremove,
            currIdx, i, record, nodes, node;

        if (rows.getCount()) {
            if (me.dataSource.getCount() === 0) {
                // Refresh so emptyText can be applied if necessary
                if (fireItemRemove) {
                    me.fireEvent(&#39;itemremove&#39;, records, index, me.getNodes(index, index + records.length - 1));
                }
                me.preventPrune = true;
                me.refresh();
                me.preventPrune = false;
            } else {
                // Just remove the elements which corresponds to the removed records
                // The tpl&#39;s full HTML will still be in place.
                if (fireItemRemove) {
                    nodes = [];
                }
                for (i = records.length - 1; i &gt;= 0; --i) {
                    record = records[i];
                    currIdx = index + i;
                    if (nodes) {
                        node = rows.item(currIdx);
                        nodes[i] = node ? node.dom : undefined;
                    }
                    
                    if (rows.item(currIdx)) {
                        me.doRemove(record, currIdx);
                    }
                }

                if (fireItemRemove) {
                    me.fireEvent(&#39;itemremove&#39;, records, index, nodes, me);
                }
                me.updateIndexes(index);
            }

            // Ensure layout system knows about new content size
            me.refreshSizePending = true;
        }
    },

<span id='Ext-view-AbstractView-method-doRemove'>    // private
</span>    doRemove: function(record, index) {
        this.all.removeElement(index, true);
    },

<span id='Ext-view-AbstractView-method-refreshNode'>    /**
</span>     * Refreshes an individual node&#39;s data from the store.
     * @param {Ext.data.Model/Number} record The record or index of the record to update.
     * @since 2.3.0
     */
    refreshNode: function(record) {
        if (Ext.isNumber(record)) {
            record = this.store.getAt(record);
        }
        this.onUpdate(this.dataSource, record);
    },

<span id='Ext-view-AbstractView-method-updateIndexes'>    // private
</span>    updateIndexes: function(startIndex, endIndex) {
        var nodes = this.all.elements,
            node,
            records = this.getViewRange(),
            i,
            myId = this.id;

        startIndex = startIndex || 0;
        endIndex = endIndex || ((endIndex === 0) ? 0 : (nodes.length - 1));
        for (i = startIndex; i &lt;= endIndex; i++) {
            node = nodes[i];
            node.setAttribute(&#39;data-recordIndex&#39;, i);
            node.setAttribute(&#39;data-recordId&#39;, records[i].internalId);
            node.setAttribute(&#39;data-boundView&#39;, myId);
        }
    },

<span id='Ext-view-AbstractView-method-bindStore'>    /**
</span>     * Changes the data store bound to this view and refreshes it.
     * @param {Ext.data.Store} store The store to bind to this view
     * @since 3.4.0
     */
    bindStore: function(store, initial, propName) {
        var me = this,
            selModel = me.getSelectionModel();

        selModel.bindStore(store);
        selModel.bindComponent(store ? me : null);
        me.mixins.storeholder.bindStore.apply(me, arguments);

        // If we have already achieved our first layout, refresh immediately.
        // If we bind to the Store before the first layout, then beforeLayout will
        // call doFirstRefresh
        if (store &amp;&amp; me.componentLayoutCounter &amp;&amp; !me.preventRefresh) {
            // If not the initial bind, we enforce noDefer
            me.doFirstRefresh(store, !initial);
        }
    },

<span id='Ext-view-AbstractView-method-doFirstRefresh'>    /**
</span>     * @private
     * Perform the first refresh of the View from a newly bound store.
     *
     * This is called when this View has been sized for the first time.
     */
    doFirstRefresh: function(store, noDefer) {
        var me = this;

        // If we are configured to defer, and *NOT* called from the defer call below
        if (me.deferInitialRefresh &amp;&amp; !noDefer) {
            Ext.defer(me.doFirstRefresh, 1, me, [store, true]);
        }

        else {
            // 4.1.0: If we have a store, and the Store is *NOT* already loading (a refresh is on the way), then
            // on first layout, refresh regardless of record count.
            // Template may contain boilerplate HTML outside of record iteration loop.
            // Also, emptyText is appended by the refresh method.
            if (store &amp;&amp; !store.isLoading()) {
                me.refresh();
            }
        }
    },

<span id='Ext-view-AbstractView-method-onUnbindStore'>    onUnbindStore: function(store, initial, propertyName) {
</span>        if (propertyName === &#39;store&#39;) {
            this.setMaskBind(null);
            this.getSelectionModel().bindStore(null);
        }
    },

<span id='Ext-view-AbstractView-method-onBindStore'>    onBindStore: function(store, initial, propName) {
</span>        var me = this;

        me.setMaskBind(store);
        // After the oldStore (.store) has been unbound/bound,
        // do the same for the old data source (.dataSource).
        if (!initial &amp;&amp; propName === &#39;store&#39;) {
            // Block any refresh, since this means we&#39;re binding the store, which will kick off
            // a refresh.
            me.preventRefresh = true;
            // Ensure we have the this.store reference set correctly.
            me.store = store;
            me.bindStore(store, false, &#39;dataSource&#39;);
            me.preventRefresh = false;
        }
    },

<span id='Ext-view-AbstractView-method-setMaskBind'>    setMaskBind: function(store) {
</span>        var mask = this.loadMask;


        if (this.rendered &amp;&amp; mask &amp;&amp; store &amp;&amp; !mask.bindStore) {
            mask = this.createMask();
        }

        if (mask &amp;&amp; mask.bindStore) {
            mask.bindStore(store);
        }
    },

<span id='Ext-view-AbstractView-method-getStoreListeners'>    getStoreListeners: function() {
</span>        var me = this;
        return {
            refresh: me.onDataRefresh,
            replace: me.onReplace,
            add: me.onAdd,
            remove: me.onRemove,
            update: me.onUpdate,
            clear: me.refresh,
            beginupdate: me.onBeginUpdate,
            endupdate: me.onEndUpdate
        };
    },
    
<span id='Ext-view-AbstractView-method-onBeginUpdate'>    onBeginUpdate: function() {
</span>        Ext.suspendLayouts();
    },

<span id='Ext-view-AbstractView-method-onEndUpdate'>    onEndUpdate: function() {
</span>        Ext.resumeLayouts(true);
        if (this.refreshSizePending) {
            this.refreshSize(true);
            this.refreshSizePending = false;
        }
    },

<span id='Ext-view-AbstractView-method-onDataRefresh'>    /**
</span>     * @private
     * Calls this.refresh if this.blockRefresh is not true
     * @since 3.4.0
     */
    onDataRefresh: function() {
        this.refreshView();
    },

<span id='Ext-view-AbstractView-method-refreshView'>    refreshView: function() {
</span>        var me = this,
            // If we have an ancestor in a non-boxready state (collapsed or in-transition, or hidden), then block the
            // refresh because the next layout will trigger the refresh
            blocked = me.blockRefresh || !me.rendered || me.up(&#39;[collapsed],[isCollapsingOrExpanding],[hidden]&#39;);

        // If we are blocked in any way due to either a setting, or hidden or collapsed, or animating ancestor, then
        // the next refresh attempt at the upcoming layout must not defer.
        if (blocked) {
            me.refreshNeeded = true;
        } else {
            if (me.bufferedRenderer &amp;&amp; me.all.getCount()) {
                me.bufferedRenderer.refreshView();
            } else {
                me.refresh();
            }
        }
    },

<span id='Ext-view-AbstractView-method-findItemByChild'>    /**
</span>     * Returns the template node the passed child belongs to, or null if it doesn&#39;t belong to one.
     * @param {HTMLElement} node
     * @return {HTMLElement} The template node
     */
    findItemByChild: function(node){
        return Ext.fly(node).findParent(this.getItemSelector(), this.getTargetEl());
    },

<span id='Ext-view-AbstractView-method-findTargetByEvent'>    /**
</span>     * Returns the template node by the Ext.event.Event or null if it is not found.
     * @param {Ext.event.Event} e
     */
    findTargetByEvent: function(e) {
        return e.getTarget(this.getItemSelector(), this.getTargetEl());
    },


<span id='Ext-view-AbstractView-method-getSelectedNodes'>    /**
</span>     * Gets the currently selected nodes.
     * @return {HTMLElement[]} An array of HTMLElements
     * @since 2.3.0
     */
    getSelectedNodes: function(){
        var nodes   = [],
            records = this.getSelectionModel().getSelection(),
            ln = records.length,
            i  = 0;

        for (; i &lt; ln; i++) {
            nodes.push(this.getNode(records[i]));
        }

        return nodes;
    },

<span id='Ext-view-AbstractView-method-getRecords'>    /**
</span>     * Gets an array of the records from an array of nodes
     * @param {HTMLElement[]} nodes The nodes to evaluate
     * @return {Ext.data.Model[]} records The {@link Ext.data.Model} objects
     * @since 2.3.0
     */
    getRecords: function(nodes) {
        var records = [],
            i = 0,
            len = nodes.length,
            data = this.dataSource.data;

        for (; i &lt; len; i++) {
            records[records.length] = data.getByKey(nodes[i].getAttribute(&#39;data-recordId&#39;));
        }

        return records;
    },

<span id='Ext-view-AbstractView-method-getRecord'>    /**
</span>     * Gets a record from a node
     * @param {Ext.dom.Element/HTMLElement} node The node to evaluate
     *
     * @return {Ext.data.Model} record The {@link Ext.data.Model} object
     * @since 2.3.0
     */
    getRecord: function(node){
        return this.dataSource.getByInternalId(Ext.getDom(node).getAttribute(&#39;data-recordId&#39;));
    },


<span id='Ext-view-AbstractView-method-isSelected'>    /**
</span>     * Returns true if the passed node is selected, else false.
     * @param {HTMLElement/Number/Ext.data.Model} node The node, node index or record to check
     * @return {Boolean} True if selected, else false
     * @since 2.3.0
     */
    isSelected: function(node) {
        var r = this.getRecord(node);
        return this.getSelectionModel().isSelected(r);
    },

<span id='Ext-view-AbstractView-method-select'>    /**
</span>     * Selects a record instance by record instance or index.
     * @param {Ext.data.Model[]/Number} records An array of records or an index
     * @param {Boolean} keepExisting
     * @param {Boolean} suppressEvent Set to false to not fire a select event
     * @deprecated 4.0 Use {@link Ext.selection.Model#select} instead.
     * @since 2.3.0
     */
    select: function(records, keepExisting, suppressEvent) {
        this.getSelectionModel().select(records, keepExisting, suppressEvent);
    },

<span id='Ext-view-AbstractView-method-deselect'>    /**
</span>     * Deselects a record instance by record instance or index.
     * @param {Ext.data.Model[]/Number} records An array of records or an index
     * @param {Boolean} suppressEvent Set to false to not fire a deselect event
     * @since 2.3.0
     */
    deselect: function(records, suppressEvent) {
        this.getSelectionModel().deselect(records, suppressEvent);
    },

<span id='Ext-view-AbstractView-method-getNode'>    /**
</span>     * Gets a template node.
     * @param {HTMLElement/String/Number/Ext.data.Model} nodeInfo An HTMLElement template node, index of a template node,
     * the id of a template node or the record associated with the node.
     * @return {HTMLElement} The node or null if it wasn&#39;t found
     * @since 2.3.0
     */
    getNode: function(nodeInfo) {
        var me = this,
            out;

        if (me.rendered &amp;&amp; (nodeInfo || nodeInfo === 0)) {
            if (Ext.isString(nodeInfo)) {
                // Id
                out = document.getElementById(nodeInfo);
            } else if (nodeInfo.isModel) {
                // Record
                out = me.getNodeByRecord(nodeInfo);
            } else if (Ext.isNumber(nodeInfo)) {
                // Index
                out = me.all.elements[nodeInfo];
            } else {
                if (nodeInfo.target) {
                    // An event
                    nodeInfo = nodeInfo.target;
                }
                out = Ext.fly(nodeInfo).findParent(me.itemSelector, me.getTargetEl()); // already an HTMLElement
            }
        }
        return out || null;
    },

<span id='Ext-view-AbstractView-method-getNodeByRecord'>    /**
</span>     * @private
     */
    getNodeByRecord: function(record) {
        var index = this.store.indexOf(record);
        return this.all.elements[index] || null;
    },

<span id='Ext-view-AbstractView-method-getNodes'>    /**
</span>     * Gets a range nodes.
     * @param {Number} start (optional) The index of the first node in the range
     * @param {Number} end (optional) The index of the last node in the range
     * @return {HTMLElement[]} An array of nodes
     * @since 2.3.0
     */
    getNodes: function(start, end) {
        var all = this.all;

        if (end !== undefined) {
            end++;
        }
        return all.slice(start, end);
    },

<span id='Ext-view-AbstractView-method-indexOf'>    /**
</span>     * Finds the index of the passed node.
     * @param {HTMLElement/String/Number/Ext.data.Model} nodeInfo An HTMLElement template node, index of a template node, the id of a template node
     * or a record associated with a node.
     * @return {Number} The index of the node or -1
     * @since 2.3.0
     */
    indexOf: function(node) {
        node = this.getNode(node);
        if (!node &amp;&amp; node !== 0) {
            return -1;
        }
        if (node.getAttribute(&#39;data-recordIndex&#39;)) {
            return Number(node.getAttribute(&#39;data-recordIndex&#39;));
        }
        return this.all.indexOf(node);
    },

<span id='Ext-view-AbstractView-method-onDestroy'>    onDestroy: function() {
</span>        var me = this;

        me.all.clear();
        me.emptyEl = null;
        me.callParent();
        me.bindStore(null);
        Ext.destroy(me.navigationModel, me.selectionModel);
    },

<span id='Ext-view-AbstractView-method-onItemSelect'>    // invoked by the selection model to maintain visual UI cues
</span>    onItemSelect: function(record) {
        var node = this.getNode(record);

        if (node) {
            Ext.fly(node).addCls(this.selectedItemCls);
        }
    },

<span id='Ext-view-AbstractView-method-onItemDeselect'>    // invoked by the selection model to maintain visual UI cues
</span>    onItemDeselect: function(record) {
        var node = this.getNode(record);

        if (node) {
            Ext.fly(node).removeCls(this.selectedItemCls);
        }
    },

<span id='Ext-view-AbstractView-method-getItemSelector'>    getItemSelector: function() {
</span>        return this.itemSelector;
    },

<span id='Ext-view-AbstractView-method-addItemCls'>    /**
</span>     * Adds a CSS Class to a specific item.
     * @param {HTMLElement/String/Number/Ext.data.Model} itemInfo An HTMLElement, index or instance of a model
     * representing this item
     * @param {String} cls
     */
    addItemCls: function(itemInfo, cls) {
        var item = this.getNode(itemInfo);
        if (item) {
            Ext.fly(item).addCls(cls);
        }
    },

<span id='Ext-view-AbstractView-method-removeItemCls'>    /**
</span>     * Removes a CSS Class from a specific item.
     * @param {HTMLElement/String/Number/Ext.data.Model} itemInfo An HTMLElement, index or instance of a model
     * representing this item
     * @param {String} cls
     */
    removeItemCls: function(itemInfo, cls) {
        var item = this.getNode(itemInfo);
        if (item) {
            Ext.fly(item).removeCls(cls);
        }
    },

<span id='Ext-view-AbstractView-method-updateStore'>    updateStore: function(store) {
</span>        if (!this.isConfiguring) {
            // bindStore has various checks to see if the current store is the same, so
            // delete the property from our instance, it will be assigned during bindStore
            delete this.store;
            this.bindStore(store);
        }
    },

<span id='Ext-view-AbstractView-property-privates'>    privates: {
</span>        createMask: function(mask) {
            var me = this,
                maskStore = me.getMaskStore(),
                cfg;

            if (maskStore &amp;&amp; !maskStore.isEmptyStore &amp;&amp; !maskStore.loadsSynchronously()) {
                cfg = {
                    target: me,
                    msg: me.loadingText,
                    useMsg: me.loadingUseMsg,
                    // The store gets bound in initComponent, so while
                    // rendering let&#39;s push on the store
                    store: maskStore
                };
                // Do not overwrite default msgCls if we do not have a loadingCls
                if (me.loadingCls) {
                    cfg.msgCls = me.loadingCls;
                }
                // either a config object 
                if (Ext.isObject(mask)) {
                    cfg = Ext.apply(cfg, mask);
                }
                // Attach the LoadMask to a *Component* so that it can be sensitive to resizing during long loads.
                // If this DataView is floating, then mask this DataView.
                // Otherwise, mask its owning Container (or this, if there *is* no owning Container).
                // LoadMask captures the element upon render.
                me.loadMask = new Ext.LoadMask(cfg);
                me.loadMask.on({
                    scope: me,
                    beforeshow: me.onMaskBeforeShow,
                    hide: me.onMaskHide
                });
            }
            return me.loadMask;
        },

        getFocusEl: function() {
            return this.el;
        },
        getOverflowEl: function() {
            // The desired behavior here is just to inherit from the superclass.  However,
            // the superclass method calls this.getTargetEl, which sends us into an infinte
            // loop because our getTargetEl may call getScrollerEl(), which calls getOverflowEl()
            return Ext.Component.prototype.getTargetEl.call(this);
        },

        getTargetEl: function() {
            return this.touchScroll ? this.getScrollerEl() : this.callParent();
        }
    }
}, function() {
    // all of this information is available directly
    // from the SelectionModel itself, the only added methods
    // to DataView regarding selection will perform some transformation/lookup
    // between HTMLElement/Nodes to records and vice versa.
    Ext.deprecate(&#39;extjs&#39;, &#39;4.0&#39;, function() {
        Ext.view.AbstractView.override({
<span id='Ext-view-AbstractView-cfg-multiSelect'>            /**
</span>             * @cfg {Boolean} [multiSelect=false]
             * True to allow selection of more than one item at a time, false to allow selection of only a single item
             * at a time or no selection at all, depending on the value of {@link #singleSelect}.
             * @deprecated 4.0 Use {@link Ext.selection.Model#mode} &#39;MULTI&#39; instead.
             * @since 2.3.0
             */
<span id='Ext-view-AbstractView-cfg-singleSelect'>            /**
</span>             * @cfg {Boolean} [singleSelect]
             * Allows selection of exactly one item at a time. As this is the default selection mode anyway, this config
             * is completely ignored.
             * @removed 4.0 Use {@link Ext.selection.Model#mode} &#39;SINGLE&#39; instead.
             * @since 2.3.0
             */
<span id='Ext-view-AbstractView-cfg-simpleSelect'>            /**
</span>             * @cfg {Boolean} [simpleSelect=false]
             * True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl,
             * false to force the user to hold Ctrl or Shift to select more than on item.
             * @deprecated 4.0 Use {@link Ext.selection.Model#mode} &#39;SIMPLE&#39; instead.
             * @since 2.3.0
             */

<span id='Ext-view-AbstractView-method-getSelectionCount'>            /**
</span>             * Gets the number of selected nodes.
             * @return {Number} The node count
             * @deprecated 4.0 Use {@link Ext.selection.Model#getCount} instead.
             * @since 2.3.0
             */
            getSelectionCount: function(){
                if (Ext.global.console) {
                    Ext.global.console.warn(&quot;DataView: getSelectionCount will be removed, please interact with the Ext.selection.DataViewModel&quot;);
                }
                return this.selModel.getSelection().length;
            },

<span id='Ext-view-AbstractView-method-getSelectedRecords'>            /**
</span>             * Gets an array of the selected records
             * @return {Ext.data.Model[]} An array of {@link Ext.data.Model} objects
             * @deprecated 4.0 Use {@link Ext.selection.Model#getSelection} instead.
             * @since 2.3.0
             */
            getSelectedRecords: function(){
                if (Ext.global.console) {
                    Ext.global.console.warn(&quot;DataView: getSelectedRecords will be removed, please interact with the Ext.selection.DataViewModel&quot;);
                }
                return this.selModel.getSelection();
            },

            // documented above
            // @ignore
            select: function(records, keepExisting, supressEvents) {
                if (Ext.global.console) {
                    Ext.global.console.warn(&quot;DataView: select will be removed, please access select through a DataView&#39;s SelectionModel, ie: view.getSelectionModel().select()&quot;);
                }
                var sm = this.getSelectionModel();
                return sm.select.apply(sm, arguments);
            },

<span id='Ext-view-AbstractView-method-clearSelections'>            /**
</span>             * Deselects all selected records.
             * @deprecated 4.0 Use {@link Ext.selection.Model#deselectAll} instead.
             * @since 2.3.0
             */
            clearSelections: function() {
                if (Ext.global.console) {
                    Ext.global.console.warn(&quot;DataView: clearSelections will be removed, please access deselectAll through DataView&#39;s SelectionModel, ie: view.getSelectionModel().deselectAll()&quot;);
                }
                var sm = this.getSelectionModel();
                return sm.deselectAll();
            }
        });
    });
});
</pre>
</body>
</html>
