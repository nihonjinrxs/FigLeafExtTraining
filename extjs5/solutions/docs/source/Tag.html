<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-form-field-Tag'>/**
</span> * The `tagfield` is a combo box improved for multiple value editing, selection and easy
 * management.
 *
 * ### History
 *
 * Inspired by the [SuperBoxSelect component for ExtJS 3](http://technomedia.co.uk/SuperBoxSelect/examples3.html),
 * which in turn was inspired by the [BoxSelect component for ExtJS 2](http://efattal.fr/en/extjs/extuxboxselect/).
 *
 * Various contributions and suggestions made by many members of the ExtJS community which can be seen
 * in the [user extension forum post](http://www.sencha.com/forum/showthread.php?134751-Ext.ux.form.field.BoxSelect).
 *
 * By: kvee_iv http://www.sencha.com/forum/member.php?29437-kveeiv
 */
Ext.define(&#39;Ext.form.field.Tag&#39;, {
    extend:&#39;Ext.form.field.ComboBox&#39;,
    requires: [
        &#39;Ext.selection.Model&#39;,
        &#39;Ext.data.Store&#39;,
        &#39;Ext.data.ChainedStore&#39;
    ],

    xtype: &#39;tagfield&#39;,
<span id='Ext-form-field-Tag-cfg-valueParam'>    /**
</span>     * @cfg {String} valueParam
     * The name of the parameter used to load unknown records into the store. If left unspecified, {@link #valueField}
     * will be used.
     */

<span id='Ext-form-field-Tag-cfg-multiSelect'>    /**
</span>     * @cfg {Boolean} multiSelect
     * If set to `true`, allows the combo field to hold more than one value at a time, and allows selecting multiple
     * items from the dropdown list. The combo&#39;s text field will show all selected values using the template
     * defined by {@link #labelTpl}.
     *
     */
    multiSelect: true,

<span id='Ext-form-field-Tag-cfg-delimiter'>    /**
</span>     * @cfg {String} delimiter
     * The character(s) used to separate new values to be added when {@link #createNewOnEnter}
     * or {@link #createNewOnBlur} are set.
     * `{@link #multiSelect} = true`.
     */
    delimiter: &#39;,&#39;,

<span id='Ext-form-field-Tag-cfg-labelTpl'>    /**
</span>     * @cfg {String/Ext.XTemplate} labelTpl
     * The {@link Ext.XTemplate XTemplate} to use for the inner
     * markup of the labelled items. Defaults to the configured {@link #displayField}
     */

<span id='Ext-form-field-Tag-cfg-forceSelection'>    /**
</span>     * @cfg
     * @inheritdoc
     *
     * When {@link #forceSelection} is `false`, new records can be created by the user as they
     * are typed. These records are **not** added to the combo&#39;s store. Multiple new values
     * may be added by separating them with the {@link #delimiter}, and can be further configured using the
     * {@link #createNewOnEnter} and {@link #createNewOnBlur} configuration options.
     *
     * This functionality is primarily useful for things such as an email address.
     */
    forceSelection: true,

<span id='Ext-form-field-Tag-cfg-createNewOnEnter'>    /**
</span>     * @cfg {Boolean} createNewOnEnter
     * Has no effect if {@link #forceSelection} is `true`.
     *
     * With this set to `true`, the creation described in
     * {@link #forceSelection} will also be triggered by the &#39;enter&#39; key.
     */
    createNewOnEnter: false,

<span id='Ext-form-field-Tag-cfg-createNewOnBlur'>    /**
</span>     * @cfg {Boolean} createNewOnBlur
     * Has no effect if {@link #forceSelection} is `true`.
     *
     * With this set to `true`, the creation described in
     * {@link #forceSelection} will also be triggered when the field loses focus.
     *
     * Please note that this behavior is also affected by the configuration options
     * {@link #autoSelect} and {@link #selectOnTab}. If those are true and an existing
     * item would have been selected as a result, the partial text the user has entered will
     * be discarded and the existing item will be added to the selection.
     */
    createNewOnBlur: false,

<span id='Ext-form-field-Tag-cfg-encodeSubmitValue'>    /**
</span>     * @cfg {Boolean} encodeSubmitValue
     * Has no effect if {@link #multiSelect} is `false`.
     *
     * Controls the formatting of the form submit value of the field as returned by {@link #getSubmitValue}
     *
     * - `true` for the field value to submit as a json encoded array in a single GET/POST variable
     * - `false` for the field to submit as an array of GET/POST variables
     */
    encodeSubmitValue: false,

<span id='Ext-form-field-Tag-cfg-triggerOnClick'>    /**
</span>     * @cfg {Boolean} triggerOnClick
     * `true` to activate the trigger when clicking in empty space in the field. Note that the
     * subsequent behavior of this is controlled by the field&#39;s {@link #triggerAction}.
     * This behavior is similar to that of a basic ComboBox with {@link #editable} `false`.
     */
    triggerOnClick: true,

<span id='Ext-form-field-Tag-cfg-stacked'>    /**
</span>     * @cfg {Boolean} stacked
     * - `true` to have each selected value fill to the width of the form field
     * - `false to have each selected value size to its displayed contents
     */
    stacked: false,

<span id='Ext-form-field-Tag-cfg-filterPickList'>    /**
</span>     * @cfg {Boolean} filterPickList
     * True to hide the currently selected values from the drop down list.
     *
     * - `true` to hide currently selected values from the drop down pick list
     * - `false` to keep the item in the pick list as a selected item
     */
    filterPickList: false,

<span id='Ext-form-field-Tag-cfg-grow'>    /**
</span>     * @cfg {Boolean}
     *
     * `true` if this field should automatically grow and shrink vertically to its content.
     * Note that this overrides the natural trigger grow functionality, which is used to size
     * the field horizontally.
     */
    grow: true,

<span id='Ext-form-field-Tag-cfg-growMin'>    /**
</span>     * @cfg {Number/Boolean}
     * Has no effect if {@link #grow} is `false`
     *
     * The minimum height to allow when {@link #grow} is `true`, or `false` to allow for
     * natural vertical growth based on the current selected values. See also {@link #growMax}.
     */
    growMin: false,

<span id='Ext-form-field-Tag-cfg-growMax'>    /**
</span>     * @cfg {Number/Boolean}
     * Has no effect if {@link #grow} is `false`
     *
     * The maximum height to allow when {@link #grow} is `true`, or `false` to allow for
     * natural vertical growth based on the current selected values. See also {@link #growMin}.
     */
    growMax: false,

<span id='Ext-form-field-Tag-cfg-selectOnFocus'>    /**
</span>     * @cfg
     * @inheritdoc
     */
    selectOnFocus: true,

<span id='Ext-form-field-Tag-cfg-growAppend'>    /**
</span>     * @cfg growAppend
     * @hide
     * Currently unsupported since this is used for horizontal growth and this component
     * only supports vertical growth.
     */

<span id='Ext-form-field-Tag-cfg-growToLongestValue'>    /**
</span>     * @cfg growToLongestValue
     * @hide
     * Currently unsupported since this is used for horizontal growth and this component
     * only supports vertical growth.
     */

<span id='Ext-form-field-Tag-event-autosize'>    /**
</span>     * @event autosize
     * Fires when the **{@link #autoSize}** function is triggered and the field is resized according to the
     * {@link #grow}/{@link #growMin}/{@link #growMax} configs as a result. This event provides a hook for the
     * developer to apply additional logic at runtime to resize the field if needed.
     * @param {Ext.form.field.Tag} this This field
     * @param {Number} height The new field height
     */

<span id='Ext-form-field-Tag-property-fieldSubTpl'>    /**
</span>     * @private
     */
    fieldSubTpl: [
        &#39;&lt;div id=&quot;{cmpId}-listWrapper&quot; data-ref=&quot;listWrapper&quot; class=&quot;&#39; + Ext.baseCSSPrefix + &#39;tagfield {fieldCls} {typeCls} {typeCls}-{ui} style=&quot;{wrapperStyle}&quot;&gt;&#39;,
            &#39;&lt;ul id=&quot;{cmpId}-itemList&quot; data-ref=&quot;itemList&quot; class=&quot;&#39; + Ext.baseCSSPrefix + &#39;tagfield-list{itemListCls}&quot;&gt;&#39;,
                &#39;&lt;li id=&quot;{cmpId}-inputElCt&quot; data-ref=&quot;inputElCt&quot; class=&quot;&#39; + Ext.baseCSSPrefix + &#39;tagfield-input&quot;&gt;&#39;,
                    &#39;&lt;div id=&quot;{cmpId}-emptyEl&quot; data-ref=&quot;emptyEl&quot; class=&quot;{emptyCls}&quot;&gt;{emptyText}&lt;/div&gt;&#39;,
                    &#39;&lt;input id=&quot;{cmpId}-inputEl&quot; data-ref=&quot;inputEl&quot; type=&quot;{type}&quot; &#39;,
                    &#39;&lt;tpl if=&quot;name&quot;&gt;name=&quot;{name}&quot; &lt;/tpl&gt;&#39;,
                    &#39;&lt;tpl if=&quot;value&quot;&gt; value=&quot;{[Ext.util.Format.htmlEncode(values.value)]}&quot;&lt;/tpl&gt;&#39;,
                    &#39;&lt;tpl if=&quot;size&quot;&gt;size=&quot;{size}&quot; &lt;/tpl&gt;&#39;,
                    &#39;&lt;tpl if=&quot;tabIdx != null&quot;&gt;tabindex=&quot;{tabIdx}&quot; &lt;/tpl&gt;&#39;,
                    &#39;&lt;tpl if=&quot;disabled&quot;&gt; disabled=&quot;disabled&quot;&lt;/tpl&gt;&#39;,
                    &#39;class=&quot;&#39; + Ext.baseCSSPrefix + &#39;tagfield-input-field {inputElCls}&quot; autocomplete=&quot;off&quot;&gt;&#39;,
                &#39;&lt;/li&gt;&#39;,
            &#39;&lt;/ul&gt;&#39;,
        &#39;&lt;/div&gt;&#39;,
        {
            disableFormats: true
        }
    ],

<span id='Ext-form-field-Tag-property-extraFieldBodyCls'>    extraFieldBodyCls: Ext.baseCSSPrefix + &#39;tagfield-body&#39;,
</span>
<span id='Ext-form-field-Tag-property-childEls'>    /**
</span>     * @private
     */
    childEls: [ &#39;listWrapper&#39;, &#39;itemList&#39;, &#39;inputEl&#39;, &#39;inputElCt&#39;, &#39;emptyEl&#39; ],

<span id='Ext-form-field-Tag-property-emptyInputCls'>    /**
</span>     * @private
     */
    emptyInputCls: Ext.baseCSSPrefix + &#39;tagfield-emptyinput&#39;,

<span id='Ext-form-field-Tag-property-tagItemSelector'>    tagItemSelector: &#39;.&#39; + Ext.baseCSSPrefix + &#39;tagfield-item&#39;,
</span><span id='Ext-form-field-Tag-property-tagItemCloseSelector'>    tagItemCloseSelector: &#39;.&#39; + Ext.baseCSSPrefix + &#39;tagfield-item-close&#39;,
</span><span id='Ext-form-field-Tag-property-tagSelectedCls'>    tagSelectedCls: Ext.baseCSSPrefix + &#39;tagfield-item-selected&#39;,
</span>
<span id='Ext-form-field-Tag-method-initComponent'>    initComponent: function() {
</span>        var me = this,
            typeAhead = me.typeAhead,
            delimiter = me.delimiter;

        // &lt;debug&gt;
        if (typeAhead &amp;&amp; !me.editable) {
            Ext.Error.raise(&#39;If typeAhead is enabled the combo must be editable: true -- please change one of those settings.&#39;);
        }
        // &lt;/debug&gt;

        // Allow unmatched textual values to be converted into new value records.
        if (me.createNewOnEnter || me.createNewOnBlur) {
            me.forceSelection = false;
        }

        me.typeAhead = false;

        // This is the selection model for selecting tags in the tag list. NOT the dropdown BoundList.
        // Create the selModel before calling parent, we need it to be available
        // when we bind the store.
        me.selectionModel = new Ext.selection.Model({
            mode: &#39;MULTI&#39;,
            onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
                commitFn();
            },
            // Relay these selection events passing the field instead of exposing the underlying selection model
            listeners: {
                scope: me,
                selectionchange: me.onSelectionChange,
                focuschange: me.onFocusChange
            }
        });

        me.callParent();

        me.typeAhead = typeAhead;

        if (delimiter &amp;&amp; me.multiSelect) {
            me.delimiterRegexp = new RegExp(Ext.String.escapeRegex(delimiter));
        }
    },

<span id='Ext-form-field-Tag-method-initEvents'>    initEvents: function() {
</span>        var me = this,
            inputEl = me.inputEl;

        me.callParent(arguments);

        if (!me.enableKeyEvents) {
            inputEl.on(&#39;keydown&#39;, me.onKeyDown, me);
            inputEl.on(&#39;keyup&#39;,   me.onKeyUp, me);
        }
        me.listWrapper.on(&#39;click&#39;, me.onItemListClick, me);
    },
    
<span id='Ext-form-field-Tag-method-isValid'>    isValid: function() {
</span>        var me = this,
            disabled = me.disabled,
            validate = me.forceValidation || !disabled;

        return validate ? me.validateValue(me.getValue()) : disabled;
    },

<span id='Ext-form-field-Tag-method-onBindStore'>    onBindStore: function(store) {
</span>        var me = this;

        me.callParent([store]);
        if (store) {
            // We collect picked records in a value store so that a selection model can track selection
            me.valueStore = new Ext.data.Store({
                model: store.getModel()
            });
            me.selectionModel.bindStore(me.valueStore);

            // Picked records disappear from the BoundList
            if (me.filterPickList) {
                me.listFilter = new Ext.util.Filter({
                    scope: me,
                    filterFn: me.filterPicked
                });
                me.changingFilters = true;
                store.filter(me.listFilter);
                me.changingFilters = false;
            }
        }
    },

<span id='Ext-form-field-Tag-method-filterPicked'>    filterPicked: function(rec) {
</span>        return !this.valueCollection.contains(rec);
    },

<span id='Ext-form-field-Tag-method-onUnbindStore'>    onUnbindStore: function(store) {
</span>        var me = this,
            valueStore = me.valueStore,
            picker = me.picker;

        if (picker) {
            picker.bindStore(null);
        }

        if (valueStore) {
            valueStore.destroy();
            me.valueStore = null;
        }

        if (me.filterPickList) {
            me.changingFilters = true;
            store.removeFilter(me.listFilter);
            me.changingFilters = false;
        }
        me.callParent(arguments);
    },

<span id='Ext-form-field-Tag-method-onValueCollectionEndUpdate'>    onValueCollectionEndUpdate: function() {
</span>        var me = this,
            pickedRecords = me.valueCollection.items,
            valueStore = me.valueStore;

        if (me.isSelectionUpdating()) {
            return;
        }

        // Ensure the source store is filtered down
        if (me.filterPickList) {
            me.changingFilters = true;
            me.store.filter(me.listFilter);
            me.changingFilters = false;
        }
        me.callParent();

        Ext.suspendLayouts();
        if (valueStore) {
            valueStore.suspendEvents();
            valueStore.loadRecords(pickedRecords);
            valueStore.resumeEvents();
        }
        Ext.resumeLayouts(true);
    },

<span id='Ext-form-field-Tag-method-checkValueOnDataChange'>    checkValueOnDataChange: Ext.emptyFn,
</span>
<span id='Ext-form-field-Tag-method-onSelectionChange'>    onSelectionChange: function(selModel, selectedRecs) {
</span>        this.applyMultiselectItemMarkup();
        this.fireEvent(&#39;valueselectionchange&#39;, this, selectedRecs);
    },

<span id='Ext-form-field-Tag-method-onFocusChange'>    onFocusChange: function(selectionModel, oldFocused, newFocused) {
</span>        this.fireEvent(&#39;valuefocuschange&#39;, this, oldFocused, newFocused);
    },

<span id='Ext-form-field-Tag-method-onDestroy'>    onDestroy: function() {
</span>        this.selectionModel = Ext.destroy(this.selectionModel);

        // This will unbind the store, which will destroy the valueStore
        this.callParent(arguments);
    },

<span id='Ext-form-field-Tag-method-getSubTplData'>    getSubTplData: function(fieldData) {
</span>        var me = this,
            data = me.callParent(arguments),
            emptyText = me.emptyText,
            emptyInputCls = me.emptyInputCls,
            isEmpty = emptyText &amp;&amp; data.value.length &lt; 1,
            growMin = me.growMin,
            growMax = me.growMax;

        data.value = &#39;&#39;;
        data.emptyText = isEmpty ? emptyText : &#39;&#39;;
        data.emptyCls = isEmpty ? me.emptyCls : emptyInputCls;
        data.inputElCls = isEmpty ? emptyInputCls : &#39;&#39;;
        data.wrapperStyle = &#39;&#39;;
        data.itemListCls = &#39;&#39;;

        if (me.grow) {
            if (Ext.isNumber(growMin) &amp;&amp; growMin &gt; 0) {
                wrapperStyle += &#39;min-height:&#39; + growMin + &#39;px;&#39;;
            }
            if (Ext.isNumber(growMax) &amp;&amp; growMax &gt; 0) {
                wrapperStyle += &#39;max-height:&#39; + growMax + &#39;px;&#39;;
            }
        }

        if (me.stacked === true) {
            data.itemListCls += &#39; &#39; + Ext.baseCSSPrefix + &#39;tagfield-stacked&#39;;
        }

        if (!me.multiSelect) {
            data.itemListCls += &#39; &#39; + Ext.baseCSSPrefix + &#39;tagfield-singleselect&#39;;
        }

        return data;
    },

<span id='Ext-form-field-Tag-method-afterRender'>    afterRender: function() {
</span>        var me = this,
            inputEl = me.inputEl;

        if (Ext.supports.Placeholder &amp;&amp; inputEl &amp;&amp; me.emptyText) {
            inputEl.dom.removeAttribute(&#39;placeholder&#39;);
        }

        me.applyMultiselectItemMarkup();

        me.callParent(arguments);
    },

<span id='Ext-form-field-Tag-method-findRecord'>    findRecord: function(field, value) {
</span>        var matches = this.getStore().queryRecords(field, value);
        return matches.length ? matches[0] : false;
    },

<span id='Ext-form-field-Tag-method-getCursorPosition'>    /**
</span>     * Get the current cursor position in the input field, for key-based navigation
     * @private
     */
    getCursorPosition: function() {
        var cursorPos;

        if (document.selection) {
            cursorPos = document.selection.createRange();
            cursorPos.collapse(true);
            cursorPos.moveStart(&#39;character&#39;, -this.inputEl.dom.value.length);
            cursorPos = cursorPos.text.length;
        } else {
            cursorPos = this.inputEl.dom.selectionStart;
        }
        return cursorPos;
    },

<span id='Ext-form-field-Tag-method-hasSelectedText'>    /**
</span>     * Check to see if the input field has selected text, for key-based navigation
     * @private
     */
    hasSelectedText: function() {
        var inputEl = this.inputEl.dom,
            sel, range;

        if (document.selection) {
            sel = document.selection;
            range = sel.createRange();
            return (range.parentElement() === inputEl);
        } else {
            return inputEl.selectionStart !== inputEl.selectionEnd;
        }
    },

<span id='Ext-form-field-Tag-method-onKeyDown'>    /**
</span>     * Handles keyDown processing of key-based selection of labelled items.
     * Supported keyboard controls:
     *
     * - If pick list is expanded
     *
     *     - `CTRL-A` will select all the items in the pick list
     *
     * - If the cursor is at the beginning of the input field and there are values present
     *
     *     - `CTRL-A` will highlight all the currently selected values
     *     - `BACKSPACE` and `DELETE` will remove any currently highlighted selected values
     *     - `RIGHT` and `LEFT` will move the current highlight in the appropriate direction
     *     - `SHIFT-RIGHT` and `SHIFT-LEFT` will add to the current highlight in the appropriate direction
     *
     * @protected
     */
    onKeyDown: function(e) {
        var me = this,
            key = e.getKey(),
            inputEl = me.inputEl,
            rawValue = inputEl.dom.value,
            valueCollection = me.valueCollection,
            selModel = me.selectionModel,
            stopEvent = false,
            lastSelectionIndex;

        if (me.readOnly || me.disabled || !me.editable) {
            return;
        }

        if (valueCollection.getCount() &gt; 0 &amp;&amp; (rawValue === &#39;&#39; || (me.getCursorPosition() === 0 &amp;&amp; !me.hasSelectedText()))) {
            // Keyboard navigation of current values
            lastSelectionIndex = (selModel.getCount() &gt; 0) ? valueCollection.indexOf(selModel.getLastSelected()) : -1;

            if (key === e.BACKSPACE || key === e.DELETE) {
                // Delete token
                if (lastSelectionIndex &gt; -1) {
                    if (selModel.getCount() &gt; 1) {
                        lastSelectionIndex = -1;
                    }
                    valueCollection.remove(selModel.getSelection());
                } else {
                    valueCollection.remove(valueCollection.last());
                }
                selModel.clearSelections();
                if (lastSelectionIndex &gt; 0) {
                    selModel.select(lastSelectionIndex - 1);
                } else if (valueCollection.getCount()) {
                    selModel.select(valueCollection.last());
                }
                stopEvent = true;
            } else if (key === e.RIGHT || key === e.LEFT) {
                // Navigate and select tokens
                if (lastSelectionIndex === -1 &amp;&amp; key === e.LEFT) {
                    selModel.select(valueCollection.last());
                    stopEvent = true;
                } else if (lastSelectionIndex &gt; -1) {
                    if (key === e.RIGHT) {
                        if (lastSelectionIndex &lt; (valueCollection.getCount() - 1)) {
                            selModel.select(lastSelectionIndex + 1, e.shiftKey);
                            stopEvent = true;
                        } else if (!e.shiftKey) {
                            selModel.deselectAll();
                            stopEvent = true;
                        }
                    } else if (key === e.LEFT &amp;&amp; (lastSelectionIndex &gt; 0)) {
                        selModel.select(lastSelectionIndex - 1, e.shiftKey);
                        stopEvent = true;
                    }
                }
            } else if (key === e.A &amp;&amp; e.ctrlKey) {
                // Select all tokens
                selModel.selectAll();
                stopEvent = e.A;
            }
        }

        if (stopEvent) {
            me.preventKeyUpEvent = stopEvent;
            e.stopEvent();
            return;
        }

        // Prevent key up processing for enter if it is being handled by the picker
        if (me.isExpanded &amp;&amp; key === e.ENTER &amp;&amp; me.picker.highlightedItem) {
            me.preventKeyUpEvent = true;
        }

        if (me.enableKeyEvents) {
            me.callParent(arguments);
        }

        if (!e.isSpecialKey() &amp;&amp; !e.hasModifier()) {
            selModel.deselectAll();
        }
    },

<span id='Ext-form-field-Tag-method-onKeyUp'>    /**
</span>     * Handles auto-selection and creation of labelled items based on this field&#39;s
     * delimiter, as well as the keyUp processing of key-based selection of labelled items.
     * @protected
     */
    onKeyUp: function(e, t) {
        var me = this,
            inputEl = me.inputEl,
            rawValue = inputEl.dom.value,
            preventKeyUpEvent = me.preventKeyUpEvent;

        if (me.preventKeyUpEvent) {
            e.stopEvent();
            if (preventKeyUpEvent === true || e.getKey() === preventKeyUpEvent) {
                delete me.preventKeyUpEvent;
            }
            return;
        }

        if (me.multiSelect &amp;&amp; me.delimiterRegexp &amp;&amp; me.delimiterRegexp.test(rawValue) ||
                (me.createNewOnEnter &amp;&amp; e.getKey() === e.ENTER)) {
            rawValue = Ext.Array.clean(rawValue.split(me.delimiterRegexp));
            inputEl.dom.value = &#39;&#39;;
            me.setValue(me.valueStore.getRange().concat(rawValue));
            inputEl.focus();
        }

        me.callParent([e,t]);
    },

<span id='Ext-form-field-Tag-method-onTypeAhead'>    /**
</span>     * Overridden to get and set the DOM value directly for type-ahead suggestion (bypassing get/setRawValue)
     * @protected
     */
    onTypeAhead: function() {
        var me = this,
            displayField = me.displayField,
            inputElDom = me.inputEl.dom,
            boundList = me.getPicker(),
            record = me.getStore().findRecord(displayField, inputElDom.value),
            newValue, len, selStart;

        if (record) {
            newValue = record.get(displayField);
            len = newValue.length;
            selStart = inputElDom.value.length;
            boundList.highlightItem(boundList.getNode(record));
            if (selStart !== 0 &amp;&amp; selStart !== len) {
                inputElDom.value = newValue;
                me.selectText(selStart, newValue.length);
            }
        }
    },

<span id='Ext-form-field-Tag-method-onItemListClick'>    /**
</span>     * Delegation control for selecting and removing labelled items or triggering list collapse/expansion
     * @protected
     */
    onItemListClick: function(e) {
        var me = this,
            selectionModel = me.selectionModel,
            itemEl = e.getTarget(me.tagItemSelector),
            closeEl = itemEl ? e.getTarget(me.tagItemCloseSelector) : false;

        if (me.readOnly || me.disabled) {
            return;
        }

        e.stopPropagation();

        if (itemEl) {
            if (closeEl) {
                me.removeByListItemNode(itemEl);
                if (me.valueStore.getCount() &gt; 0) {
                    me.fireEvent(&#39;select&#39;, me, me.valueStore.getRange());
                }
            } else {
                me.toggleSelectionByListItemNode(itemEl, e.shiftKey);
            }
            // If not using touch interactions, focus the input
            if (!Ext.supports.TouchEvents) {
                me.inputEl.focus();
            }
        } else {
            if (selectionModel.getCount() &gt; 0) {
                selectionModel.deselectAll();
            }
            me.inputEl.focus();
            if (me.triggerOnClick) {
                me.onTriggerClick();
            }
            
        }
    },

<span id='Ext-form-field-Tag-method-getMultiSelectItemMarkup'>    /**
</span>     * Build the markup for the labelled items. Template must be built on demand due to ComboBox initComponent
     * lifecycle for the creation of on-demand stores (to account for automatic valueField/displayField setting)
     * @private
     */
    getMultiSelectItemMarkup: function() {
        var me = this,
            cssPrefix = Ext.baseCSSPrefix,
            valueField = me.valueField;

        if (!me.multiSelectItemTpl) {
            if (!me.labelTpl) {
                me.labelTpl = &#39;{&#39; + me.displayField + &#39;}&#39;;
            }
            me.labelTpl = me.getTpl(&#39;labelTpl&#39;);

            me.multiSelectItemTpl = new Ext.XTemplate([
                &#39;&lt;tpl for=&quot;.&quot;&gt;&#39;,
                    &#39;&lt;li data-selectionIndex=&quot;{[xindex - 1]}&quot; data-recordId=&quot;{internalId}&quot; data-value=&quot;{[this.getItemValue(values)]}&quot; class=&quot;&#39; + cssPrefix + &#39;tagfield-item&#39;,
                    &#39;&lt;tpl if=&quot;this.isSelected(values)&quot;&gt;&#39;,
                    &#39; &#39; + me.tagSelectedCls,
                    &#39;&lt;/tpl&gt;&#39;,
                    &#39;{%&#39;,
                        &#39;values = values.data;&#39;,
                    &#39;%}&#39;,
                    &#39;&quot; qtip=&quot;{&#39; + me.displayField + &#39;}&quot;&gt;&#39; ,
                    &#39;&lt;div class=&quot;&#39; + cssPrefix + &#39;tagfield-item-text&quot;&gt;{[this.getItemLabel(values)]}&lt;/div&gt;&#39;,
                    &#39;&lt;div class=&quot;&#39; + cssPrefix + &#39;tagfield-item-close&quot;&gt;&lt;/div&gt;&#39; ,
                    &#39;&lt;/li&gt;&#39; ,
                &#39;&lt;/tpl&gt;&#39;,
                {
                    isSelected: function(rec) {
                        return me.selectionModel.isSelected(rec);
                    },
                    getItemLabel: function(values) {
                        return me.labelTpl.apply(values);
                    },
                    getItemValue: function(rec) {
                        return rec.get(valueField);
                    },
                    strict: true
                }
            ]);
        }
        if (!me.multiSelectItemTpl.isTemplate) {
            me.multiSelectItemTpl = this.getTpl(&#39;multiSelectItemTpl&#39;);
        }

        return me.multiSelectItemTpl.apply(me.valueCollection.getRange());
    },

<span id='Ext-form-field-Tag-method-applyMultiselectItemMarkup'>    /**
</span>     * Update the labelled items rendering
     * @private
     */
    applyMultiselectItemMarkup: function() {
        var me = this,
            itemList = me.itemList;

        if (itemList) {
            itemList.select(&#39;.&#39; + Ext.baseCSSPrefix + &#39;tagfield-item&#39;).destroy();
            me.inputElCt.insertHtml(&#39;beforeBegin&#39;, me.getMultiSelectItemMarkup());
            me.autoSize();
        }
    },

<span id='Ext-form-field-Tag-method-getRecordByListItemNode'>    /**
</span>     * Returns the record from valueStore for the labelled item node
     */
    getRecordByListItemNode: function(itemEl) {
        return this.valueCollection.items[Number(itemEl.getAttribute(&#39;data-selectionIndex&#39;))];
    },

<span id='Ext-form-field-Tag-method-toggleSelectionByListItemNode'>    /**
</span>     * Toggle of labelled item selection by node reference
     */
    toggleSelectionByListItemNode: function(itemEl, keepExisting) {
        var me = this,
            rec = me.getRecordByListItemNode(itemEl),
            selModel = me.selectionModel;

        if (rec) {
            if (selModel.isSelected(rec)) {
                selModel.deselect(rec);
            } else {
                selModel.select(rec, keepExisting);
            }
        }
    },

<span id='Ext-form-field-Tag-method-removeByListItemNode'>    /**
</span>     * Removal of labelled item by node reference
     */
    removeByListItemNode: function(itemEl) {
        var me = this,
            rec = me.getRecordByListItemNode(itemEl);

        if (rec) {
            me.pickerSelectionModel.deselect(rec);
        }
    },

<span id='Ext-form-field-Tag-method-getDisplayValue'>    // Private implementation.
</span>    // The display value is always the raw value.
    // Picked values are displayed by the tag template.
    getDisplayValue: function() {
        return this.getRawValue();
    },

<span id='Ext-form-field-Tag-method-getRawValue'>    /**
</span>     * @inheritdoc
     * Intercept calls to getRawValue to pretend there is no inputEl for rawValue handling,
     * so that we can use inputEl for user input of just the current value.
     */
    getRawValue: function() {
        var me = this,
            inputEl = me.inputEl,
            result;

        me.inputEl = false;
        result = me.callParent(arguments);
        me.inputEl = inputEl;
        return result;
    },

<span id='Ext-form-field-Tag-method-setRawValue'>    /**
</span>     * @inheritdoc
     * Intercept calls to setRawValue to pretend there is no inputEl for rawValue handling,
     * so that we can use inputEl for user input of just the current value.
     */
    setRawValue: function(value) {
        var me = this,
            inputEl = me.inputEl,
            result;

        me.inputEl = false;
        result = me.callParent([value]);
        me.inputEl = inputEl;

        return result;
    },


<span id='Ext-form-field-Tag-method-removeValue'>    /**
</span>     * Removes a value or values from the current value of the field
     * @param {Mixed} value The value or values to remove from the current value, see {@link #setValue}
     */
    removeValue: function(value) {
        var me = this,
            valueCollection = me.valueCollection,
            len, i, item,
            toRemove = [];

        if (value) {
            value = Ext.Array.from(value);

            // Ensure that the remove values are records
            for (i = 0, len = value.length; i &lt; len; ++i) {
                item = value[i];

                // If a key is supplied, find the matching value record from our value collection
                if (!item.isModel) {
                    item = valueCollection.byValue.get(item);
                }
                if (item) {
                    toRemove.push(item);
                }
            }
            me.valueCollection.beginUpdate();
            me.pickerSelectionModel.deselect(toRemove);
            me.valueCollection.endUpdate();
        }
    },

<span id='Ext-form-field-Tag-method-setValue'>    /**
</span>     * Sets the specified value(s) into the field. The following value formats are recognised:
     *
     * - Single Values
     *
     *     - A string associated to this field&#39;s configured {@link #valueField}
     *     - A record containing at least this field&#39;s configured {@link #valueField} and {@link #displayField}
     *
     * - Multiple Values
     *
     *     - If {@link #multiSelect} is `true`, a string containing multiple strings as
     *       specified in the Single Values section above, concatenated in to one string
     *       with each entry separated by this field&#39;s configured {@link #delimiter}
     *     - An array of strings as specified in the Single Values section above
     *     - An array of records as specified in the Single Values section above
     *
     * In any of the string formats above, the following occurs if an associated record cannot be found:
     *
     * 1. If {@link #forceSelection} is `false`, a new record of the {@link #store}&#39;s configured model type
     *    will be created using the given value as the {@link #displayField} and {@link #valueField}.
     *    This record will be added to the current value, but it will **not** be added to the store.
     * 2. If {@link #forceSelection} is `true` and {@link #queryMode} is `remote`, the list of unknown
     *    values will be submitted as a call to the {@link #store}&#39;s load as a parameter named by
     *    the {@link #valueParam} with values separated by the configured {@link #delimiter}.
     *    ** This process will cause setValue to asynchronously process. ** This will only be attempted
     *    once. Any unknown values that the server does not return records for will be removed.
     * 3. Otherwise, unknown values will be removed.
     *
     * @param {Mixed} value The value(s) to be set, see method documentation for details
     * @return {Ext.form.field.Field/Boolean} this, or `false` if asynchronously querying for unknown values
     */
    setValue: function(value, /* private */ add, skipLoad) {
        var me = this,
            valueStore = me.valueStore,
            valueField = me.valueField,
            unknownValues = [],
            store = me.store,
            record, len, i, valueRecord, cls, params;

        if (Ext.isEmpty(value)) {
            value = null;
        }
        if (Ext.isString(value) &amp;&amp; me.multiSelect) {
            value = value.split(me.delimiter);
        }
        value = Ext.Array.from(value, true);

        for (i = 0, len = value.length; i &lt; len; i++) {
            record = value[i];
            if (!record || !record.isModel) {
                valueRecord = valueStore.findExact(valueField, record);
                if (valueRecord &gt; -1) {
                    value[i] = valueStore.getAt(valueRecord);
                } else {
                    valueRecord = me.findRecord(valueField, record);
                    if (!valueRecord) {
                        if (me.forceSelection) {
                            unknownValues.push(record);
                        } else {
                            valueRecord = {};
                            valueRecord[me.valueField] = record;
                            valueRecord[me.displayField] = record;

                            cls = me.valueStore.getModel();
                            valueRecord = new cls(valueRecord);
                        }
                    }
                    if (valueRecord) {
                        value[i] = valueRecord;
                    }
                }
            }
        }

        if (!store.isEmptyStore &amp;&amp; skipLoad !== true &amp;&amp; unknownValues.length &gt; 0 &amp;&amp; me.queryMode === &#39;remote&#39;) {
            params = {};
            params[me.valueParam || me.valueField] = unknownValues.join(me.delimiter);
            store.load({
                params: params,
                callback: function() {
                    if (me.itemList) {
                        me.itemList.unmask();
                    }
                    me.setValue(value, add, true);
                    me.autoSize();
                    me.lastQuery = false;
                }
            });
            return false;
        }

        // For single-select boxes, use the last good (formal record) value if possible
        if (!me.multiSelect &amp;&amp; value.length &gt; 0) {
            for (i = value.length - 1; i &gt;= 0; i--) {
                if (value[i].isModel) {
                    value = value[i];
                    break;
                }
            }
            if (Ext.isArray(value)) {
                value = value[value.length - 1];
            }
        }

        return me.callParent([value, add]);
    },

<span id='Ext-form-field-Tag-method-updateValue'>    // Private internal setting of value when records are added to the valueCollection
</span>    // setValue itself adds to the valueCollection.
    updateValue: function() {
        var me = this,
            valueArray = me.valueCollection.getRange(),
            len = valueArray.length,
            i;

        for (i = 0; i &lt; len; i++) {
            valueArray[i] = valueArray[i].get(me.valueField);
        }

        // Set the value of this field. If we are multiselecting, then that is an array.
        me.setHiddenValue(valueArray);
        me.value = me.multiSelect ? valueArray : valueArray[0];
        if (!Ext.isDefined(me.value)) {
            me.value = undefined;
        }

        me.applyMultiselectItemMarkup();
        me.checkChange();
    },

<span id='Ext-form-field-Tag-method-getValueRecords'>    /**
</span>     * Returns the records for the field&#39;s current value
     * @return {Array} The records for the field&#39;s current value
     */
    getValueRecords: function() {
        return this.valueCollection.getRange();
    },

<span id='Ext-form-field-Tag-method-getSubmitData'>    /**
</span>     * @inheritdoc
     * Overridden to optionally allow for submitting the field as a json encoded array.
     */
    getSubmitData: function() {
        var me = this,
            val = me.callParent(arguments);

        if (me.multiSelect &amp;&amp; me.encodeSubmitValue &amp;&amp; val &amp;&amp; val[me.name]) {
            val[me.name] = Ext.encode(val[me.name]);
        }

        return val;
    },

<span id='Ext-form-field-Tag-method-assertValue'>    /**
</span>     * Overridden to handle partial-input selections more directly
     */
    assertValue: function() {
        var me = this,
            rawValue = me.inputEl.dom.value,
            rec = !Ext.isEmpty(rawValue) ? me.findRecordByDisplay(rawValue) : false,
            value = false;

        if (!rec &amp;&amp; !me.forceSelection &amp;&amp; me.createNewOnBlur &amp;&amp; !Ext.isEmpty(rawValue)) {
            value = rawValue;
        } else if (rec) {
            value = rec;
        }

        if (value) {
            me.addValue(value);
        }

        me.inputEl.dom.value = &#39;&#39;;

        me.collapse();
    },

<span id='Ext-form-field-Tag-method-isEqual'>    /**
</span>     * Overridden to be more accepting of varied value types
     */
    isEqual: function(v1, v2) {
        var fromArray = Ext.Array.from,
            valueField = this.valueField,
            i, len, t1, t2;

        v1 = fromArray(v1);
        v2 = fromArray(v2);
        len = v1.length;

        if (len !== v2.length) {
            return false;
        }

        for(i = 0; i &lt; len; i++) {
            t1 = v1[i].isModel ? v1[i].get(valueField) : v1[i];
            t2 = v2[i].isModel ? v2[i].get(valueField) : v2[i];
            if (t1 !== t2) {
                return false;
            }
        }

        return true;
    },

<span id='Ext-form-field-Tag-method-applyEmptyText'>    /**
</span>     * Overridden to use value (selection) instead of raw value and to avoid the use of placeholder
     */
    applyEmptyText : function() {
        var me = this,
            emptyText = me.emptyText,
            emptyEl = me.emptyEl,
            inputEl = me.inputEl,
            listWrapper = me.listWrapper,
            emptyCls = me.emptyCls,
            emptyInputCls = me.emptyInputCls,
            isEmpty;

        if (me.rendered &amp;&amp; emptyText) {
            isEmpty = Ext.isEmpty(me.value) &amp;&amp; !me.hasFocus;
            if (isEmpty) {
                inputEl.dom.value = &#39;&#39;;
                emptyEl.setHtml(emptyText);
                emptyEl.addCls(emptyCls);
                emptyEl.removeCls(emptyInputCls);
                listWrapper.addCls(emptyCls);
                inputEl.addCls(emptyInputCls);
            } else {
                emptyEl.addCls(emptyInputCls);
                emptyEl.removeCls(emptyCls);
                listWrapper.removeCls(emptyCls);
                inputEl.removeCls(emptyInputCls);
            }
            me.autoSize();
        }
    },

<span id='Ext-form-field-Tag-method-preFocus'>    /**
</span>     * Overridden to use inputEl instead of raw value and to avoid the use of placeholder
     */
    preFocus : function(){
        var me = this,
            inputEl = me.inputEl,
            isEmpty = inputEl.dom.value === &#39;&#39;;

        me.emptyEl.addCls(me.emptyInputCls);
        me.emptyEl.removeCls(me.emptyCls);
        me.listWrapper.removeCls(me.emptyCls);
        me.inputEl.removeCls(me.emptyInputCls);

        if (me.selectOnFocus || isEmpty) {
            inputEl.dom.select();
        }
    },

<span id='Ext-form-field-Tag-method-onFocus'>    /**
</span>     * Intercept calls to onFocus to add focusCls, because the base field
     * classes assume this should be applied to inputEl
     */
    onFocus: function() {
        var me = this,
            focusCls = me.focusCls,
            itemList = me.itemList;

        if (focusCls &amp;&amp; itemList) {
            itemList.addCls(focusCls);
        }

        me.callParent(arguments);
    },

<span id='Ext-form-field-Tag-method-onBlur'>    /**
</span>     * Intercept calls to onBlur to remove focusCls, because the base field
     * classes assume this should be applied to inputEl
     */
    onBlur: function() {
        var me = this,
            focusCls = me.focusCls,
            itemList = me.itemList;

        if (focusCls &amp;&amp; itemList) {
            itemList.removeCls(focusCls);
        }

        me.callParent(arguments);
    },

<span id='Ext-form-field-Tag-method-renderActiveError'>    /**
</span>     * Intercept calls to renderActiveError to add invalidCls, because the base
     * field classes assume this should be applied to inputEl
     */
    renderActiveError: function() {
        var me = this,
            invalidCls = me.invalidCls,
            itemList = me.itemList,
            hasError = me.hasActiveError();

        if (invalidCls &amp;&amp; itemList) {
            itemList[hasError ? &#39;addCls&#39; : &#39;removeCls&#39;](me.invalidCls + &#39;-field&#39;);
        }

        me.callParent(arguments);
    },

<span id='Ext-form-field-Tag-method-autoSize'>    /**
</span>     * Initiate auto-sizing for height based on {@link #grow}, if applicable.
     */
    autoSize: function() {
        var me = this;

        if (me.grow &amp;&amp; me.rendered) {
            me.autoSizing = true;
            me.updateLayout();
        }

        return me;
    },

<span id='Ext-form-field-Tag-method-afterComponentLayout'>    /**
</span>     * Track height change to fire {@link #event-autosize} event, when applicable.
     */
    afterComponentLayout: function() {
        var me = this,
            height;

        if (me.autoSizing) {
            height = me.getHeight();
            if (height !== me.lastInputHeight) {
                if (me.isExpanded) {
                    me.alignPicker();
                }
                me.fireEvent(&#39;autosize&#39;, me, height);
                me.lastInputHeight = height;
                me.autoSizing = false;
            }
        }
    }
});
</pre>
</body>
</html>
