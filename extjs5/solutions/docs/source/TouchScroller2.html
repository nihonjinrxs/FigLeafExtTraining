<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-scroll-TouchScroller'>/**
</span> * @class Ext.scroll.TouchScroller
 * @private
 * Momentum scrolling is one of the most important parts of the user experience on touch-screen
 * devices.  Depending on the device and browser, Ext JS will select one of several different
 * scrolling implementations for best performance.
 *
 * Scroller settings can be changed using the {@link Ext.Container#scrollable scrollable}
 * configuration on {@link Ext.Component}. Here is a simple example of how to adjust the
 * scroller settings when using a Component (or anything that extends it).
 *
 *     @example
 *     Ext.create(&#39;Ext.Component&#39;, {
 *         renderTo: Ext.getBody(),
 *         height: 100,
 *         width: 100,
 *         // this component is scrollable vertically but not horizontally
 *         scrollable: &#39;y&#39;,
 *         html: &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque convallis lorem et magna tempus fermentum.&#39;
 *     });
 */
Ext.define(&#39;Ext.scroll.TouchScroller&#39;, {
    extend: &#39;Ext.scroll.Scroller&#39;,
    alias: &#39;scroller.touch&#39;,

    requires: [
        &#39;Ext.fx.easing.BoundMomentum&#39;,
        &#39;Ext.fx.easing.EaseOut&#39;,
        &#39;Ext.util.Translatable&#39;,
        &#39;Ext.scroll.Indicator&#39;,
        &#39;Ext.GlobalEvents&#39;
    ],

<span id='Ext-scroll-TouchScroller-property-isTouchScroller'>    isTouchScroller: true,
</span>
    config: {
<span id='Ext-scroll-TouchScroller-cfg-autoRefresh'>        /**
</span>         * @cfg autoRefresh
         * @private
         */
        autoRefresh: true,

<span id='Ext-scroll-TouchScroller-cfg-bounceEasing'>        /**
</span>         * @cfg bounceEasing
         * @private
         */
        bounceEasing: {
            duration: 400
        },

<span id='Ext-scroll-TouchScroller-cfg-elementSize'>        /**
</span>         * @cfg
         * @private
         */
        elementSize: undefined,

<span id='Ext-scroll-TouchScroller-cfg-indicators'>        indicators: true,
</span>
<span id='Ext-scroll-TouchScroller-cfg-fps'>        /**
</span>         * @cfg fps
         * @private
         */
        fps: &#39;auto&#39;,

<span id='Ext-scroll-TouchScroller-cfg-maxAbsoluteVelocity'>        /**
</span>         * @cfg maxAbsoluteVelocity
         * @private
         */
        maxAbsoluteVelocity: 6,

<span id='Ext-scroll-TouchScroller-cfg-momentumEasing'>        /**
</span>         * @cfg {Object} momentumEasing
         * @inheritdoc
         * The default value is:
         *
         *     {
         *         momentum: {
         *             acceleration: 30,
         *             friction: 0.5
         *         },
         *         bounce: {
         *             acceleration: 30,
         *             springTension: 0.3
         *         }
         *     }
         *
         * Note that supplied object will be recursively merged with the default object. For example, you can simply
         * pass this to change the momentum acceleration only:
         *
         *     {
         *         momentum: {
         *             acceleration: 10
         *         }
         *     }
         */
        momentumEasing: {
            momentum: {
                acceleration: 30,
                friction: 0.5
            },

            bounce: {
                acceleration: 30,
                springTension: 0.3
            },

            minVelocity: 1
        },

<span id='Ext-scroll-TouchScroller-cfg-outOfBoundRestrictFactor'>        /**
</span>         * @cfg outOfBoundRestrictFactor
         * @private
         */
        outOfBoundRestrictFactor: 0.5,

<span id='Ext-scroll-TouchScroller-cfg-innerElement'>        /**
</span>         * @cfg {Ext.dom.Element}
         * @private
         * The element that wraps the content of {@link #element} and is translated in
         * response to user interaction.  If not configured, one will be automatically
         * generated.
         */
        innerElement: null,

<span id='Ext-scroll-TouchScroller-cfg-size'>        size: undefined,
</span>
<span id='Ext-scroll-TouchScroller-cfg-slotSnapEasing'>        /**
</span>         * @cfg
         * @private
         */
        slotSnapEasing: {
            duration: 150
        },

<span id='Ext-scroll-TouchScroller-cfg-slotSnapSize'>        /**
</span>         * @cfg {Number/Object} slotSnapSize
         * The size of each slot to snap to in &#39;px&#39;, can be either an object with `x` and `y` values, i.e:
         *
         *      {
         *          x: 50,
         *          y: 100
         *      }
         *
         * or a number value to be used for both directions. For example, a value of `50` will be treated as:
         *
         *      {
         *          x: 50,
         *          y: 50
         *      }
         *
         * @accessor
         */
        slotSnapSize: {
            x: 0,
            y: 0
        },

<span id='Ext-scroll-TouchScroller-cfg-slotSnapOffset'>        /**
</span>         * @cfg slotSnapOffset
         * @private
         */
        slotSnapOffset: {
            x: 0,
            y: 0
        },

<span id='Ext-scroll-TouchScroller-cfg-startMomentumResetTime'>        /**
</span>         * @cfg startMomentumResetTime
         * @private
         */
        startMomentumResetTime: 300,

<span id='Ext-scroll-TouchScroller-cfg-translatable'>        /**
</span>         * @cfg translatable
         * @private
         */
        translatable: {
            translationMethod: &#39;auto&#39;,
            useWrapper: false
        }
    },

<span id='Ext-scroll-TouchScroller-property-cls'>    cls: Ext.baseCSSPrefix + &#39;scroll-container&#39;,
</span><span id='Ext-scroll-TouchScroller-property-scrollerCls'>    scrollerCls: Ext.baseCSSPrefix + &#39;scroll-scroller&#39;,
</span>
<span id='Ext-scroll-TouchScroller-property-dragStartTime'>    dragStartTime: 0,
</span>
<span id='Ext-scroll-TouchScroller-property-dragEndTime'>    dragEndTime: 0,
</span>
<span id='Ext-scroll-TouchScroller-property-isDragging'>    isDragging: false,
</span>
<span id='Ext-scroll-TouchScroller-property-isAnimating'>    isAnimating: false,
</span>
<span id='Ext-scroll-TouchScroller-property-isMouseEvent'>    isMouseEvent: {
</span>        mousedown: 1,
        mousemove: 1,
        mouseup: 1
    },

<span id='Ext-scroll-TouchScroller-property-listenerMap'>    listenerMap: {
</span>        touchstart: &#39;onTouchStart&#39;,
        touchmove: &#39;onTouchMove&#39;,
        touchend: &#39;onTouchEnd&#39;,
        dragstart: &#39;onDragStart&#39;,
        drag: &#39;onDrag&#39;,
        dragend: &#39;onDragEnd&#39;
    },

<span id='Ext-scroll-TouchScroller-property-refreshCounter'>    refreshCounter: 0,
</span>
<span id='Ext-scroll-TouchScroller-method-constructor'>    constructor: function(config) {
</span>        var me = this,
            onEvent = &#39;onEvent&#39;;

        me.elementListeners = {
            touchstart: onEvent,
            touchmove: onEvent,
            touchend: onEvent,
            dragstart: onEvent,
            drag: onEvent,
            dragend: onEvent,
            scope: me
        };

        me.minPosition = { x: 0, y: 0 };

        me.startPosition = { x: 0, y: 0 };

        me.position = { x: 0, y: 0 };

        me.velocity = { x: 0, y: 0 };

        me.isAxisEnabledFlags = { x: false, y: false };

        me.flickStartPosition = { x: 0, y: 0 };

        me.flickStartTime = { x: 0, y: 0 };

        me.lastDragPosition = { x: 0, y: 0 };

        me.dragDirection = { x: 0, y: 0};

        Ext.GlobalEvents.on(&#39;idle&#39;, me.onIdle, me);

        me.callParent([config]);

        me.refreshAxes();
    },

<span id='Ext-scroll-TouchScroller-method-applyBounceEasing'>    applyBounceEasing: function(easing) {
</span>        var defaultClass = Ext.fx.easing.EaseOut;

        return {
            x: Ext.factory(easing, defaultClass),
            y: Ext.factory(easing, defaultClass)
        };
    },

<span id='Ext-scroll-TouchScroller-method-applyElementSize'>    applyElementSize: function(size) {
</span>        var el = this.getElement(),
            dom, x, y;

        if (!el) {
            return null;
        }

        dom = el.dom;

        if (!dom) {
            return;
        }

        if (size == null) { // null or undefined
            x = dom.clientWidth;
            y = dom.clientHeight;
        } else {
            x = size.x;
            y = size.y;
        }

        return {
            x: x,
            y: y
        };
    },

<span id='Ext-scroll-TouchScroller-method-applyIndicators'>    applyIndicators: function(indicators, oldIndicators) {
</span>        var me = this,
            xIndicator, yIndicator, x, y;

        if (indicators) {
            if (indicators === true) {
                xIndicator = yIndicator = {};
            } else {
                x = indicators.x;
                y = indicators.y;
                if (x || y) {
                    // handle an object with x/y keys for configuring the indicators
                    // individually.  undfined/null/true are all the same, only false
                    // can prevent the indicator from being created
                    xIndicator = (x == null || x === true) ? {} : x;
                    yIndicator = (x == null || y === true) ? {} : y;
                } else {
                    // not an object with x/y keys, handle as a single indicators config
                    // that applies to both axes
                    xIndicator = yIndicator = indicators;
                }
            }

            if (oldIndicators) {
                if (xIndicator) {
                    oldIndicators.x.setConfig(xIndicator);
                } else {
                    oldIndicators.x.destroy();
                    oldIndicators.x = null;
                }
                if (yIndicator) {
                    oldIndicators.y.setConfig(yIndicator);
                } else {
                    oldIndicators.y.destroy();
                    oldIndicators.y = null;
                }
                indicators = oldIndicators;
            } else {
                indicators = { x: null, y: null };
                if (xIndicator) {
                    indicators.x = new Ext.scroll.Indicator(Ext.applyIf({
                        axis: &#39;x&#39;,
                        scroller: me
                    }, xIndicator));
                }
                if (yIndicator) {
                    indicators.y = new Ext.scroll.Indicator(Ext.applyIf({
                        axis: &#39;y&#39;,
                        scroller: me
                    }, yIndicator));
                }
            }
        } else if (oldIndicators) {
            oldIndicators.x.destroy();
            oldIndicators.y.destroy();
            oldIndicators.x = null;
            oldIndicators.y = null;
        }

        return indicators;
    },

<span id='Ext-scroll-TouchScroller-method-applyMomentumEasing'>    applyMomentumEasing: function(easing) {
</span>        var defaultClass = Ext.fx.easing.BoundMomentum;

        return {
            x: Ext.factory(easing, defaultClass),
            y: Ext.factory(easing, defaultClass)
        };
    },

<span id='Ext-scroll-TouchScroller-method-applyInnerElement'>    applyInnerElement: function(innerElement) {
</span>        if (innerElement &amp;&amp; !innerElement.isElement) {
            innerElement = Ext.get(innerElement);
        }

        //&lt;debug&gt;
        if (this.isConfiguring &amp;&amp; !innerElement) {
            Ext.Error.raise(&quot;Cannot create Ext.scroll.TouchScroller instance with null innerElement&quot;);
        }
        //&lt;/debug&gt;

        return innerElement;
    },

<span id='Ext-scroll-TouchScroller-method-applySize'>    applySize: function(size) {
</span>        var el, dom, scrollerDom, x, y;

        if (size == null) { // null or undefined
            el = this.getElement();

            if (!el) {
                return null;
            }

            dom = el.dom;
            scrollerDom = this.getInnerElement().dom;

            // using scrollWidth/scrollHeight instead of offsetWidth/offsetHeight ensures
            // that the size includes any contained absolutely positioned items
            x = Math.max(scrollerDom.scrollWidth, dom.clientWidth);
            y = Math.max(scrollerDom.scrollHeight, dom.clientHeight);
        } else if (typeof size === &#39;number&#39;) {
            x = size;
            y = size;
        } else {
            x = size.x;
            y = size.y;
        }

        return {
            x: x,
            y: y
        };
    },

<span id='Ext-scroll-TouchScroller-method-applySlotSnapOffset'>    applySlotSnapOffset: function(snapOffset) {
</span>        if (typeof snapOffset == &#39;number&#39;) {
            return {
                x: snapOffset,
                y: snapOffset
            };
        }

        return snapOffset;
    },

<span id='Ext-scroll-TouchScroller-method-applySlotSnapSize'>    applySlotSnapSize: function(snapSize) {
</span>        if (typeof snapSize == &#39;number&#39;) {
            return {
                x: snapSize,
                y: snapSize
            };
        }

        return snapSize;
    },

<span id='Ext-scroll-TouchScroller-method-applySlotSnapEasing'>    applySlotSnapEasing: function(easing) {
</span>        var defaultClass = Ext.fx.easing.EaseOut;

        return {
            x: Ext.factory(easing, defaultClass),
            y: Ext.factory(easing, defaultClass)
        };
    },

<span id='Ext-scroll-TouchScroller-method-applyTranslatable'>    applyTranslatable: function(config, translatable) {
</span>        return Ext.factory(config, Ext.util.Translatable, translatable);
    },

<span id='Ext-scroll-TouchScroller-method-destroy'>    destroy: function() {
</span>        var me = this,
            element = me.getElement(),
            innerElement = me.getInnerElement(),
            sizeMonitors = me.sizeMonitors;

        if (sizeMonitors) {
            sizeMonitors.element.destroy();
            sizeMonitors.container.destroy();
        }

        if (element &amp;&amp; !element.isDestroyed) {
            element.removeCls(me.cls);
        }

        if (innerElement &amp;&amp; !innerElement.isDestroyed) {
            innerElement.removeCls(me.scrollerCls);
        }

        if (me._isWrapped) {
            if (!element.isDestroyed) {
                me.unwrapContent();
            }

            innerElement.destroy();
            if (me.FixedHBoxStretching) {
                innerElement.parent().destroy();
            }
        }

        me.setElement(null);
        me.setInnerElement(null);

        Ext.GlobalEvents.un(&#39;idle&#39;, me.onIdle, me);

        Ext.destroy(me.getTranslatable());

        me.callParent(arguments);
    },

<span id='Ext-scroll-TouchScroller-method-getPosition'>    getPosition: function() {
</span>        return this.position;
    },

<span id='Ext-scroll-TouchScroller-method-refresh'>    refresh: function(immediate, /* private */ options) {
</span>        ++this.refreshCounter;
        if (immediate) {
            this.doRefresh(options);
        }
    },

<span id='Ext-scroll-TouchScroller-method-updateAutoRefresh'>    updateAutoRefresh: function(autoRefresh) {
</span>        this.toggleResizeListeners(autoRefresh);
    },

<span id='Ext-scroll-TouchScroller-method-updateBounceEasing'>    updateBounceEasing: function(easing) {
</span>        this.getTranslatable().setEasingX(easing.x).setEasingY(easing.y);
    },

<span id='Ext-scroll-TouchScroller-method-updateElementSize'>    updateElementSize: function() {
</span>        if (!this.isConfiguring) {
            // to avoid multiple calls to refreshAxes() during initialization we will
            // call it once after initConfig has finished.
            this.refreshAxes();
        }
    },

<span id='Ext-scroll-TouchScroller-method-updateDisabled'>    updateDisabled: function(disabled) {
</span>        // attachment of listeners is handled by updateElement during initial config
        if (!this.isConfiguring) {
            if (disabled) {
                this.detachListeners();
            } else {
                this.attachListeners();
            }
        }
    },

<span id='Ext-scroll-TouchScroller-method-updateElement'>    updateElement: function(element, oldElement) {
</span>        var me = this,
            // first check if the user configured a innerElement
            innerElement = me.getInnerElement(),
            fixedHBoxStretching = this.FixedHBoxStretching,
            listeners;

        if (!innerElement) {
            // if no configured scroller element, check if the first child has the
            // scrollerCls, if so we can assume that the user already wrapped the content
            // in a scrollerEl (this is true of both Ext and Touch Components).
            innerElement = element.dom.firstChild;

            if (fixedHBoxStretching &amp;&amp; innerElement) {
                innerElement = innerElement.dom.firstChild;
            }

            if (!innerElement || innerElement.nodeType !== 1 ||
                    !Ext.fly(innerElement).hasCls(me.scrollerCls)) {
                // no scrollerEl found, generate one now
                innerElement = me.wrapContent(element);
            }

            me.setInnerElement(innerElement);
        }

        if (!fixedHBoxStretching) {
            element.addCls(me.cls);
        }

        if (me.isConfiguring) {
            if (!me.getTranslatable().isScrollParent) {
                // If using full virtual scrolling attach a mousewheel listener for moving
                // the scroll position.  Otherwise we use native scrolling when interacting
                // using the mouse and so do not want to override the native behavior
                listeners = me.elementListeners;
                listeners.mousewheel = &#39;onMouseWheel&#39;;
                listeners.scroll = {
                    fn: &#39;onElementScroll&#39;,
                    delegated: false,
                    scope: me
                };
            }
        }

        if (!me.getDisabled()) {
            me.attachListeners();
        }

        if (!me.isConfiguring) {
            // setting element after initial construction of Scroller
            // sync up configs that depend on element
            if (me.getAutoRefresh()) {
                me.toggleResizeListeners(true);
            }
            // setting null size and elementSize will cause them to be updated from the DOM
            me.setSize(null);
            me.setElementSize(null);
        }

        me.callParent([element, oldElement]);
    },

<span id='Ext-scroll-TouchScroller-method-updateFps'>    updateFps: function(fps) {
</span>        if (fps !== &#39;auto&#39;) {
            this.getTranslatable().setFps(fps);
        }
    },

<span id='Ext-scroll-TouchScroller-method-updateMaxUserPosition'>    updateMaxUserPosition: function() {
</span>        this.snapToBoundary();
    },

<span id='Ext-scroll-TouchScroller-method-updateMinUserPosition'>    updateMinUserPosition: function() {
</span>        this.snapToBoundary();
    },

<span id='Ext-scroll-TouchScroller-method-updateInnerElement'>    updateInnerElement: function(innerElement) {
</span>        if (innerElement) {
            innerElement.addCls(this.scrollerCls);
        }

        this.getTranslatable().setElement(innerElement);
    },

<span id='Ext-scroll-TouchScroller-method-updateSize'>    updateSize: function() {
</span>        if (!this.isConfiguring) {
            // to avoid multiple calls to refreshAxes() during initialization we will
            // call it once after initConfig has finished.
            this.refreshAxes();
        }
    },

<span id='Ext-scroll-TouchScroller-method-updateTranslatable'>    updateTranslatable: function(translatable) {
</span>        translatable.setElement(this.getInnerElement());
        translatable.on({
            animationframe: &#39;onAnimationFrame&#39;,
            animationend: &#39;onAnimationEnd&#39;,
            scope: this
        });
    },

<span id='Ext-scroll-TouchScroller-method-updateX'>    updateX: function() {
</span>        if (!this.isConfiguring) {
            // to avoid multiple calls to refreshAxes() during initialization we will
            // call it once after initConfig has finished.
            this.refreshAxes();
        }
    },

<span id='Ext-scroll-TouchScroller-method-updateY'>    updateY: function() {
</span>        if (!this.isConfiguring) {
            // to avoid multiple calls to refreshAxes() during initialization we will
            // call it once after initConfig has finished.
            this.refreshAxes();
        }
    },

<span id='Ext-scroll-TouchScroller-property-privates'>    privates: {
</span>        attachListeners: function() {
            this.getElement().on(this.elementListeners);
        },

        constrainX: function(x) {
            var maxX = this.getMaxPosition().x;
            return Math.min(this.getMaxPosition().x, Math.max(x, 0));
        },

        constrainY: function(y) {
            var maxY = this.getMaxPosition().y;
            return Math.min(this.getMaxPosition().y, Math.max(y, 0));
        },

        // overridden in RTL mode to swap min/max momentum values
        convertEasingConfig: function(config) {
            return config;
        },

        detachListeners: function() {
            this.getElement().un(this.elementListeners);
        },

        // private
        doRefresh: function(options) {
            var me = this,
                size, elementSize;

            if (me.refreshCounter &amp;&amp; me.getElement()) {
                me.stopAnimation();

                me.getTranslatable().refresh();

                if (options) {
                    // refresh called due to resize handler on element or innerElement.
                    // Do not bother to read the DOM to determine sizing info, just set the size
                    // given by the resize handler
                    size = options.size;
                    elementSize = options.elementSize;

                    if (size) {
                        me.setSize(size);
                    }

                    if (elementSize) {
                        me.setElementSize(elementSize);
                    }
                } else {
                    // calling doRefresh() without options will cause both size and
                    // elementSize to be measured from the DOM.
                    me.setSize(null);
                    me.setElementSize(null);
                }

                me.fireEvent(&#39;refresh&#39;, me);
                me.refreshCounter = 0;
            }
        },

        doScrollTo: function(x, y, animation, /* private */ allowOverscroll) {
            var me = this,
                isDragging = me.isDragging,
                fireScrollCallback;

            if (me.isDestroyed || !me.getElement()) {
                return me;
            }

            // Normally the scroll position is constrained to the max scroll position, but
            // during a drag operation or during reflectio the scroller is allowed to overscroll.
            allowOverscroll = allowOverscroll || me.isDragging;

            var translatable = me.getTranslatable(),
                position = me.position,
                positionChanged = false,
                translationX, translationY;

            if (!isDragging || me.isAxisEnabled(&#39;x&#39;)) {
                if (isNaN(x) || typeof x != &#39;number&#39;) {
                    x = position.x;
                } else {

                    if (!allowOverscroll) {
                        x = me.constrainX(x);
                    }

                    if (position.x !== x) {
                        position.x = x;
                        positionChanged = true;
                    }
                }

                translationX = me.convertX(-x);
            }

            if (!isDragging || me.isAxisEnabled(&#39;y&#39;)) {
                if (isNaN(y) || typeof y != &#39;number&#39;) {
                    y = position.y;
                } else {
                    if (!allowOverscroll) {
                        y = me.constrainY(y);
                    }

                    if (position.y !== y) {
                        position.y = y;
                        positionChanged = true;
                    }
                }

                translationY = -y;
            }

            if (positionChanged) {
                if (animation) {

                    // We need a callback to fire it after the animation
                    fireScrollCallback = function() {
                        me.onScroll();
                    };

                    // If they passed a boolean, create an object to hold the callback.
                    if (animation === true) {
                        animation = {
                            callback: fireScrollCallback
                        };
                    }
                    // They want a callback, so we need to create a sequence on it.
                    else if (animation.callback) {
                        animation.callback = Ext.Function.createSequence(animation.callback, fireScrollCallback);
                    }
                    // We can just use the callback for our own purpose
                    else {
                        animation.callback = fireScrollCallback;
                    }
                    translatable.translateAnimated(translationX, translationY, animation);
                }
                else {
                    translatable.translate(translationX, translationY);
                    me.onScroll();
                }
            }

            return me;
        },

<span id='Ext-scroll-TouchScroller-method-getAnimationEasing'>        /**
</span>         * @private
         */
        getAnimationEasing: function(axis, e) {
            if (!this.isAxisEnabled(axis)) {
                return null;
            }

            var me = this,
                currentPosition = me.position[axis],
                minPosition = me.getMinUserPosition()[axis],
                maxPosition = me.getMaxUserPosition()[axis],
                maxAbsVelocity = me.getMaxAbsoluteVelocity(),
                boundValue = null,
                dragEndTime = me.dragEndTime,
                velocity = e.flick.velocity[axis],
                isX = axis === &#39;x&#39;,
                easingConfig, easing;

            if (currentPosition &lt; minPosition) {
                boundValue = minPosition;
            }
            else if (currentPosition &gt; maxPosition) {
                boundValue = maxPosition;
            }

            if (isX) {
                currentPosition = me.convertX(currentPosition);
                boundValue = me.convertX(boundValue);
            }

            // Out of bound, to be pulled back
            if (boundValue !== null) {
                easing = me.getBounceEasing()[axis];
                easing.setConfig({
                    startTime: dragEndTime,
                    startValue: -currentPosition,
                    endValue: -boundValue
                });

                return easing;
            }

            if (velocity === 0) {
                return null;
            }

            if (velocity &lt; -maxAbsVelocity) {
                velocity = -maxAbsVelocity;
            }
            else if (velocity &gt; maxAbsVelocity) {
                velocity = maxAbsVelocity;
            }

            if (Ext.browser.is.IE) {
                velocity *= 2;
            }

            easing = me.getMomentumEasing()[axis];
            easingConfig = {
                startTime: dragEndTime,
                startValue: -currentPosition,
                startVelocity: velocity * 1.5,
                minMomentumValue: -maxPosition,
                maxMomentumValue: 0
            };

            if (isX) {
                me.convertEasingConfig(easingConfig);
            }

            easing.setConfig(easingConfig);

            return easing;
        },

<span id='Ext-scroll-TouchScroller-method-getSnapPosition'>        /**
</span>         * @private
         * @return {Number/null}
         */
        getSnapPosition: function(axis) {
            var me = this,
                snapSize = me.getSlotSnapSize()[axis],
                snapPosition = null,
                position, snapOffset, maxPosition, mod;

            if (snapSize !== 0 &amp;&amp; me.isAxisEnabled(axis)) {
                position = me.position[axis];
                snapOffset = me.getSlotSnapOffset()[axis];
                maxPosition = me.getMaxUserPosition()[axis];

                mod = Math.floor((position - snapOffset) % snapSize);

                if (mod !== 0) {
                    if (position !== maxPosition) {
                        if (Math.abs(mod) &gt; snapSize / 2) {
                            snapPosition = Math.min(maxPosition, position + ((mod &gt; 0) ? snapSize - mod : mod - snapSize));
                        }
                        else {
                            snapPosition = position - mod;
                        }
                    }
                    else {
                        snapPosition = position - mod;
                    }
                }
            }

            return snapPosition;
        },

        hideIndicators: function() {
            var me = this,
                indicators = me.getIndicators(),
                xIndicator, yIndicator;

            if (indicators) {
                if (me.isAxisEnabled(&#39;x&#39;)) {
                    xIndicator = indicators.x;
                    if (xIndicator) {
                        xIndicator.hide();
                    }
                }

                if (me.isAxisEnabled(&#39;y&#39;)) {
                    yIndicator = indicators.y;
                    if (yIndicator) {
                        yIndicator.hide();
                    }
                }
            }
        },

<span id='Ext-scroll-TouchScroller-method-isAxisEnabled'>        /**
</span>         * Returns `true` if a specified axis is enabled.
         * @private
         * @param {String} axis The axis to check (`x` or `y`).
         * @return {Boolean} `true` if the axis is enabled.
         */
        isAxisEnabled: function(axis) {
            this.getX();
            this.getY();

            return this.isAxisEnabledFlags[axis];
        },

        onAnimationEnd: function() {
            this.snapToBoundary();
            this.onScrollEnd();
        },

        onAnimationFrame: function(translatable, x, y) {
            var position = this.position;

            position.x = this.convertX(-x);
            position.y = -y;

            this.onScroll();
        },

        onAxisDrag: function(axis, delta) {
            if (!this.isAxisEnabled(axis)) {
                return;
            }

            var me = this,
                flickStartPosition = me.flickStartPosition,
                flickStartTime = me.flickStartTime,
                lastDragPosition = me.lastDragPosition,
                dragDirection = me.dragDirection,
                old = me.position[axis],
                min = me.getMinUserPosition()[axis],
                max = me.getMaxUserPosition()[axis],
                start = me.startPosition[axis],
                last = lastDragPosition[axis],
                current = start - delta,
                lastDirection = dragDirection[axis],
                restrictFactor = me.getOutOfBoundRestrictFactor(),
                startMomentumResetTime = me.getStartMomentumResetTime(),
                now = Ext.Date.now(),
                distance;

            if (current &lt; min) {
                current *= restrictFactor;
            }
            else if (current &gt; max) {
                distance = current - max;
                current = max + distance * restrictFactor;
            }

            if (current &gt; last) {
                dragDirection[axis] = 1;
            }
            else if (current &lt; last) {
                dragDirection[axis] = -1;
            }

            if ((lastDirection !== 0 &amp;&amp; (dragDirection[axis] !== lastDirection))
                || (now - flickStartTime[axis]) &gt; startMomentumResetTime) {
                flickStartPosition[axis] = old;
                flickStartTime[axis] = now;
            }

            lastDragPosition[axis] = current;
        },

        // In &quot;hybrid&quot; touch scroll mode where the TouchScroller is used to control the
        // scroll position of a naturally overflowing element, we need to sync the scroll
        // position of the TouchScroller when the element is scrolled
        onDomScroll: function() {
            var me = this,
                dom, position;

            if (me.getTranslatable().isScrollParent) {
                dom = me.getElement().dom;
                position = me.position;

                position.x = dom.scrollLeft;
                position.y = dom.scrollTop;
            }
            me.callParent();
        },

        onDrag: function(e) {
            var me = this,
                lastDragPosition = me.lastDragPosition;

            if (!me.isDragging) {
                return;
            }

            me.onAxisDrag(&#39;x&#39;, me.convertX(e.deltaX));
            me.onAxisDrag(&#39;y&#39;, e.deltaY);

            me.doScrollTo(lastDragPosition.x, lastDragPosition.y);
        },

        onDragEnd: function(e) {
            var me = this,
                easingX, easingY;

            if (!me.isDragging) {
                return;
            }

            me.dragEndTime = Ext.Date.now();

            me.onDrag(e);

            me.isDragging = false;

            easingX = me.getAnimationEasing(&#39;x&#39;, e);
            easingY = me.getAnimationEasing(&#39;y&#39;, e);

            if (easingX || easingY) {
                me.getTranslatable().animate(easingX, easingY);
            } else {
                me.onScrollEnd();
            }
        },

        onDragStart: function(e) {
            var me = this,
                direction = me.getDirection(),
                absDeltaX = e.absDeltaX,
                absDeltaY = e.absDeltaY,
                directionLock = me.getDirectionLock(),
                startPosition = me.startPosition,
                flickStartPosition = me.flickStartPosition,
                flickStartTime = me.flickStartTime,
                lastDragPosition = me.lastDragPosition,
                currentPosition = me.position,
                dragDirection = me.dragDirection,
                x = currentPosition.x,
                y = currentPosition.y,
                now = Ext.Date.now();

            me.isDragging = true;

            if (directionLock &amp;&amp; direction !== &#39;both&#39;) {
                if ((direction === &#39;horizontal&#39; &amp;&amp; absDeltaX &gt; absDeltaY)
                    || (direction === &#39;vertical&#39; &amp;&amp; absDeltaY &gt; absDeltaX)) {
                    e.stopPropagation();
                }
                else {
                    me.isDragging = false;
                    return;
                }
            }

            lastDragPosition.x = x;
            lastDragPosition.y = y;

            flickStartPosition.x = x;
            flickStartPosition.y = y;

            startPosition.x = x;
            startPosition.y = y;

            flickStartTime.x = now;
            flickStartTime.y = now;

            dragDirection.x = 0;
            dragDirection.y = 0;

            me.dragStartTime = now;

            me.isDragging = true;

            me.onScrollStart();
        },

        onElementResize: function(element, info) {
            this.refresh(true, {
                elementSize: {
                    x: info.width,
                    y: info.height
                }
            });
        },

        onElementScroll: function(event, targetEl) {
            targetEl.scrollTop = targetEl.scrollLeft = 0;
        },

        onEvent: function(e) {
            // use browserEvent to get the &quot;real&quot; type of DOM event that was fired, not a
            // potentially translated (or recognized) type
            var me = this,
                browserEvent = e.browserEvent;

            if ((!me.self.isTouching || me.isTouching) &amp;&amp; // prevents nested scrolling
                    // prevents scrolling in response to mouse input on multi-input devices
                    // such as windows 8 laptops with touch screens.
                    // Don&#39;t bother checking the event type if we are on a device that uses
                    // full virtual scrolling (!isScrollParent)
                    // TODO: this should be handled by the event system once EXTJSIV-12840
                    // is implemented
                    ((!me.getTranslatable().isScrollParent) || (!me.isMouseEvent[browserEvent.type] &amp;&amp;
                        browserEvent.pointerType !== &#39;mouse&#39;)) &amp;&amp;
                        (me.getY() || me.getX())) {
                me[me.listenerMap[e.type]](e);
            }
        },

        onIdle: function() {
            this.doRefresh();
        },

        onInnerElementResize: function(element, info) {
            this.refresh(true, {
                size: {
                    x: info.width,
                    y: info.height
                }
            });
        },

        onMouseWheel: function(e) {
            var me = this,
                delta = e.getWheelDeltas(),
                deltaX = -delta.x,
                deltaY = -delta.y,
                position = me.position,
                maxPosition = me.getMaxUserPosition(),
                minPosition = me.getMinUserPosition(),
                max = Math.max,
                min = Math.min,
                positionX = max(min(position.x + deltaX, maxPosition.x), minPosition.x),
                positionY = max(min(position.y + deltaY, maxPosition.y), minPosition.y);

            deltaX = positionX - position.x;
            deltaY = positionY - position.y;

            if (!deltaX &amp;&amp; !deltaY) {
                return;
            }
            e.stopEvent();

            me.onScrollStart();
            me.scrollBy(deltaX, deltaY);
            me.onScroll();
            me.onScrollEnd();
        },

        onPartnerScrollEnd: function() {
            this.hideIndicators();
        },

        onPartnerScrollStart: function() {
            this.showIndicators();
        },

        onScroll: function() {
            var me = this,
                position = me.position,
                x = position.x,
                y = position.y,
                indicators = me.getIndicators(),
                xIndicator, yIndicator;

            if (indicators) {
                if (me.isAxisEnabled(&#39;x&#39;)) {
                    xIndicator = indicators.x;
                    if (xIndicator) {
                        xIndicator.setValue(x);
                    }
                }
                if (me.isAxisEnabled(&#39;y&#39;)) {
                    yIndicator = indicators.y;
                    if (yIndicator) {
                        yIndicator.setValue(y);
                    }
                }
            }

            me.fireScroll(x, y);
        },

        onScrollEnd: function() {
            var me = this,
                position = me.position;

            if (!me.isTouching &amp;&amp; !me.snapToSlot()) {
                me.hideIndicators();
                Ext.isScrolling = false;
                me.fireScrollEnd(position.x, position.y);
            }
        },

        onScrollStart: function() {
            var me = this,
                position = me.position;

            me.showIndicators();

            Ext.isScrolling = true;
            me.fireScrollStart(position.x, position.y);
        },

        onTouchEnd: function() {
            var me = this;

            me.isTouching = me.self.isTouching = false;

            if (!me.isDragging &amp;&amp; me.snapToSlot()) {
                me.onScrollStart();
            }
        },

        onTouchMove: function(e) {
            // Prevents the page from scrolling while an element is being scrolled using
            // the TouchScroller.  Only needed when inside a page that does not use a
            // Viewport, since the Viewport already prevents default behavior of touchmove
            e.preventDefault();
        },

        onTouchStart: function() {
            this.isTouching = this.self.isTouching = true;
            this.stopAnimation();
        },

        refreshAxes: function() {
            var me = this,
                flags = me.isAxisEnabledFlags,
                size = me.getSize(),
                elementSize = me.getElementSize(),
                indicators = me.getIndicators(),
                maxX, maxY, x, y, xIndicator, yIndicator;

            if (!size || !elementSize) {
                return;
            }

            maxX = Math.max(0, size.x - elementSize.x);
            maxY = Math.max(0, size.y - elementSize.y);
            x = me.getX();
            y = me.getY();

            me.setMaxPosition({
                x: maxX,
                y: maxY
            });

            if (x === true || x === &#39;auto&#39;) {
                // auto scroll - axis is only enabled if the content is overflowing in the
                // same direction
                flags.x = !!maxX;
            } else if (x === false) {
                flags.x = false;
                xIndicator = indicators &amp;&amp; indicators.x;
                if (xIndicator) {
                    // hide the x indicator if the x axis is disabled, just in case we
                    // are refreshing during a scroll
                    xIndicator.hide();
                }
            } else if (x === &#39;scroll&#39;) {
                flags.x = true
            }

            if (y === true || y === &#39;auto&#39;) {
                // auto scroll - axis is only enabled if the content is overflowing in the
                // same direction
                flags.y = !!maxY;
            } else if (y === false) {
                flags.y = false;
                yIndicator = indicators &amp;&amp; indicators.y;
                if (yIndicator) {
                    // hide the y indicator if the y axis is disabled, just in case we
                    // are refreshing during a scroll
                    yIndicator.hide();
                }
            } else if (y === &#39;scroll&#39;) {
                flags.y = true
            }

            me.setMaxUserPosition({
                x: flags.x ? maxX : 0,
                y: flags.y ? maxY : 0
            });
        },

        showIndicators: function() {
            var me = this,
                indicators = me.getIndicators(),
                xIndicator, yIndicator;

            if (indicators) {
                if (me.isAxisEnabled(&#39;x&#39;)) {
                    xIndicator = indicators.x;
                    if (xIndicator) {
                        xIndicator.show();
                    }
                }

                if (me.isAxisEnabled(&#39;y&#39;)) {
                    yIndicator = indicators.y;
                    if (yIndicator) {
                        yIndicator.show();
                    }
                }
            }
        },

        snapToBoundary: function() {
            if (this.isConfiguring) {
                return;
            }

            var me = this,
                position = me.position,
                minPosition = me.getMinUserPosition(),
                maxPosition = me.getMaxUserPosition(),
                minX = minPosition.x,
                minY = minPosition.y,
                maxX = maxPosition.x,
                maxY = maxPosition.y,
                x = Math.round(position.x),
                y = Math.round(position.y);

            if (x &lt; minX) {
                x = minX;
            }
            else if (x &gt; maxX) {
                x = maxX;
            }

            if (y &lt; minY) {
                y = minY;
            }
            else if (y &gt; maxY) {
                y = maxY;
            }

            me.doScrollTo(x, y);
        },

<span id='Ext-scroll-TouchScroller-method-snapToSlot'>        /**
</span>         * @private
         * @return {Boolean}
         */
        snapToSlot: function() {
            var me = this,
                snapX = me.getSnapPosition(&#39;x&#39;),
                snapY = me.getSnapPosition(&#39;y&#39;),
                easing = me.getSlotSnapEasing();

            if (snapX !== null || snapY !== null) {
                me.doScrollTo(snapX, snapY, {
                    easingX: easing.x,
                    easingY: easing.y
                });

                return true;
            }

            return false;
        },

<span id='Ext-scroll-TouchScroller-method-stopAnimation'>        /**
</span>         * @private
         * Stops the animation of the scroller at any time.
         */
        stopAnimation: function() {
            this.getTranslatable().stopAnimation();
        },

        toggleResizeListeners: function(on) {
            var me = this,
                element = me.getElement(),
                method = on ? &#39;on&#39; : &#39;un&#39;;

            if (element) {
                element[method](&#39;resize&#39;, &#39;onElementResize&#39;, me);
                me.getInnerElement()[method](&#39;resize&#39;, &#39;onInnerElementResize&#39;, me);
            }
        },

        unwrapContent: function() {
            var innerDom = this.getInnerElement().dom,
                dom = this.getElement().dom,
                child;

            while ((child = innerDom.firstChild)) {
                dom.insertBefore(child, innerDom);
            }
        },

<span id='Ext-scroll-TouchScroller-method-wrapContent'>        /**
</span>         * Wraps the element&#39;s content in a innerElement
         * @param {Ext.dom.Element} element
         * @return {Ext.dom.Element} the innerElement
         * @private
         */
        wrapContent: function(element) {
            var wrap = document.createElement(&#39;div&#39;),
                dom = element.dom,
                child;

            while (child = dom.lastChild) {
                wrap.insertBefore(child, wrap.firstChild);
            }

            dom.appendChild(wrap);

            this.setInnerElement(wrap);

            // Set a flag that indiacates the element&#39;s content was not already pre-wrapped
            // when the scroller was instanced.  This means we had to wrap the content
            // and so must unwrap when we destroy the scroller.
            this._isWrapped = true;

            return this.getInnerElement();
        }
    }
});
</pre>
</body>
</html>
