<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// @tag core
<span id='Ext-mixin-Observable'>/**
</span> * Base class that provides a common interface for publishing events. Subclasses are
 * expected to have a property &quot;events&quot; which is populated as event listeners register,
 * and, optionally, a property &quot;listeners&quot; with configured listeners defined.
 *
 * For example:
 *
 *     Ext.define(&#39;Employee&#39;, {
 *         mixins: [&#39;Ext.mixin.Observable&#39;]
 *
 *         constructor: function (config) {
 *             // The Observable constructor copies all of the properties of `config` on
 *             // to `this` using {@link Ext#apply}. Further, the `listeners` property is
 *             // processed to add listeners.
 *             //
 *             this.mixins.observable.constructor.call(this, config);
 *         }
 *     });
 *
 * This could then be used like this:
 *
 *     var newEmployee = new Employee({
 *         name: employeeName,
 *         listeners: {
 *             quit: function() {
 *                 // By default, &quot;this&quot; will be the object that fired the event.
 *                 alert(this.name + &quot; has quit!&quot;);
 *             }
 *         }
 *     });
 */
Ext.define(&#39;Ext.mixin.Observable&#39;, function(Observable) {

    var emptyFn = Ext.emptyFn,
        emptyArray = [],
        arrayProto = Array.prototype,
        arraySlice = arrayProto.slice,
        // Private Destroyable class which removes listeners
        ListenerRemover = function(observable) {

            // Passed a ListenerRemover: return it
            if (observable instanceof ListenerRemover) {
                return observable;
            }

            this.observable = observable;

            // Called when addManagedListener is used with the event source as the second arg:
            // (owner, eventSource, args...)
            if (arguments[1].isObservable) {
                this.managedListeners = true;
            }
            this.args = arraySlice.call(arguments, 1);
        };

    ListenerRemover.prototype.destroy = function() {
        this.destroy = Ext.emptyFn;
        var observable = this.observable;
        observable[this.managedListeners ? &#39;mun&#39; : &#39;un&#39;].apply(observable, this.args);
    };

    return {
        extend: &#39;Ext.Mixin&#39;,
        mixinConfig: {
            id: &#39;observable&#39;,
            after: {
                destroy: &#39;clearListeners&#39;
            }
        },

        requires: [
            &#39;Ext.util.Event&#39;
        ],

        mixins: [&#39;Ext.mixin.Identifiable&#39;],

        statics: {
<span id='Ext-mixin-Observable-static-method-releaseCapture'>            /**
</span>            * Removes **all** added captures from the Observable.
            *
            * @param {Ext.util.Observable} o The Observable to release
            * @static
            */
            releaseCapture: function(o) {
                o.fireEventArgs = this.prototype.fireEventArgs;
            },

<span id='Ext-mixin-Observable-static-method-capture'>            /**
</span>            * Starts capture on the specified Observable. All events will be passed to the supplied function with the event
            * name + standard signature of the event **before** the event is fired. If the supplied function returns false,
            * the event will not fire.
            *
            * @param {Ext.util.Observable} o The Observable to capture events from.
            * @param {Function} fn The function to call when an event is fired.
            * @param {Object} scope (optional) The scope (`this` reference) in which the function is executed. Defaults to
            * the Observable firing the event.
            * @static
            */
            capture: function(o, fn, scope) {
                // We&#39;re capturing calls to fireEventArgs to avoid duplication of events;
                // however fn expects fireEvent&#39;s signature so we have to convert it here.
                // To avoid unnecessary conversions, observe() below is aware of the changes
                // and will capture fireEventArgs instead.
                var newFn = function(eventName, args) {
                    return fn.apply(scope, [eventName].concat(args));
                };
                
                this.captureArgs(o, newFn, scope);
            },
            
<span id='Ext-mixin-Observable-method-captureArgs'>            /**
</span>             * @private
             */
            captureArgs: function(o, fn, scope) {
                o.fireEventArgs = Ext.Function.createInterceptor(o.fireEventArgs, fn, scope);
            },

<span id='Ext-mixin-Observable-static-method-observe'>            /**
</span>            * Sets observability on the passed class constructor.
            *
            * This makes any event fired on any instance of the passed class also fire a single event through
            * the **class** allowing for central handling of events on many instances at once.
            *
            * Usage:
            *
            *     Ext.util.Observable.observe(Ext.data.Connection);
            *     Ext.data.Connection.on(&#39;beforerequest&#39;, function(con, options) {
            *         console.log(&#39;Ajax request made to &#39; + options.url);
            *     });
            *
            * @param {Function} c The class constructor to make observable.
            * @param {Object} listeners An object containing a series of listeners to add. See {@link #addListener}.
            * @static
            */
            observe: function(cls, listeners) {
                if (cls) {
                    if (!cls.isObservable) {
                        Ext.applyIf(cls, new this());
                        this.captureArgs(cls.prototype, cls.fireEventArgs, cls);
                    }
                    if (Ext.isObject(listeners)) {
                        cls.on(listeners);
                    }
                }
                return cls;
            },

<span id='Ext-mixin-Observable-method-prepareClass'>            /**
</span>            * Prepares a given class for observable instances. This method is called when a
            * class derives from this class or uses this class as a mixin.
            * @param {Function} T The class constructor to prepare.
            * @param {Ext.util.Observable} mixin The mixin if being used as a mixin.
            * @param {Object} data The raw class creation data if this is an extend.
            * @private
            */
            prepareClass: function (T, mixin, data) {
                // T.hasListeners is the object to track listeners on class T. This object&#39;s
                // prototype (__proto__) is the &quot;hasListeners&quot; of T.superclass.

                // Instances of T will create &quot;hasListeners&quot; that have T.hasListeners as their
                // immediate prototype (__proto__).

                var listeners = T.listeners = [],
                    // If this function was called as a result of an &quot;onExtended&quot;, it will
                    // receive the class as &quot;T&quot;, but the members will not yet have been
                    // applied to the prototype. If this is the case, just grab listeners
                    // off of the raw data object.
                    target = data || T.prototype,
                    targetListeners = target.listeners,
                    superListeners = mixin ? mixin.listeners : T.superclass.self.listeners,
                    name, scope, namedScope;

                // Process listeners that have been declared on the class body. These
                // listeners must not override each other, but each must be added
                // separately. This is accomplished by maintaining a nested array
                // of listeners for the class and it&#39;s superclasses/mixins
                if (superListeners) {
                    listeners.push(superListeners);
                }

                if (targetListeners) {
                    // Allow listener scope resolution mechanism to know if the listeners
                    // were declared on the class.  This is only necessary when scope
                    // is unspecified, or when scope is &#39;controller&#39;.  We use special private
                    // named scopes of &quot;self&quot; and &quot;self.controller&quot; to indicate either
                    // unspecified scope, or scope declared as controller on the class
                    // body.  To avoid iterating the listeners object multiple times, we
                    // only put this special scope on the outermost object at this point
                    // and allow addListener to handle scope:&#39;controller&#39; declared on
                    // inner objects of the listeners config.
                    scope = targetListeners.scope;
                    if (!scope) {
                        targetListeners.scope = &#39;self&#39;;
                    } else {
                        namedScope = Ext._namedScopes[scope];
                        if (namedScope &amp;&amp; namedScope.isController) {
                            targetListeners.scope = &#39;self.controller&#39;;
                        }
                    }

                    listeners.push(targetListeners);

                    // After adding the target listeners to the declared listeners array
                    // we can delete it off of the prototype (or data object).  This ensures
                    // that we don&#39;t attempt to add the listeners twice, once during
                    // addDeclaredListeners, and again when we add this.listeners in the
                    // constructor.
                    target.listeners = null;
                }

                if (!T.HasListeners) {
                    // We create a HasListeners &quot;class&quot; for this class. The &quot;prototype&quot; of the
                    // HasListeners class is an instance of the HasListeners class associated
                    // with this class&#39;s super class (or with Observable).
                    var HasListeners = function () {},
                        SuperHL = T.superclass.HasListeners || (mixin &amp;&amp; mixin.HasListeners) ||
                                Observable.HasListeners;

                    // Make the HasListener class available on the class and its prototype:
                    T.prototype.HasListeners = T.HasListeners = HasListeners;

                    // And connect its &quot;prototype&quot; to the new HasListeners of our super class
                    // (which is also the class-level &quot;hasListeners&quot; instance).
                    HasListeners.prototype = T.hasListeners = new SuperHL();
                }
            }
        },

        /* End Definitions */

<span id='Ext-mixin-Observable-cfg-listeners'>        /**
</span>        * @cfg {Object} listeners
        *
        * A config object containing one or more event handlers to be added to this object during initialization. This
        * should be a valid listeners config object as specified in the {@link #addListener} example for attaching multiple
        * handlers at once.
        *
        * **DOM events from Ext JS {@link Ext.Component Components}**
        *
        * While _some_ Ext JS Component classes export selected DOM events (e.g. &quot;click&quot;, &quot;mouseover&quot; etc), this is usually
        * only done when extra value can be added. For example the {@link Ext.view.View DataView}&#39;s **`{@link
        * Ext.view.View#itemclick itemclick}`** event passing the node clicked on. To access DOM events directly from a
        * child element of a Component, we need to specify the `element` option to identify the Component property to add a
        * DOM listener to:
        *
        *     new Ext.panel.Panel({
        *         width: 400,
        *         height: 200,
        *         dockedItems: [{
        *             xtype: &#39;toolbar&#39;
        *         }],
        *         listeners: {
        *             click: {
        *                 element: &#39;el&#39;, //bind to the underlying el property on the panel
        *                 fn: function(){ console.log(&#39;click el&#39;); }
        *             },
        *             dblclick: {
        *                 element: &#39;body&#39;, //bind to the underlying body property on the panel
        *                 fn: function(){ console.log(&#39;dblclick body&#39;); }
        *             }
        *         }
        *     });
        */

<span id='Ext-mixin-Observable-property-isObservable'>        /**
</span>        * @property {Boolean} isObservable
        * `true` in this class to identify an object as an instantiated Observable, or subclass thereof.
        */
        isObservable: true,
        
<span id='Ext-mixin-Observable-property-eventsSuspended'>        /**
</span>        * @private
        * Initial suspended call count. Incremented when {@link #suspendEvents} is called, decremented when {@link #resumeEvents} is called.
        */
        eventsSuspended: 0,

<span id='Ext-mixin-Observable-property-hasListeners'>        /**
</span>        * @property {Object} hasListeners
        * @readonly
        * This object holds a key for any event that has a listener. The listener may be set
        * directly on the instance, or on its class or a super class (via {@link #observe}) or
        * on the {@link Ext.app.EventBus MVC EventBus}. The values of this object are truthy
        * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
        * of listeners. The value for an event is truthy if the event must be fired and is
        * falsy if there is no need to fire the event.
        * 
        * The intended use of this property is to avoid the expense of fireEvent calls when
        * there are no listeners. This can be particularly helpful when one would otherwise
        * have to call fireEvent hundreds or thousands of times. It is used like this:
        * 
        *      if (this.hasListeners.foo) {
        *          this.fireEvent(&#39;foo&#39;, this, arg1);
        *      }
        */

        constructor: function(config) {
            var me = this,
                self = me.self,
                declaredListeners, listeners, bubbleEvents;

            me.hasListeners = new me.HasListeners();

            me.events = me.events || {};

            declaredListeners = self.listeners;
            if (declaredListeners &amp;&amp; !me._addDeclaredListeners(declaredListeners)) {
                // Nulling out declared listeners allows future instances to avoid
                // recursing into the declared listeners arrays if the first instance
                // discovers that there are no declarative listeners in its hierarchy
                self.listeners = null;
            }

            listeners = (config &amp;&amp; config.listeners) || me.listeners;

            if (listeners) {
                if (listeners instanceof Array) {
                    // Support for listeners declared as an array:
                    //
                    //     listeners: [
                    //         { foo: fooHandler },
                    //         { bar: barHandler }
                    //     ]
                    Ext.each(listeners, me.on, me);
                } else {
                    me.on(listeners);
                }
            }

            bubbleEvents = (config &amp;&amp; config.bubbleEvents) || me.bubbleEvents;

            if (bubbleEvents) {
                me.enableBubble(bubbleEvents);
            }

            if (me.$applyConfigs) {
                // Ext.util.Observable applies config properties directly to the instance
                Ext.apply(me, config);
            } else {
                // Ext.mixin.Observable uses the config system
                me.initConfig(config);
            }

            if (listeners) {
                // Set as an instance property to pre-empt the prototype in case any are set there.
                // Prevents listeners from being added multiple times if this constructor
                // is called more than once by multiple parties in the inheritance hierarchy
                me.listeners = null;
            }
        },

        onClassExtended: function (T, data) {
            if (!T.HasListeners) {
                // Some classes derive from us and some others derive from those classes. All
                // of these are passed to this method.
                Observable.prepareClass(T, T.prototype.$observableMixedIn ? undefined : data);
            }
        },

        // @private
        // Matches options property names within a listeners specification object  - property names which are never used as event names.
        $eventOptions: {
            scope: 1,
            delay: 1,
            buffer: 1,
            onFrame: 1,
            single: 1,
            args: 1,
            destroyable: 1,
            priority: 1,
            order: 1
        },

        $orderToPriority: {
            before: 100,
            current: 0,
            after: -100
        },

<span id='Ext-mixin-Observable-method-_addDeclaredListeners'>        /**
</span>         * Adds declarative listeners as nested arrays of listener objects.
         * @private
         * @param {Array} listeners
         * @return {Boolean} `true` if any listeners were added
         */
        _addDeclaredListeners: function(listeners) {
            var me = this;

            if (listeners instanceof Array) {
                Ext.each(listeners, me._addDeclaredListeners, me);
            } else {
                me._addedDeclaredListeners = true;
                me.addListener(listeners);
            }

            return me._addedDeclaredListeners;
        },

<span id='Ext-mixin-Observable-method-addManagedListener'>        /**
</span>        * The addManagedListener method is used when some object (call it &quot;A&quot;) is listening 
        * to an event on another observable object (&quot;B&quot;) and you want to remove that listener 
        * from &quot;B&quot; when &quot;A&quot; is destroyed. This is not an issue when &quot;B&quot; is destroyed because
        * all of its listeners will be removed at that time.
        *
        * Example:
        *
        *     Ext.define(&#39;Foo&#39;, {
        *         extend: &#39;Ext.Component&#39;,
        *
        *         initComponent: function () {
        *             this.addManagedListener(MyApp.SomeGlobalSharedMenu, &#39;show&#39;, this.doSomething);
        *             this.callParent();
        *         }
        *     });
        *
        * As you can see, when an instance of Foo is destroyed, it ensures that the &#39;show&#39; 
        * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
        *
        * As of version 5.1 it is no longer necessary to use this method in most cases because
        * listeners are automatically managed if the scope object provided to {@link #addListener}
        * is an Observable instance. However, if the observable instance and scope are not the
        * same object you still need to use `mon` or `addManagedListener` if you want the listener
        * to be managed.
        *
        * @param {Ext.util.Observable/Ext.dom.Element} item The item to which to add a listener/listeners.
        * @param {Object/String} ename The event name, or an object containing event name properties.
        * @param {Function} fn (optional) If the `ename` parameter was an event name, this is the handler function.
        * @param {Object} scope (optional) If the `ename` parameter was an event name, this is the scope (`this` reference)
        * in which the handler function is executed.
        * @param {Object} options (optional) If the `ename` parameter was an event name, this is the
        * {@link Ext.util.Observable#addListener addListener} options.
        * @return {Object} **Only when the `destroyable` option is specified. **
        *
        *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
        *
        *     this.btnListeners = myButton.mon({
        *         destroyable: true
        *         mouseover:   function() { console.log(&#39;mouseover&#39;); },
        *         mouseout:    function() { console.log(&#39;mouseout&#39;); },
        *         click:       function() { console.log(&#39;click&#39;); }
        *     });
        *
        * And when those listeners need to be removed:
        *
        *     Ext.destroy(this.btnListeners);
        *
        * or
        *
        *     this.btnListeners.destroy();
        */
        addManagedListener: function(item, ename, fn, scope, options, /* private */ noDestroy) {
            var me = this,
                managedListeners = me.managedListeners = me.managedListeners || [],
                config, passedOptions;

            if (typeof ename !== &#39;string&#39;) {
                // When creating listeners using the object form, allow caller to override the default of
                // using the listeners object as options.
                // This is used by relayEvents, when adding its relayer so that it does not contibute
                // a spurious options param to the end of the arg list.
                passedOptions = arguments.length &gt; 4 ? options : ename;

                options = ename;
                for (ename in options) {
                    if (options.hasOwnProperty(ename)) {
                        config = options[ename];
                        if (!item.$eventOptions[ename]) {
                            // recurse, but pass the noDestroy parameter as true so that lots of individual Destroyables are not created.
                            // We create a single one at the end if necessary.
                            me.addManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope, config.fn ? config : passedOptions, true);
                        }
                    }
                }
                if (options &amp;&amp; options.destroyable) {
                    return new ListenerRemover(me, item, options);
                }
            }
            else {
                if (fn !== emptyFn) {
                    item.doAddListener(ename, fn, scope, options, null, me, me);

                    // The &#39;noDestroy&#39; flag is sent if we&#39;re looping through a hash of listeners passing each one to addManagedListener separately
                    if (!noDestroy &amp;&amp; options &amp;&amp; options.destroyable) {
                        return new ListenerRemover(me, item, ename, fn, scope);
                    }
                }
            }
        },

<span id='Ext-mixin-Observable-method-removeManagedListener'>        /**
</span>        * Removes listeners that were added by the {@link #mon} method.
        *
        * @param {Ext.util.Observable/Ext.dom.Element} item The item from which to remove a listener/listeners.
        * @param {Object/String} ename The event name, or an object containing event name properties.
        * @param {Function} fn (optional) If the `ename` parameter was an event name, this is the handler function.
        * @param {Object} scope (optional) If the `ename` parameter was an event name, this is the scope (`this` reference)
        * in which the handler function is executed.
        */
        removeManagedListener: function(item, ename, fn, scope) {
            var me = this,
                options,
                config,
                managedListeners,
                length,
                i;

            if (typeof ename !== &#39;string&#39;) {
                options = ename;
                for (ename in options) {
                    if (options.hasOwnProperty(ename)) {
                        config = options[ename];
                        if (!item.$eventOptions[ename]) {
                            me.removeManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope);
                        }
                    }
                }
            } else {
                managedListeners = me.managedListeners ? me.managedListeners.slice() : [];

                ename = Ext.canonicalEventName(ename);

                for (i = 0, length = managedListeners.length; i &lt; length; i++) {
                    me.removeManagedListenerItem(false, managedListeners[i], item, ename, fn, scope);
                }
            }
        },

<span id='Ext-mixin-Observable-method-fireEvent'>        /**
</span>        * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
        * to {@link #addListener}).
        *
        * An event may be set to bubble up an Observable parent hierarchy (See {@link Ext.Component#getBubbleTarget}) by
        * calling {@link #enableBubble}.
        *
        * @param {String} eventName The name of the event to fire.
        * @param {Object...} args Variable number of parameters are passed to handlers.
        * @return {Boolean} returns false if any of the handlers return false otherwise it returns true.
        */
        fireEvent: function(eventName) {
            return this.fireEventArgs(eventName, arraySlice.call(arguments, 1));
        },
        
<span id='Ext-mixin-Observable-method-resolveListenerScope'>        /**
</span>         * Gets the default scope for firing late bound events (string names with
         * no scope attached) at runtime.
         * @param {Object} [defaultScope=this] The default scope to return if none is found.
         * @return {Object} The default event scope
         * @protected
         */
        resolveListenerScope: function (defaultScope) {
            var namedScope = Ext._namedScopes[defaultScope];
            if (namedScope) {
                //&lt;debug&gt;
                if (namedScope.isController) {
                    Ext.Error.raise(&#39;scope: &quot;controller&quot; can only be specified on classes that derive from Ext.Component or Ext.Widget&#39;);
                }
                //&lt;/debug&gt;

                if (namedScope.isSelf || namedScope.isThis) {
                    defaultScope = null;
                }
            }
            return defaultScope || this;
        },

<span id='Ext-mixin-Observable-method-fireEventArgs'>        /**
</span>        * Fires the specified event with the passed parameter list.
        *
        * An event may be set to bubble up an Observable parent hierarchy (See {@link Ext.Component#getBubbleTarget}) by
        * calling {@link #enableBubble}.
        *
        * @param {String} eventName The name of the event to fire.
        * @param {Object[]} args An array of parameters which are passed to handlers.
        * @return {Boolean} returns false if any of the handlers return false otherwise it returns true.
        */
        fireEventArgs: function(eventName, args) {
            eventName = Ext.canonicalEventName(eventName);
            var me = this,
                // no need to make events since we need an Event with listeners
                events = me.events,
                event = events &amp;&amp; events[eventName],
                ret = true;

            // Only continue firing the event if there are listeners to be informed.
            // Bubbled events will always have a listener count, so will be fired.
            if (me.hasListeners[eventName]) {
                ret = me.doFireEvent(eventName, args || emptyArray, event ? event.bubble : false);
            }
            return ret;
        },

<span id='Ext-mixin-Observable-method-fireAction'>        /**
</span>         * Fires the specified event with the passed parameters and executes a function (action).
         * By default, the action function will be executed after any &quot;before&quot; event handlers
         * (as specified using the `order` option of `{@link #addListener}`), but before any
         * other handlers are fired.  This gives the &quot;before&quot; handlers an opportunity to
         * cancel the event by returning `false`, and prevent the action function from being
         * called.
         *
         * The action can also be configured to run after normal handlers, but before any &quot;after&quot;
         * handlers (as specified using the `order` event option) by passing `&#39;after&#39;`
         * as the `order` parameter.  This configuration gives any event handlers except
         * for &quot;after&quot; handlers the opportunity to cancel the event and prevent the action
         * function from being called.
         *
         * @param {String} eventName The name of the event to fire.
         * @param {Array} args Arguments to pass to handlers and to the action function.
         * @param {Function} fn The action function.
         * @param {Object} [scope] The scope (`this` reference) in which the handler function is
         * executed. **If omitted, defaults to the object which fired the event.**
         * @param {Object} options Event options for the action function.  Accepts any
         * of the options of `{@link #addListener}`
         * @param {String} [order=&#39;before&#39;] The order to call the action function relative
         * too the event handlers (`&#39;before&#39;` or `&#39;after&#39;`).  Note that this option is
         * simply used to sort the action function relative to the event handlers by &quot;priority&quot;.
         * An order of `&#39;before&#39;` is equivalent to a priority of `99.5`, while an order of
         * `&#39;after&#39;` is equivalent to a priority of `-99.5`.  See the `priority` option
         * of `{@link #addListener}` for more details.
         */
        fireAction: function(eventName, args, fn, scope, options, order) {
            // chain options to avoid mutating the user&#39;s options object
            options = options ? Ext.Object.chain(options) : {};
            options.single = true;
            options.priority = ((order === &#39;after&#39;) ? -99.5 : 99.5);

            this.doAddListener(eventName, fn, scope, options);
            this.fireEventArgs(eventName, args);
        },

<span id='Ext-mixin-Observable-method-doFireEvent'>        /**
</span>        * Continue to fire event.
        * @private
        *
        * @param {String} eventName
        * @param {Array} args
        * @param {Boolean} bubbles
        */
        doFireEvent: function(eventName, args, bubbles) {
            var target = this,
                queue, event,
                ret = true;

            do {
                if (target.eventsSuspended) {
                    if ((queue = target.eventQueue)) {
                        queue.push([eventName, args]);
                    }
                    return ret;
                } else {
                    event = target.events &amp;&amp; target.events[eventName];
                    // Continue bubbling if event exists and it is `true` or the handler didn&#39;t returns false and it
                    // configure to bubble.
                    if (event &amp;&amp; event !== true) {
                        if ((ret = event.fire.apply(event, args)) === false) {
                            break;
                        }
                    }
                }
            } while (bubbles &amp;&amp; (target = target.getBubbleParent()));
            return ret;
        },

<span id='Ext-mixin-Observable-method-getBubbleParent'>        /**
</span>        * Gets the bubbling parent for an Observable
        * @private
        * @return {Ext.util.Observable} The bubble parent. null is returned if no bubble target exists
        */
        getBubbleParent: function() {
            var me = this, parent = me.getBubbleTarget &amp;&amp; me.getBubbleTarget();
            if (parent &amp;&amp; parent.isObservable) {
                return parent;
            }
            return null;
        },

<span id='Ext-mixin-Observable-method-addListener'>        /**
</span>        * The {@link #on} method is shorthand for {@link #addListener}.
        *
        * Appends an event handler to this object.  For example:
        *
        *     myGridPanel.on(&quot;mouseover&quot;, this.onMouseOver, this);
        *
        * The method also allows for a single argument to be passed which is a config object
        * containing properties which specify multiple events. For example:
        *
        *     myGridPanel.on({
        *         cellClick: this.onCellClick,
        *         mouseover: this.onMouseOver,
        *         mouseout: this.onMouseOut,
        *         scope: this // Important. Ensure &quot;this&quot; is correct during handler execution
        *     });
        *
        * One can also specify options for each event handler separately:
        *
        *     myGridPanel.on({
        *         cellClick: {fn: this.onCellClick, scope: this, single: true},
        *         mouseover: {fn: panel.onMouseOver, scope: panel}
        *     });
        *
        * *Names* of methods in a specified scope may also be used. Note that
        * `scope` MUST be specified to use this option:
        *
        *     myGridPanel.on({
        *         cellClick: {fn: &#39;onCellClick&#39;, scope: this, single: true},
        *         mouseover: {fn: &#39;onMouseOver&#39;, scope: panel}
        *     });
        *
        * @param {String/Object} eventName The name of the event to listen for.
        * May also be an object who&#39;s property names are event names.
        *
        * @param {Function} [fn] The method the event invokes, or *if `scope` is specified, the *name* of the method within
        * the specified `scope`.  Will be called with arguments
        * given to {@link Ext.util.Observable#fireEvent} plus the `options` parameter described below.
        *
        * @param {Object} [scope] The scope (`this` reference) in which the handler function is
        * executed. **If omitted, defaults to the object which fired the event.**
        *
        * @param {Object} [options] An object containing handler configuration.
        *
        * **Note:** Unlike in ExtJS 3.x, the options object will also be passed as the last
        * argument to every event handler.
        *
        * This object may contain any of the following properties:
        *
        * @param {Object} options.scope
        *   The scope (`this` reference) in which the handler function is executed. **If omitted,
        *   defaults to the object which fired the event.**
        *
        * @param {Number} options.delay
        *   The number of milliseconds to delay the invocation of the handler after the event fires.
        *
        * @param {Boolean} options.single
        *   True to add a handler to handle just the next firing of the event, and then remove itself.
        *
        * @param {Number} options.buffer
        *   Causes the handler to be scheduled to run in an {@link Ext.util.DelayedTask} delayed
        *   by the specified number of milliseconds. If the event fires again within that time,
        *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
        *
        * @param {Number} options.onFrame
        *   Causes the handler to be scheduled to run at the next animation frame event. If the
        *   event fires again before that time, the handler is not rescheduled - the handler
        *   will only be called once when the next animation frame is fired, with the last set
        *   of arguments passed.
        *
        * @param {Ext.util.Observable} options.target
        *   Only call the handler if the event was fired on the target Observable, _not_ if the event
        *   was bubbled up from a child Observable.
        *
        * @param {String} options.element
        *   **This option is only valid for listeners bound to {@link Ext.Component Components}.**
        *   The name of a Component property which references an element to add a listener to.
        *
        *   This option is useful during Component construction to add DOM event listeners to elements of
        *   {@link Ext.Component Components} which will exist only after the Component is rendered.
        *   For example, to add a click listener to a Panel&#39;s body:
        *
        *       new Ext.panel.Panel({
        *           title: &#39;The title&#39;,
        *           listeners: {
        *               click: this.handlePanelClick,
        *               element: &#39;body&#39;
        *           }
        *       });
        *
        * @param {Array} [options.args]
        *   Optional arguments to pass to the handler function. Any additional arguments
        *   passed to {@link #fireEvent} will be appended to these arguments.
        *
        * @param {Boolean} [options.destroyable=false]
        *   When specified as `true`, the function returns A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call.
        *   
        * @param {Number} [options.priority]
        *   An optional numeric priority that determines the order in which event handlers
        *   are run. Event handlers with no priority will be run as if they had a priority
        *   of 0. Handlers with a higher priority will be prioritized to run sooner than
        *   those with a lower priority.  Negative numbers can be used to set a priority
        *   lower than the default. Internally, the framework uses a range of 1000 or
        *   greater, and -1000 or lesser for handlers that are intended to run before or
        *   after all others, so it is recommended to stay within the range of -999 to 999
        *   when setting the priority of event handlers in application-level code.
        *   A priority must be an integer to be valid.  Fractional values are reserved for
        *   internal framework use.
        *
        * @param {String} [options.order=&#39;current&#39;]
        *   A legacy option that is provided for backward compatibility.
        *   It is recommended to use the `priority` option instead.  Available options are:
        *
        *   - `&#39;before&#39;`: equal to a priority of `100`
        *   - `&#39;current&#39;`: equal to a priority of `0` or default priority
        *   - `&#39;after&#39;`: equal to a priority of `-100`
        *
        * @param {String} [order=&#39;current&#39;]
        *   A shortcut for the `order` event option.  Provided for backward compatibility.
        *   Please use the `priority` event option instead.
        *
        * **Combining Options**
        *
        * Using the options argument, it is possible to combine different types of listeners:
        *
        * A delayed, one-time listener.
        *
        *     myPanel.on(&#39;hide&#39;, this.handleClick, this, {
        *         single: true,
        *         delay: 100
        *     });
        *
        * @return {Object} **Only when the `destroyable` option is specified. **
        *
        *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
        *
        *     this.btnListeners =  = myButton.on({
        *         destroyable: true
        *         mouseover:   function() { console.log(&#39;mouseover&#39;); },
        *         mouseout:    function() { console.log(&#39;mouseout&#39;); },
        *         click:       function() { console.log(&#39;click&#39;); }
        *     });
        *
        * And when those listeners need to be removed:
        *
        *     Ext.destroy(this.btnListeners);
        *
        * or
        *
        *     this.btnListeners.destroy();
        */
        addListener: function(ename, fn, scope, options, order, /* private */ caller) {
            var me = this,
                namedScopes = Ext._namedScopes,
                config, namedScope, isClassListener, innerScope, eventOptions;

            // Object listener hash passed
            if (typeof ename !== &#39;string&#39;) {
                options = ename;
                scope = options.scope;
                namedScope = scope &amp;&amp; namedScopes[scope];
                isClassListener = namedScope &amp;&amp; namedScope.isSelf;
                // give subclasses the opportunity to switch the valid eventOptions
                // (Ext.Component uses this when the &quot;element&quot; option is used)
                eventOptions = ((me.isComponent || me.isWidget) &amp;&amp; options.element) ?
                    me.$elementEventOptions : me.$eventOptions;

                for (ename in options) {
                    config = options[ename];
                    if (!eventOptions[ename]) {
                        /* This would be an API change so check removed until https://sencha.jira.com/browse/EXTJSIV-7183 is fully implemented in 4.2
                        // Test must go here as well as in the simple form because of the attempted property access here on the config object.
                        //&lt;debug&gt;
                        if (!config || (typeof config !== &#39;function&#39; &amp;&amp; !config.fn)) {
                            Ext.Error.raise(&#39;No function passed for event &#39; + me.$className + &#39;.&#39; + ename);
                        }
                        //&lt;/debug&gt;
                        */

                        innerScope = config.scope;
                        // for proper scope resolution, scope:&#39;controller&#39; specified on an
                        // inner object, must be translated to &#39;self.controller&#39; if the
                        // listeners object was declared on the class body.
                        // see also Ext.util.Observable#prepareClass and
                        // Ext.mixin.Inheritable#resolveListenerScope
                        if (innerScope &amp;&amp; isClassListener) {
                            namedScope = namedScopes[innerScope];
                            if (namedScope &amp;&amp; namedScope.isController) {
                                innerScope = &#39;self.controller&#39;;
                            }
                        }

                        me.doAddListener(ename, config.fn || config, innerScope || scope, config.fn ? config : options, order, caller);
                    }

                }
                if (options &amp;&amp; options.destroyable) {
                    return new ListenerRemover(me, options);
                }
            } else {
                me.doAddListener(ename, fn, scope, options, order, caller);

                if (options &amp;&amp; options.destroyable) {
                    return new ListenerRemover(me, ename, fn, scope, options);
                }
            }
            return me;
        },

<span id='Ext-mixin-Observable-method-removeListener'>        /**
</span>        * Removes an event handler.
        *
        * @param {String} eventName The type of event the handler was associated with.
        * @param {Function} fn The handler to remove. **This must be a reference to the function passed into the
        * {@link Ext.util.Observable#addListener} call.**
        * @param {Object} scope (optional) The scope originally specified for the handler. It must be the same as the
        * scope argument specified in the original call to {@link Ext.util.Observable#addListener} or the listener will not be removed.
        */
        removeListener: function(ename, fn, scope, /* private */ eventOptions) {
            var me = this,
                config, options;

            if (typeof ename !== &#39;string&#39;) {
                options = ename;
                // give subclasses the opportunity to switch the valid eventOptions
                // (Ext.Component uses this when the &quot;element&quot; option is used)
                eventOptions = eventOptions || me.$eventOptions;
                for (ename in options) {
                    if (options.hasOwnProperty(ename)) {
                        config = options[ename];
                        if (!me.$eventOptions[ename]) {
                            me.doRemoveListener(ename, config.fn || config, config.scope || options.scope);
                        }
                    }
                }
            } else {
                me.doRemoveListener(ename, fn, scope);
            }

            return me;
        },

<span id='Ext-mixin-Observable-method-clearListeners'>        /**
</span>        * Removes all listeners for this object including the managed listeners
        */
        clearListeners: function() {
            var me = this,
                events = me.events,
                hasListeners = me.hasListeners,
                event,
                key;

            if (events) {
                for (key in events) {
                    if (events.hasOwnProperty(key)) {
                        event = events[key];
                        if (event.isEvent) {
                            delete hasListeners[key];
                            event.clearListeners();
                        }
                    }
                }
            }

            me.clearManagedListeners();
        },

        //&lt;debug&gt;
        purgeListeners : function() {
            if (Ext.global.console) {
                Ext.global.console.warn(&#39;Observable: purgeListeners has been deprecated. Please use clearListeners.&#39;);
            }
            return this.clearListeners.apply(this, arguments);
        },
        //&lt;/debug&gt;

<span id='Ext-mixin-Observable-method-clearManagedListeners'>        /**
</span>        * Removes all managed listeners for this object.
        */
        clearManagedListeners : function() {
            var me = this,
                managedListeners = me.managedListeners ? me.managedListeners.slice() : [],
                i = 0,
                len = managedListeners.length;

            for (; i &lt; len; i++) {
                me.removeManagedListenerItem(true, managedListeners[i]);
            }

            me.managedListeners = [];
        },

<span id='Ext-mixin-Observable-method-removeManagedListenerItem'>        /**
</span>        * Remove a single managed listener item
        * @private
        * @param {Boolean} isClear True if this is being called during a clear
        * @param {Object} managedListener The managed listener item
        * See removeManagedListener for other args
        */
        removeManagedListenerItem: function(isClear, managedListener, item, ename, fn, scope){
            if (isClear || (managedListener.item === item &amp;&amp; managedListener.ename === ename &amp;&amp; (!fn || managedListener.fn === fn) &amp;&amp; (!scope || managedListener.scope === scope))) {
                // Pass along the options for mixin.Observable, for example if using delegate
                managedListener.item.doRemoveListener(managedListener.ename, managedListener.fn, managedListener.scope, managedListener.options);
                if (!isClear) {
                    Ext.Array.remove(this.managedListeners, managedListener);
                }
            }
        },

        //&lt;debug&gt;
        purgeManagedListeners : function() {
            if (Ext.global.console) {
                Ext.global.console.warn(&#39;Observable: purgeManagedListeners has been deprecated. Please use clearManagedListeners.&#39;);
            }
            return this.clearManagedListeners.apply(this, arguments);
        },
        //&lt;/debug&gt;
        
<span id='Ext-mixin-Observable-method-hasListener'>        /**
</span>        * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
        * indicates whether the event needs firing or not.
        *
        * @param {String} eventName The name of the event to check for
        * @return {Boolean} `true` if the event is being listened for or bubbles, else `false`
        */
        hasListener: function(ename) {
            ename = Ext.canonicalEventName(ename);
            return !!this.hasListeners[ename];
        },
        
<span id='Ext-mixin-Observable-method-isSuspended'>        /**
</span>         * Checks if all events, or a specific event, is suspended.
         * @param {String} [event] The name of the specific event to check
         * @return {Boolean} `true` if events are suspended
         */
        isSuspended: function(event) {
            var suspended = this.eventsSuspended &gt; 0,
                events = this.events;
                
            if (!suspended &amp;&amp; event &amp;&amp; events) {
                event = events[event];
                if (event &amp;&amp; event.isEvent) {
                    return event.isSuspended();
                }
            }
            return suspended;
        },

<span id='Ext-mixin-Observable-method-suspendEvents'>        /**
</span>        * Suspends the firing of all events. (see {@link #resumeEvents})
        *
        * @param {Boolean} queueSuspended `true` to queue up suspended events to be fired
        * after the {@link #resumeEvents} call instead of discarding all suspended events.
        */
        suspendEvents: function(queueSuspended) {
            ++this.eventsSuspended;
            if (queueSuspended &amp;&amp; !this.eventQueue) {
                this.eventQueue = [];
            }
        },

<span id='Ext-mixin-Observable-method-suspendEvent'>        /**
</span>         * Suspends firing of the named event(s).
         *
         * After calling this method to suspend events, the events will no longer fire when requested to fire.
         *
         * **Note that if this is called multiple times for a certain event, the converse method
         * {@link #resumeEvent} will have to be called the same number of times for it to resume firing.**
         *
         * @param  {String...} eventName Multiple event names to suspend.
         */
        suspendEvent: function() {
            var me = this,
                events = me.events,
                len = arguments.length,
                i, event, ename;

            for (i = 0; i &lt; len; i++) {
                ename = arguments[i];
                ename = Ext.canonicalEventName(ename);
                event = events[ename];
                // we need to spin up the Event instance so it can hold the suspend count
                if (!event || !event.isEvent) {
                    event = me._initEvent(ename);
                }
                event.suspend();
            }
        },

<span id='Ext-mixin-Observable-method-resumeEvent'>        /**
</span>         * Resumes firing of the named event(s).
         *
         * After calling this method to resume events, the events will fire when requested to fire.
         *
         * **Note that if the {@link #suspendEvent} method is called multiple times for a certain event,
         * this converse method will have to be called the same number of times for it to resume firing.**
         *
         * @param  {String...} eventName Multiple event names to resume.
         */
        resumeEvent: function() {
            var events = this.events || 0,
                len = events &amp;&amp; arguments.length,
                i, event;

            for (i = 0; i &lt; len; i++) {
                // If it exists, and is an Event object (not still a boolean placeholder), resume it
                event = events[arguments[i]];
                if (event &amp;&amp; event.resume) {
                    event.resume();
                }
            }
        },

<span id='Ext-mixin-Observable-method-resumeEvents'>        /**
</span>        * Resumes firing events (see {@link #suspendEvents}).
        *
        * If events were suspended using the `queueSuspended` parameter, then all events fired
        * during event suspension will be sent to any listeners now.
        * 
        * @param {Boolean} [discardQueue] `true` to prevent any previously queued events from firing
        * while we were suspended. See {@link #suspendEvents}.
        */
        resumeEvents: function(discardQueue) {
            var me = this,
                queued = me.eventQueue,
                qLen, q;

            if (me.eventsSuspended &amp;&amp; ! --me.eventsSuspended) {
                delete me.eventQueue;

                if (!discardQueue &amp;&amp; queued) {
                    qLen = queued.length;
                    for (q = 0; q &lt; qLen; q++) {
                        // Important to call fireEventArgs here so MVC can hook in
                        me.fireEventArgs.apply(me, queued[q]);
                    }
                }
            }
        },

<span id='Ext-mixin-Observable-method-relayEvents'>        /**
</span>        * Relays selected events from the specified Observable as if the events were fired by `this`.
        *
        * For example if you are extending Grid, you might decide to forward some events from store.
        * So you can do this inside your initComponent:
        *
        *     this.relayEvents(this.getStore(), [&#39;load&#39;]);
        *
        * The grid instance will then have an observable &#39;load&#39; event which will be passed 
        * the parameters of the store&#39;s load event and any function fired with the grid&#39;s 
        * load event would have access to the grid using the this keyword (unless the event 
        * is handled by a controller&#39;s control/listen event listener in which case &#39;this&#39; 
        * will be the controller rather than the grid).
        *
        * @param {Object} origin The Observable whose events this object is to relay.
        * @param {String[]} events Array of event names to relay.
        * @param {String} [prefix] A common prefix to prepend to the event names. For example:
        *
        *     this.relayEvents(this.getStore(), [&#39;load&#39;, &#39;clear&#39;], &#39;store&#39;);
        *
        * Now the grid will forward &#39;load&#39; and &#39;clear&#39; events of store as &#39;storeload&#39; and &#39;storeclear&#39;.
        *
        * @return {Object} A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
        *
        *     this.storeRelayers = this.relayEvents(this.getStore(), [&#39;load&#39;, &#39;clear&#39;], &#39;store&#39;);
        *
        * Can be undone by calling
        *
        *     Ext.destroy(this.storeRelayers);
        *
        * or
        *     this.store.relayers.destroy();
        */
        relayEvents : function(origin, events, prefix) {
            var me = this,
                len = events.length,
                i = 0,
                oldName,
                relayers = {};

            for (; i &lt; len; i++) {
                oldName = events[i];

                // Build up the listener hash.
                relayers[oldName] = me.createRelayer(prefix ? prefix + oldName : oldName);
            }
            // Add the relaying listeners as ManagedListeners so that they are removed when this.clearListeners is called (usually when _this_ is destroyed)
            // Explicitly pass options as undefined so that the listener does not get an extra options param
            // which then has to be sliced off in the relayer.
            me.mon(origin, relayers, null, null, undefined);

            // relayed events are always destroyable.
            return new ListenerRemover(me, origin, relayers);
        },

<span id='Ext-mixin-Observable-method-createRelayer'>        /**
</span>        * @private
        * Creates an event handling function which refires the event from this object as the passed event name.
        * @param {String} newName The name under which to refire the passed parameters.
        * @param {Array} beginEnd (optional) The caller can specify on which indices to slice.
        * @returns {Function}
        */
        createRelayer: function(newName, beginEnd) {
            var me = this;
            return function() {
                return me.fireEventArgs.call(me, newName, beginEnd ? arraySlice.apply(arguments, beginEnd) : arguments);
            };
        },

<span id='Ext-mixin-Observable-method-enableBubble'>        /**
</span>        * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
        * present. There is no implementation in the Observable base class.
        *
        * This is commonly used by Ext.Components to bubble events to owner Containers.
        * See {@link Ext.Component#getBubbleTarget}. The default implementation in Ext.Component returns the
        * Component&#39;s immediate owner. But if a known target is required, this can be overridden to access the
        * required target more quickly.
        *
        * Example:
        *
        *     Ext.define(&#39;Ext.overrides.form.field.Base&#39;, {
        *         override: &#39;Ext.form.field.Base&#39;,
        *
        *         //  Add functionality to Field&#39;s initComponent to enable the change event to bubble
        *         initComponent: function () {
        *             this.callParent();
        *             this.enableBubble(&#39;change&#39;);
        *         }
        *     });
        *
        *     var myForm = Ext.create(&#39;Ext.form.Panel&#39;, {
        *         title: &#39;User Details&#39;,
        *         items: [{
        *             ...
        *         }],
        *         listeners: {
        *             change: function() {
        *                 // Title goes red if form has been modified.
        *                 myForm.header.setStyle(&#39;color&#39;, &#39;red&#39;);
        *             }
        *         }
        *     });
        *
        * @param {String/String[]} eventNames The event name to bubble, or an Array of event names.
        */
        enableBubble: function(eventNames) {
            if (eventNames) {
                var me = this,
                    names = (typeof eventNames == &#39;string&#39;) ? arguments : eventNames,
                    // we must create events now if we have not yet
                    events = me.events,
                    length = events &amp;&amp; names.length,
                    ename, event, i;

                for (i = 0; i &lt; length; ++i) {
                    ename = names[i];
                    ename = Ext.canonicalEventName(ename);
                    event = events[ename];

                    if (!event || !event.isEvent) {
                        event = me._initEvent(ename);
                    }

                    // Event must fire if it bubbles (We don&#39;t know if anyone up the
                    // bubble hierarchy has listeners added)
                    me.hasListeners._incr_(ename);

                    event.bubble = true;
                }
            }
        },

        destroy: function() {
            this.clearListeners();
            this.callParent();
        },

        privates: {
            doAddListener: function(ename, fn, scope, options, order, caller, manager) {
                var me = this,
                    event, managedListeners, priority;

                order = order || (options &amp;&amp; options.order);

                if (order) {
                    priority = (options &amp;&amp; options.priority);

                    if (!priority) { // priority option takes precedence over order
                        // do not mutate the user&#39;s options
                        options = options ? Ext.Object.chain(options) : {};
                        options.priority = me.$orderToPriority[order];
                    }
                }

                ename = Ext.canonicalEventName(ename);

                //&lt;debug&gt;
                if (!fn) {
                    Ext.Error.raise(&quot;Cannot add &#39;&quot; + ename + &quot;&#39; listener to &quot; + me.$className +
                        &quot; instance.  No function specified.&quot;);
                }
                //&lt;/debug&gt;

                if (!manager &amp;&amp; (scope &amp;&amp; scope.isObservable &amp;&amp; (scope !== me))) {
                    manager = scope;
                }

                if (manager) {
                    // if scope is an observable, the listener will be automatically managed
                    // this eliminates the need to call mon() in a majority of cases
                    managedListeners = manager.managedListeners = manager.managedListeners || [];

                    managedListeners.push({
                        item: me,
                        ename: ename,
                        fn: fn,
                        scope: scope,
                        options: options
                    });
                }

                event = (me.events || (me.events = {}))[ename];
                if (!event || !event.isEvent) {
                    event = me._initEvent(ename);
                }

                if (fn !== emptyFn) {
                    if (event.addListener(fn, scope, options, caller, manager)) {
                        // If a new listener has been added (Event.addListener rejects duplicates of the same fn+scope)
                        // then increment the hasListeners counter
                        me.hasListeners._incr_(ename);
                    }
                }
            },

            doRemoveListener: function(ename, fn, scope) {
                var me = this,
                    events = me.events,
                    event;

                ename = Ext.canonicalEventName(ename);
                event = events &amp;&amp; events[ename];

                //&lt;debug&gt;
                if (!fn) {
                    Ext.Error.raise(&quot;Cannot remove &#39;&quot; + ename + &quot;&#39; listener to &quot; + me.$className +
                        &quot; instance.  No function specified.&quot;);
                }
                //&lt;/debug&gt;

                if (event &amp;&amp; event.isEvent) {
                    if (event.removeListener(fn, scope)) {
                        me.hasListeners._decr_(ename);
                    }
                }
            },

            _initEvent: function(eventName) {
                return (this.events[eventName] = new Ext.util.Event(this, eventName));
            }
        },

        deprecated: {
            &#39;5.0&#39;: {
                methods: {
                    addEvents: null
                }
            },
            &#39;5.1&#39;: {
                methods: {
<span id='Ext-mixin-Observable-method-addBeforeListener'>                    /**
</span>                     * Appends a before-event handler.  Returning `false` from the handler will stop the event.
                     *
                     * Same as {@link #addListener} with `order` set to `&#39;before&#39;`.
                     *
                     * @param {String/String[]/Object} eventName The name of the event to listen for.
                     * @param {Function/String} fn The method the event invokes.
                     * @param {Object} [scope] The scope for `fn`.
                     * @param {Object} [options] An object containing handler configuration.
                     * @deprecated 5.1 Use {@link #addListener} with the `priority` option instead.
                     */
                    addBeforeListener: function(eventName, fn, scope, options) {
                        return this.addListener(eventName, fn, scope, options, &#39;before&#39;);
                    },

<span id='Ext-mixin-Observable-method-addAfterListener'>                    /**
</span>                     * Appends an after-event handler.
                     *
                     * Same as {@link #addListener} with `order` set to `&#39;after&#39;`.
                     *
                     * @param {String/String[]/Object} eventName The name of the event to listen for.
                     * @param {Function/String} fn The method the event invokes.
                     * @param {Object} [scope] The scope for `fn`.
                     * @param {Object} [options] An object containing handler configuration.
                     * @deprecated 5.1 Use {@link #addListener} with the `priority` option instead.
                     */
                    addAfterListener: function(eventName, fn, scope, options) {
                        return this.addListener(eventName, fn, scope, options, &#39;after&#39;);
                    },

<span id='Ext-mixin-Observable-method-removeBeforeListener'>                    /**
</span>                     * Removes a before-event handler.
                     *
                     * Same as {@link #removeListener} with `order` set to `&#39;before&#39;`.
                     *
                     * @param {String/String[]/Object} eventName The name of the event the handler was associated with.
                     * @param {Function/String} fn The handler to remove.
                     * @param {Object} [scope] The scope originally specified for `fn`.
                     * @param {Object} [options] Extra options object.
                     * @deprecated 5.1 Use {@link #removeListener} instead.
                     */
                    removeBeforeListener: function(eventName, fn, scope, options) {
                        return this.removeListener(eventName, fn, scope, options, &#39;before&#39;);
                    },

<span id='Ext-mixin-Observable-method-removeAfterListener'>                    /**
</span>                     * Removes a before-event handler.
                     *
                     * Same as {@link #removeListener} with `order` set to `&#39;after&#39;`.
                     *
                     * @param {String/String[]/Object} eventName The name of the event the handler was associated with.
                     * @param {Function/String} fn The handler to remove.
                     * @param {Object} [scope] The scope originally specified for `fn`.
                     * @param {Object} [options] Extra options object.
                     * @deprecated 5.1 Use {@link #removeListener} instead.
                     */
                    removeAfterListener: function(eventName, fn, scope, options) {
                        return this.removeListener(eventName, fn, scope, options, &#39;after&#39;);
                    },

<span id='Ext-mixin-Observable-method-onBefore'>                    /**
</span>                     * @method
                     * Alias for {@link #addBeforeListener}.
                     * @inheritdoc Ext.mixin.Observable#addBeforeListener
                     * @deprecated 5.1 Use {@link #on} instead.
                     */
                    onBefore: &#39;addBeforeListener&#39;,
<span id='Ext-mixin-Observable-method-onAfter'>                    /**
</span>                     * @method
                     * Alias for {@link #addAfterListener}.
                     * @inheritdoc Ext.mixin.Observable#addAfterListener
                     * @deprecated 5.1 Use {@link #on} instead.
                     */
                    onAfter: &#39;addAfterListener&#39;,
<span id='Ext-mixin-Observable-method-unBefore'>                    /**
</span>                     * @method
                     * Alias for {@link #removeBeforeListener}.
                     * @inheritdoc Ext.mixin.Observable#removeBeforeListener
                     * @deprecated 5.1 Use {@link #un} instead.
                     */
                    unBefore: &#39;removeBeforeListener&#39;,
<span id='Ext-mixin-Observable-method-unAfter'>                    /**
</span>                     * @method
                     * Alias for {@link #removeAfterListener}.
                     * @inheritdoc Ext.mixin.Observable#removeAfterListener
                     * @deprecated 5.1 Use {@link #un} instead.
                     */
                    unAfter: &#39;removeAfterListener&#39;
                }
            }
        }
    };
}, function() {
    var Observable = this,
        proto = Observable.prototype,
        HasListeners = function () {},
        prepareMixin = function (T) {
            if (!T.HasListeners) {
                var proto = T.prototype;
                // Keep track of whether we were added via a mixin or not, this becomes
                // important later when discovering merged listeners on the class.
                proto.$observableMixedIn = 1;
                // Classes that use us as a mixin (best practice) need to be prepared.
                Observable.prepareClass(T, this);

                // Now that we are mixed in to class T, we need to watch T for derivations
                // and prepare them also.
                T.onExtended(function (U, data) {
                    //&lt;debug&gt;
                    Ext.classSystemMonitor &amp;&amp; Ext.classSystemMonitor(&#39;extend mixin&#39;, arguments);
                    //&lt;/debug&gt;

                    Observable.prepareClass(U, null, data);
                });

                // Also, if a class uses us as a mixin and that class is then used as
                // a mixin, we need to be notified of that as well.
                if (proto.onClassMixedIn) {
                    // play nice with other potential overrides...
                    Ext.override(T, {
                        onClassMixedIn: function (U) {
                            prepareMixin.call(this, U);
                            this.callParent(arguments);
                        }
                    });
                } else {
                    // just us chickens, so add the method...
                    proto.onClassMixedIn = function (U) {
                        prepareMixin.call(this, U);
                    };
                }
            }

            superOnClassMixedIn.call(this, T);
        },
        // We are overriding the onClassMixedIn of Ext.Mixin. Save a reference to it
        // so we can call it after our onClassMixedIn.
        superOnClassMixedIn = proto.onClassMixedIn;

    HasListeners.prototype = {
        //$$: 42  // to make sure we have a proper prototype
        _decr_: function (ev) {
            if (! --this[ev]) {
                // Delete this entry, since 0 does not mean no one is listening, just
                // that no one is *directly* listening. This allows the eventBus or
                // class observers to &quot;poke&quot; through and expose their presence.
                delete this[ev];
            }
        },
        _incr_: function (ev) {
            if (this.hasOwnProperty(ev)) {
                // if we already have listeners at this level, just increment the count...
                ++this[ev];
            } else {
                // otherwise, start the count at 1 (which hides whatever is in our prototype
                // chain)...
                this[ev] = 1;
            }
        }
    };

    proto.HasListeners = Observable.HasListeners = HasListeners;

    Observable.createAlias({
<span id='Ext-mixin-Observable-method-on'>        /**
</span>         * @method
         * @inheritdoc Ext.util.Observable#addListener
         */
        on: &#39;addListener&#39;,
<span id='Ext-mixin-Observable-method-un'>        /**
</span>         * @method
         * Shorthand for {@link #removeListener}.
         * @inheritdoc Ext.util.Observable#removeListener
         */
        un: &#39;removeListener&#39;,
<span id='Ext-mixin-Observable-method-mon'>        /**
</span>         * @method
         * Shorthand for {@link #addManagedListener}.
         * @inheritdoc Ext.util.Observable#addManagedListener
         */
        mon: &#39;addManagedListener&#39;,
<span id='Ext-mixin-Observable-method-mun'>        /**
</span>         * @method
         * Shorthand for {@link #removeManagedListener}.
         * @inheritdoc Ext.util.Observable#removeManagedListener
         */
        mun: &#39;removeManagedListener&#39;,
<span id='Ext-mixin-Observable-method-setListeners'>        /**
</span>         * @method
         * An alias for {@link #addListener}.  In versions prior to 5.1, {@link #listeners}
         * had a generated setter which could be called to add listeners.  In 5.1 the listeners
         * config is not processed using the config system and has no generated setter, so
         * this method is provided for backward compatibility.  The preferred way of
         * adding listeners is to use the {@link #on} method.
         * @param {Object} listeners The listeners
         */
        setListeners: &#39;addListener&#39;
    });

    //deprecated, will be removed in 5.0
    Observable.observeClass = Observable.observe;

    // this is considered experimental (along with beforeMethod, afterMethod, removeMethodListener?)
    // allows for easier interceptor and sequences, including cancelling and overwriting the return value of the call
    // private
    function getMethodEvent(method){
        var e = (this.methodEvents = this.methodEvents || {})[method],
            returnValue,
            v,
            cancel,
            obj = this,
            makeCall;

        if (!e) {
            this.methodEvents[method] = e = {};
            e.originalFn = this[method];
            e.methodName = method;
            e.before = [];
            e.after = [];

            makeCall = function(fn, scope, args){
                if((v = fn.apply(scope || obj, args)) !== undefined){
                    if (typeof v == &#39;object&#39;) {
                        if(v.returnValue !== undefined){
                            returnValue = v.returnValue;
                        }else{
                            returnValue = v;
                        }
                        cancel = !!v.cancel;
                    }
                    else
                        if (v === false) {
                            cancel = true;
                        }
                        else {
                            returnValue = v;
                        }
                }
            };

            this[method] = function(){
                var args = Array.prototype.slice.call(arguments, 0),
                    b, i, len;
                returnValue = v = undefined;
                cancel = false;

                for(i = 0, len = e.before.length; i &lt; len; i++){
                    b = e.before[i];
                    makeCall(b.fn, b.scope, args);
                    if (cancel) {
                        return returnValue;
                    }
                }

                if((v = e.originalFn.apply(obj, args)) !== undefined){
                    returnValue = v;
                }

                for(i = 0, len = e.after.length; i &lt; len; i++){
                    b = e.after[i];
                    makeCall(b.fn, b.scope, args);
                    if (cancel) {
                        return returnValue;
                    }
                }
                return returnValue;
            };
        }
        return e;
    }

    Ext.apply(proto, {
        onClassMixedIn: prepareMixin,

        // these are considered experimental
        // allows for easier interceptor and sequences, including cancelling and overwriting the return value of the call
        // adds an &#39;interceptor&#39; called before the original method
        beforeMethod : function(method, fn, scope){
            getMethodEvent.call(this, method).before.push({
                fn: fn,
                scope: scope
            });
        },

        // adds a &#39;sequence&#39; called after the original method
        afterMethod : function(method, fn, scope){
            getMethodEvent.call(this, method).after.push({
                fn: fn,
                scope: scope
            });
        },

        removeMethodListener: function(method, fn, scope){
            var e = this.getMethodEvent(method),
                i, len;
            for(i = 0, len = e.before.length; i &lt; len; i++){
                if(e.before[i].fn == fn &amp;&amp; e.before[i].scope == scope){
                    Ext.Array.erase(e.before, i, 1);
                    return;
                }
            }
            for(i = 0, len = e.after.length; i &lt; len; i++){
                if(e.after[i].fn == fn &amp;&amp; e.after[i].scope == scope){
                    Ext.Array.erase(e.after, i, 1);
                    return;
                }
            }
        },

        toggleEventLogging: function(toggle) {
            Ext.util.Observable[toggle ? &#39;capture&#39; : &#39;releaseCapture&#39;](this, function(en) {
                if (Ext.isDefined(Ext.global.console)) {
                    Ext.global.console.log(en, arguments);
                }
            });
        }
    });
});
</pre>
</body>
</html>
