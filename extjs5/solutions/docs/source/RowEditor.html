<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Currently has the following issues:
// - Does not handle postEditValue
// - Fields without editors need to sync with their values in Store
// - starting to edit another record while already editing and dirty should probably prevent it
// - aggregating validation messages
// - tabIndex is not managed bc we leave elements in dom, and simply move via positioning
// - layout issues when changing sizes/width while hidden (layout bug)

<span id='Ext-grid-RowEditor'>/**
</span> * Internal utility class used to provide row editing functionality. For developers, they should use
 * the RowEditing plugin to use this functionality with a grid.
 *
 * @private
 */
Ext.define(&#39;Ext.grid.RowEditor&#39;, {
    extend: &#39;Ext.form.Panel&#39;,
    alias: &#39;widget.roweditor&#39;,
    requires: [
        &#39;Ext.tip.ToolTip&#39;,
        &#39;Ext.util.KeyNav&#39;,
        &#39;Ext.grid.RowEditorButtons&#39;
    ],

<span id='Ext-grid-RowEditor-property-saveBtnText'>    //&lt;locale&gt;
</span>    saveBtnText  : &#39;Update&#39;,
<span id='Ext-grid-RowEditor-property-cancelBtnText'>    //&lt;/locale&gt;
</span>    //&lt;locale&gt;
    cancelBtnText: &#39;Cancel&#39;,
<span id='Ext-grid-RowEditor-property-errorsText'>    //&lt;/locale&gt;
</span>    //&lt;locale&gt;
    errorsText: &#39;Errors&#39;,
<span id='Ext-grid-RowEditor-property-dirtyText'>    //&lt;/locale&gt;
</span>    //&lt;locale&gt;
    dirtyText: &#39;You need to commit or cancel your changes&#39;,
<span id='Ext-grid-RowEditor-property-lastScrollLeft'>    //&lt;/locale&gt;
</span>
    lastScrollLeft: 0,
<span id='Ext-grid-RowEditor-property-lastScrollTop'>    lastScrollTop: 0,
</span>
<span id='Ext-grid-RowEditor-cfg-border'>    border: false,
</span>
<span id='Ext-grid-RowEditor-property-_wrapCls'>    _wrapCls: Ext.baseCSSPrefix + &#39;grid-row-editor-wrap&#39;,
</span>
<span id='Ext-grid-RowEditor-property-errorCls'>    errorCls: Ext.baseCSSPrefix + &#39;grid-row-editor-errors-item&#39;,
</span><span id='Ext-grid-RowEditor-property-buttonUI'>    buttonUI: &#39;default&#39;,
</span>
<span id='Ext-grid-RowEditor-cfg-hideMode'>    // Change the hideMode to offsets so that we get accurate measurements when
</span>    // the roweditor is hidden for laying out things like a TriggerField.
    hideMode: &#39;offsets&#39;,

<span id='Ext-grid-RowEditor-method-initComponent'>    initComponent: function() {
</span>        var me = this,
            grid = me.editingPlugin.grid,
            Container = Ext.container.Container,
            form, normalCt, lockedCt;

        me.cls = Ext.baseCSSPrefix + &#39;grid-editor &#39; + Ext.baseCSSPrefix + &#39;grid-row-editor&#39;;

        me.layout = {
            type: &#39;hbox&#39;,
            align: &#39;middle&#39;
        };

        me.lockable = grid.lockable;

        // Create field containing structure for when editing a lockable grid.
        if (me.lockable) {
            me.items = [
                // Locked columns container shrinkwraps the fields
                lockedCt = me.lockedColumnContainer = new Container({
                    id: grid.id + &#39;-locked-editor-cells&#39;,
                    scrollable: {
                        x: false,
                        y: false
                    },
                    layout: {
                        type: &#39;hbox&#39;,
                        align: &#39;middle&#39;
                    },
                    // Locked grid has a border, we must be exactly the same width
                    margin: &#39;0 1 0 0&#39;
                }),

                // Normal columns container flexes the remaining RowEditor width
                normalCt = me.normalColumnContainer = new Container({
                    // not user scrollable, but needs a Scroller instance for syncing with view
                    scrollable: {
                        x: false,
                        y: false
                    },
                    flex: 1,
                    id: grid.id + &#39;-normal-editor-cells&#39;,
                    layout: {
                        type: &#39;hbox&#39;,
                        align: &#39;middle&#39;
                    }
                })
            ];

            // keep horizontal position of fields in sync with view&#39;s horizontal scroll position
            lockedCt.getScrollable().addPartner(grid.lockedGrid.view.getScrollable(), &#39;x&#39;);
            normalCt.getScrollable().addPartner(grid.normalGrid.view.getScrollable(), &#39;x&#39;);
        } else {
            // initialize a scroller instance for maintaining horizontal scroll position
            me.setScrollable({
                x: false,
                y: false
            });

            // keep horizontal position of fields in sync with view&#39;s horizontal scroll position
            me.getScrollable().addPartner(grid.view.getScrollable(), &#39;x&#39;);

            me.lockedColumnContainer = me.normalColumnContainer = me;
        }

        me.callParent(arguments);

        if (me.fields) {
            me.addFieldsForColumn(me.fields, true);
            me.insertColumnEditor(me.fields);
            delete me.fields;
        }

        me.mon(Ext.GlobalEvents, {
            scope: me,
            show: me.repositionIfVisible
        });
        
        form = me.getForm();
        form.on(&#39;validitychange&#39;, me.onValidityChange, me);
        form.on(&#39;errorchange&#39;, me.onErrorChange, me);
    },

<span id='Ext-grid-RowEditor-method-onGridResize'>    //
</span>    // Grid listener added when this is rendered.
    // Keep our containing element sized correctly
    //
    onGridResize: function() {
        var me = this,
            clientWidth = me.getClientWidth(),
            grid = me.editingPlugin.grid,
            gridBody = grid.body,
            btns = me.getFloatingButtons();

        me.wrapEl.setLocalX(gridBody.getOffsetsTo(grid)[0] + gridBody.getBorderWidth(&#39;l&#39;) - grid.el.getBorderWidth(&#39;l&#39;));
        
        me.setWidth(clientWidth);
        btns.setLocalX((clientWidth - btns.getWidth()) / 2);
        if (me.lockable) {
            me.lockedColumnContainer.setWidth(grid.lockedGrid.view.el.dom.clientWidth);
        }
    },
    
<span id='Ext-grid-RowEditor-method-syncAllFieldWidths'>    syncAllFieldWidths: function() {
</span>        var me = this;
        // In a locked grid, a RowEditor uses 2 inner containers, so need to use CQ to retrieve
        // configured editors which were stamped with the isEditorComponent property in Editing.createColumnField
        Ext.Array.each(me.query(&#39;[isEditorComponent]&#39;), function(editorComponent) {
            if (editorComponent.column.isVisible()) {
                me.onColumnShow(editorComponent.column);
            }
        }, me);    
    },

<span id='Ext-grid-RowEditor-method-syncFieldWidth'>    syncFieldWidth: function(column) {
</span>        var field = column.getEditor(),
            width;

        field._marginWidth = (field._marginWidth || field.el.getMargin(&#39;lr&#39;));
        width = column.getWidth() - field._marginWidth;
        field.setWidth(width);
        if (field.xtype === &#39;displayfield&#39;) {
            // displayfield must have the width set on the inputEl for ellipsis to work
            field.inputWidth = width;
        }
    },

<span id='Ext-grid-RowEditor-method-onValidityChange'>    onValidityChange: function(form, valid) {
</span>        this.updateButton(valid);
        this.isValid = valid;
    },

<span id='Ext-grid-RowEditor-method-onErrorChange'>    onErrorChange: function() {
</span>        var me = this,
            valid;

        if (me.errorSummary &amp;&amp; me.isVisible()) {
            valid = me.getForm().isValid();
            me[valid ? &#39;hideToolTip&#39; : &#39;showToolTip&#39;]();
        }
    },

<span id='Ext-grid-RowEditor-method-updateButton'>    updateButton: function(valid){
</span>        var buttons = this.floatingButtons; 
        if (buttons) {
            buttons.child(&#39;#update&#39;).setDisabled(!valid);
        } else {
            // set flag so we can disabled when created if needed
            this.updateButtonDisabled = !valid;
        }
    },

<span id='Ext-grid-RowEditor-method-afterRender'>    afterRender: function() {
</span>        var me = this,
            plugin = me.editingPlugin,
            grid = plugin.grid,
            view = grid.lockable ? grid.normalGrid.view : grid.view;

        me.callParent(arguments);

        // The scrollingViewEl is the TableView which scrolls
        me.scrollingView = view;
        me.scrollingViewEl = view.el;
        view.on(&#39;scroll&#39;, me.onViewScroll, me);

        // Prevent from bubbling click events to the grid view
        me.mon(me.el, {
            click: Ext.emptyFn,
            stopPropagation: true
        });

        // Ensure that the editor width always matches the total header width
        me.mon(grid, &#39;resize&#39;, me.onGridResize, me);

        if (me.lockable) {
            grid.lockedGrid.view.on(&#39;resize&#39;, &#39;onGridResize&#39;, me);
        }

        me.el.swallowEvent([
            &#39;keypress&#39;,
            &#39;keydown&#39;
        ]);

        me.initKeyNav();

        me.mon(plugin.view, {
            beforerefresh: me.onBeforeViewRefresh,
            refresh: me.onViewRefresh,
            itemremove: me.onViewItemRemove,
            scope: me
        });

        // Prevent trying to reposition while we set everything up
        me.preventReposition = true;
        me.syncAllFieldWidths();
        delete me.preventReposition;    
    },

<span id='Ext-grid-RowEditor-method-initKeyNav'>    initKeyNav: function() {
</span>        var me = this,
            plugin = me.editingPlugin;

        me.keyNav = new Ext.util.KeyNav(me.el, {
            enter: plugin.onEnterKey,
            esc: plugin.onEscKey,
            scope: plugin
        });
    },

<span id='Ext-grid-RowEditor-method-onBeforeViewRefresh'>    onBeforeViewRefresh: function(view) {
</span>        var me = this,
            viewDom = view.el.dom;

        if (me.el.dom.parentNode === viewDom) {
            viewDom.removeChild(me.el.dom);
        }
    },

<span id='Ext-grid-RowEditor-method-onViewRefresh'>    onViewRefresh: function(view) {
</span>        var me = this,
            context = me.context,
            row;

        // Recover our row node after a view refresh
        if (context &amp;&amp; (row = view.getRow(context.record))) {
            context.row = row;
            me.reposition();
            if (me.tooltip &amp;&amp; me.tooltip.isVisible()) {
                me.tooltip.setTarget(context.row);
            }
        } else {
            me.editingPlugin.cancelEdit();
        }
    },

<span id='Ext-grid-RowEditor-method-onViewItemRemove'>    onViewItemRemove: function(record, index, item, view) {
</span>
        // If the itemremove is due to refreshing, ignore it.
        // If the row for the current context record has gone after the
        // refresh, editing will be canceled there. See onViewRefresh above.
        if (!view.refreshing) {
            var context = this.context;
            if (context &amp;&amp; record === context.record) {
                // if the record being edited was removed, cancel editing
                this.editingPlugin.cancelEdit();
            }
        }
    },

<span id='Ext-grid-RowEditor-method-onViewScroll'>    onViewScroll: function() {
</span>        var me = this,
            viewEl = me.editingPlugin.view.el,
            scrollingView = me.scrollingView,
            scrollTop  = scrollingView.getScrollY(),
            scrollLeft = scrollingView.getScrollX(),
            scrollTopChanged = scrollTop !== me.lastScrollTop,
            row;

        me.lastScrollTop  = scrollTop;
        me.lastScrollLeft = scrollLeft;
        if (me.isVisible()) {
            row = Ext.getDom(me.context.row);

            // Only reposition if the row is in the DOM (buffered rendering may mean the context row is not there)
            if (row &amp;&amp; viewEl.contains(row)) {
                if (scrollTopChanged) {

                    // The row element in the context may be stale due to buffered rendering removing out-of-view rows, then re-inserting newly rendered ones
                    me.context.row = row;
                    me.reposition(null, true);
                    if ((me.tooltip &amp;&amp; me.tooltip.isVisible()) || me.hiddenTip) {
                        me.repositionTip();
                    }

                    me.syncEditorClip();
                }
            }
            // If row is NOT in the DOM, ensure the editor is out of sight
            else {
                me.setLocalY(-400);
            }
        }
    },

<span id='Ext-grid-RowEditor-method-onColumnResize'>    onColumnResize: function(column, width) {
</span>        var me = this;

        if (me.rendered &amp;&amp; !me.editingPlugin.reconfiguring) {
            // Need to ensure our lockable/normal horizontal scrollrange is set
            me.onGridResize();
            me.onViewScroll();
            if (!column.isGroupHeader) {
                me.syncFieldWidth(column);
                me.repositionIfVisible();
            }
        }
    },

<span id='Ext-grid-RowEditor-method-onColumnHide'>    onColumnHide: function(column) {
</span>        if (!this.editingPlugin.reconfiguring &amp;&amp; !column.isGroupHeader) {
            column.getEditor().hide();
            this.repositionIfVisible();
        }
    },

<span id='Ext-grid-RowEditor-method-onColumnShow'>    onColumnShow: function(column) {
</span>        var me = this;

        if (me.rendered &amp;&amp; !me.editingPlugin.reconfiguring &amp;&amp; !column.isGroupHeader &amp;&amp; column.getEditor) {
            column.getEditor().show();
            me.syncFieldWidth(column);
            if (!me.preventReposition) {
                this.repositionIfVisible();
            }
        }
    },

<span id='Ext-grid-RowEditor-method-onColumnMove'>    onColumnMove: function(column, fromIdx, toIdx) {
</span>        var me = this,
            locked = column.isLocked(),
            fieldContainer = locked ? me.lockedColumnContainer : me.normalColumnContainer,
            columns, i, len, after, offset;

        // If moving a group, move each leaf header
        if (column.isGroupHeader) {
            Ext.suspendLayouts();
            after = toIdx &gt; fromIdx;
            offset = after ? 1 : 0;
            columns = column.getGridColumns();
            for (i = 0, len = columns.length; i &lt; len; ++i) {    
                column = columns[i];
                toIdx = column.getIndex();
                if (after) {
                    ++offset;
                }
                me.setColumnEditor(column, toIdx + offset, fieldContainer);
            }
            Ext.resumeLayouts(true);
        } else {
            me.setColumnEditor(column, column.getIndex(), fieldContainer);
        }
    },

<span id='Ext-grid-RowEditor-method-setColumnEditor'>    setColumnEditor: function(column, idx, fieldContainer) {
</span>        this.addFieldsForColumn(column);
        fieldContainer.insert(idx, column.getEditor());
    },

<span id='Ext-grid-RowEditor-method-onColumnAdd'>    onColumnAdd: function(column) {
</span>
        // If a column header added, process its leaves
        if (column.isGroupHeader) {
            column = column.getGridColumns();
        }
        //this.preventReposition = true;
        this.addFieldsForColumn(column);
        this.insertColumnEditor(column);
        this.preventReposition = false;
    },

<span id='Ext-grid-RowEditor-method-insertColumnEditor'>    insertColumnEditor: function(column) {
</span>        var me = this,
            fieldContainer,
            len, i;

        if (Ext.isArray(column)) {
            for (i = 0, len = column.length; i &lt; len; i++) {
                me.insertColumnEditor(column[i]);
            }
            return;
        }

        if (!column.getEditor) {
            return;
        }

        fieldContainer = column.isLocked() ? me.lockedColumnContainer : me.normalColumnContainer;

        // Insert the column&#39;s field into the editor panel.
        fieldContainer.insert(column.getIndex(), column.getEditor());
        me.needsSyncFieldWidths = true;
    },

<span id='Ext-grid-RowEditor-method-destroyColumnEditor'>    destroyColumnEditor: function(column) {
</span>        var me = this,
            field,
            len, i;

        if (Ext.isArray(column)) {
            for (i = 0, len = column.length; i &lt; len; i++) {
                me.removeColumnEditor(column[i]);
            }
            return;
        }

        if (column.hasEditor() &amp;&amp; (field = column.getEditor())) {
            field.destroy();
        }
    },

<span id='Ext-grid-RowEditor-method-getFloatingButtons'>    getFloatingButtons: function() {
</span>        var me = this,
            btns = me.floatingButtons;

        if (!btns) {
            me.floatingButtons = btns = new Ext.grid.RowEditorButtons({
                rowEditor: me
            });
        }
        return btns;
    },

<span id='Ext-grid-RowEditor-method-repositionIfVisible'>    repositionIfVisible: function(c) {
</span>        var me = this,
            view = me.view;

        // If we&#39;re showing ourselves, jump out
        // If the component we&#39;re showing doesn&#39;t contain the view
        if (c &amp;&amp; (c === me || !c.el.isAncestor(view.el))) {
            return;
        }

        if (me.isVisible() &amp;&amp; view.isVisible(true)) {
            me.reposition();
        }
    },

<span id='Ext-grid-RowEditor-method-isLayoutChild'>    isLayoutChild: function(ownerCandidate) {
</span>        // RowEditor is not a floating component, but won&#39;t be laid out by the grid
        return false;
    },

<span id='Ext-grid-RowEditor-method-getRefOwner'>    getRefOwner: function() {
</span>        return this.editingPlugin.grid;
    },

<span id='Ext-grid-RowEditor-method-getRefItems'>    getRefItems: function(deep) {
</span>        var me = this,
            result;

        if (me.lockable) {
            // refItems must include ALL children. Must include the two containers
            // because we don&#39;t know what is being searched for.
            result = [me.lockedColumnContainer];
            result.push.apply(result, me.lockedColumnContainer.getRefItems(deep));
            result.push(me.normalColumnContainer);
            result.push.apply(result, me.normalColumnContainer.getRefItems(deep));
        } else {
            result = me.callParent(arguments);
        }
        result.push.apply(result, me.getFloatingButtons().getRefItems(deep));
        return result;
    },

<span id='Ext-grid-RowEditor-method-reposition'>    reposition: function(animateConfig, fromScrollHandler) {
</span>        var me = this,
            context = me.context,
            row = context &amp;&amp; context.row,
            yOffset = 0,
            wrapEl = me.wrapEl,
            rowTop,
            localY,
            deltaY,
            afterPosition;

        // Position this editor if the context row is rendered (buffered rendering may mean that it&#39;s not in the DOM at all)
        if (row &amp;&amp; Ext.isElement(row)) {

            deltaY = me.syncButtonPosition(me.getScrollDelta());

            if (!me.editingPlugin.grid.rowLines) { 
                // When the grid does not have rowLines we add a bottom border to the previous
                // row when the row is focused, but subtract the border width from the 
                // top padding to keep the row from changing size.  This adjusts the top offset
                // of the cell edtor to account for the added border.
                yOffset = -parseInt(Ext.fly(row).first().getStyle(&#39;border-bottom-width&#39;), 10);
            }
            rowTop = me.calculateLocalRowTop(row);
            localY = me.calculateEditorTop(rowTop) + yOffset;

            // If not being called from scroll handler...
            // If the editor&#39;s top will end up above the fold
            // or the bottom will end up below the fold,
            // organize an afterPosition handler which will bring it into view and focus the correct input field
            if (!fromScrollHandler) {
                afterPosition = function() {
                    if (deltaY) {
                        me.scrollingViewEl.scrollBy(0, deltaY, true);
                    }
                    me.focusColumnField(context.column);
                };
            }

            me.syncEditorClip();

            // Get the y position of the row relative to its top-most static parent.
            // offsetTop will be relative to the table, and is incorrect
            // when mixed with certain grid features (e.g., grouping).
            if (animateConfig) {
                wrapEl.animate(Ext.applyIf({
                    to: {
                        top: localY
                    },
                    duration: animateConfig.duration || 125,
                    callback: afterPosition
                }, animateConfig));
            } else {
                wrapEl.setLocalY(localY);
                if (afterPosition) {
                    afterPosition();
                }
            }
        }
    },

<span id='Ext-grid-RowEditor-method-getScrollDelta'>    /**
</span>     * @private
     * Returns the scroll delta required to scroll the context row into view in order to make
     * the whole of this editor visible.
     * @return {Number} the scroll delta. Zero if scrolling is not required.
     */
    getScrollDelta: function() {
        var me = this,
            scrollingViewDom = me.scrollingViewEl.dom,
            context = me.context,
            body = me.body,
            deltaY = 0;

        if (context) {
            deltaY = Ext.fly(context.row).getOffsetsTo(scrollingViewDom)[1];
            if (deltaY &lt; 0) {
                deltaY -= body.getBorderPadding().beforeY;
            }
            else if (deltaY &gt; 0) {
                deltaY = Math.max(deltaY + me.getHeight() + me.floatingButtons.getHeight() -
                    scrollingViewDom.clientHeight - body.getBorderWidth(&#39;b&#39;), 0);
                if (deltaY &gt; 0) {
                    deltaY -= body.getBorderPadding().afterY;
                }
            }
        }
        return deltaY;
    },

<span id='Ext-grid-RowEditor-method-calculateLocalRowTop'>    //
</span>    // Calculates the top pixel position of the passed row within the view&#39;s scroll space.
    // So in a large, scrolled grid, this could be several thousand pixels.
    //
    calculateLocalRowTop: function(row) {
        var grid = this.editingPlugin.grid;
        return Ext.fly(row).getOffsetsTo(grid)[1] - grid.el.getBorderWidth(&#39;t&#39;) + this.lastScrollTop;
    },

<span id='Ext-grid-RowEditor-method-calculateEditorTop'>    // Given the top pixel position of a row in the scroll space,
</span>    // calculate the editor top position in the view&#39;s encapsulating element.
    // This will only ever be in the visible range of the view&#39;s element.
    calculateEditorTop: function(rowTop) {
        return rowTop - this.body.getBorderPadding().beforeY - this.lastScrollTop;
    },

<span id='Ext-grid-RowEditor-method-getClientWidth'>    getClientWidth: function() {
</span>        var me = this,
            grid = me.editingPlugin.grid,
            result;

        if (me.lockable) {
            result =
               grid.lockedGrid.getWidth() +
               grid.normalGrid.view.el.dom.clientWidth;
        }
        else {
            result = grid.view.el.dom.clientWidth;
        }
        return result;
    },

<span id='Ext-grid-RowEditor-method-getEditor'>    getEditor: function(fieldInfo) {
</span>        var me = this;

        if (Ext.isNumber(fieldInfo)) {
            // In a locked grid, a RowEditor uses 2 inner containers, so need to use CQ to retrieve
            // configured editors which were stamped with the isEditorComponent property in Editing.createColumnField
            return me.query(&#39;[isEditorComponent]&#39;)[fieldInfo];
        } else if (fieldInfo.isHeader &amp;&amp; !fieldInfo.isGroupHeader) {
            return fieldInfo.getEditor();
        }
    },    

<span id='Ext-grid-RowEditor-method-addFieldsForColumn'>    addFieldsForColumn: function(column, initial) {
</span>        var me = this,
            i,
            length, field;

        if (Ext.isArray(column)) {
            for (i = 0, length = column.length; i &lt; length; i++) {
                me.addFieldsForColumn(column[i], initial);
            }
            return;
        }

        if (column.getEditor) {

            // Get a default display field if necessary
            field = column.getEditor(null, me.getDefaultFieldCfg());

            if (column.align === &#39;right&#39;) {
                field.fieldStyle = &#39;text-align:right&#39;;
            }

            if (column.xtype === &#39;actioncolumn&#39;) {
                field.fieldCls += &#39; &#39; + Ext.baseCSSPrefix + &#39;form-action-col-field&#39;;
            }

            if (me.isVisible() &amp;&amp; me.context) {
                if (field.is(&#39;displayfield&#39;)) {
                    me.renderColumnData(field, me.context.record, column);
                } else {
                    field.suspendEvents();
                    field.setValue(me.context.record.get(column.dataIndex));
                    field.resumeEvents();
                }
            }
            if (column.hidden) {
                me.onColumnHide(column);
            } else if (column.rendered &amp;&amp; !initial) {
                // Setting after initial render
                me.onColumnShow(column);
            }
        }
    },
    
<span id='Ext-grid-RowEditor-method-getDefaultFieldCfg'>    getDefaultFieldCfg: function() {
</span>        return {
            xtype: &#39;displayfield&#39;,
            // Override Field&#39;s implementation so that the default display fields will not return values. This is done because
            // the display field will pick up column renderers from the grid.
            getModelData: function() {
                return null;
            }
        };
    },

<span id='Ext-grid-RowEditor-method-loadRecord'>    loadRecord: function(record) {
</span>        var me     = this,
            form   = me.getForm(),
            fields = form.getFields(),
            items  = fields.items,
            length = items.length,
            i, displayFields,
            isValid, item;

        // temporarily suspend events on form fields before loading record to prevent the fields&#39; change events from firing
        for (i = 0; i &lt; length; i++) {
            item = items[i];
            item.suspendEvents();
            item.reset();
        }

        form.loadRecord(record);

        for (i = 0; i &lt; length; i++) {
            items[i].resumeEvents();
        }

        // Because we suspend the events, none of the field events will get propagated to
        // the form, so the valid state won&#39;t be correct.
        if (form.hasInvalidField() === form.wasValid) {
            delete form.wasValid;
        }
        isValid = form.isValid();
        if (me.errorSummary) {
            if (isValid) {
                me.hideToolTip();
            } else {
                me.showToolTip();
            }
        }
        me.updateButton(isValid);

        // render display fields so they honor the column renderer/template
        displayFields = me.query(&#39;&gt;displayfield&#39;);
        length = displayFields.length;

        for (i = 0; i &lt; length; i++) {
            me.renderColumnData(displayFields[i], record);
        }
    },

<span id='Ext-grid-RowEditor-method-renderColumnData'>    renderColumnData: function(field, record, activeColumn) {
</span>        var me = this,
            grid = me.editingPlugin.grid,
            headerCt = grid.headerCt,
            view = me.scrollingView,
            store = view.dataSource,
            column = activeColumn || field.column,
            value = record.get(column.dataIndex),
            renderer = column.editRenderer || column.renderer,
            metaData,
            rowIdx,
            colIdx,
            scope = (column.usingDefaultRenderer &amp;&amp; !column.scope) ? column : column.scope;

        // honor our column&#39;s renderer (TemplateHeader sets renderer for us!)
        if (renderer) {
            metaData = { tdCls: &#39;&#39;, style: &#39;&#39; };
            rowIdx = store.indexOf(record);
            colIdx = headerCt.getHeaderIndex(column);

            value = renderer.call(
                scope || headerCt.ownerCt,
                value,
                metaData,
                record,
                rowIdx,
                colIdx,
                store,
                view
            );
        }

        field.setRawValue(value);
    },

<span id='Ext-grid-RowEditor-method-beforeEdit'>    beforeEdit: function() {
</span>        var me = this,
            scrollDelta;

        if (me.isVisible() &amp;&amp; me.errorSummary &amp;&amp; !me.autoCancel &amp;&amp; me.isDirty()) {

            // Scroll the visible RowEditor that is in error state back into view
            scrollDelta = me.getScrollDelta();
            if (scrollDelta) {
                me.scrollingViewEl.scrollBy(0, scrollDelta, true);
            }
            me.showToolTip();
            return false;
        }
    },

<span id='Ext-grid-RowEditor-method-startEdit'>    /**
</span>     * Start editing the specified grid at the specified position.
     * @param {Ext.data.Model} record The Store data record which backs the row to be edited.
     * @param {Ext.data.Model} columnHeader The Column object defining the column to be focused
     */
    startEdit: function(record, columnHeader) {
        var me = this,
            editingPlugin = me.editingPlugin,
            grid = editingPlugin.grid,
            context = me.context = editingPlugin.context,
            alreadyVisible = me.isVisible(),
            wrapEl = me.wrapEl;

        // Ensure that the render operation does not lay out
        // The show call will update the layout
        Ext.suspendLayouts();

        if (!me.rendered) {
            me.width = me.getClientWidth();
            me.render(grid.el, grid.el.dom.firstChild);
            // The wrapEl is a container for the editor and buttons.  We use a wrap el
            // (instead of rendering the buttons inside the editor) so that the editor and
            // buttons can be clipped separately when overflowing.
            // See https://sencha.jira.com/browse/EXTJS-13851
            wrapEl = me.wrapEl = me.el.wrap();
            // Change the visibilityMode to offsets so that we get accurate measurements
            // when the roweditor is hidden for laying out things like a TriggerField.
            wrapEl.setVisibilityMode(3);

            wrapEl.addCls(me._wrapCls);
            me.getFloatingButtons().render(wrapEl);
            // On first show we need to ensure that we have the scroll positions cached
            me.onViewScroll();
        }
        
        // Select at the clicked position.
        context.grid.getSelectionModel().selectByPosition({
            row: record,
            column: columnHeader
        });

        // Make sure the container el is correctly sized.
        me.onGridResize();

        // Reload the record data
        me.loadRecord(record);

        // Layout the form with the new content if we are already visible.
        // Otherwise, just allow resumption, and the show will update the layout.
        Ext.resumeLayouts(alreadyVisible);
        if (alreadyVisible) {
            me.reposition(true);
        } else {
            me.show();
        }
    },

<span id='Ext-grid-RowEditor-method-syncButtonPosition'>    // determines the amount by which the row editor will overflow, and flips the buttons
</span>    // to the top of the editor if the required scroll amount is greater than the available
    // scroll space. Returns the scrollDelta required to scroll the editor into view after
    // adjusting the button position.
    syncButtonPosition: function(scrollDelta) {
        var me = this,
            floatingButtons = me.getFloatingButtons(),
            scrollingView = me.scrollingView,
            overflow = me.getScrollDelta() - (scrollingView.getScrollable().getSize().y -
                scrollingView.getScrollY() - me.scrollingViewEl.dom.clientHeight);

        if (overflow &gt; 0) {
            if (!me._buttonsOnTop) {
                floatingButtons.setButtonPosition(&#39;top&#39;);
                me._buttonsOnTop = true;
            }
            scrollDelta = 0;
        } else if (me._buttonsOnTop !== false) {
            floatingButtons.setButtonPosition(&#39;bottom&#39;);
            me._buttonsOnTop = false;
        }

        return scrollDelta;
    },

<span id='Ext-grid-RowEditor-method-syncEditorClip'>    // since the editor is rendered to the grid el, it must be clipped when scrolled
</span>    // outside of the grid view area so that it does not overlap the scrollbar or docked items
    // Since safari&#39;s clip implementation does not accept negative values we cannot clip
    // both buttons and editor by setting clip on a single element, because it will result
    // in the buttons being hidden when they are positioned above the editor.
    // See https://sencha.jira.com/browse/EXTJS-13851
    // To work around this we render the buttons and editor to a wrapping element and clip
    // them separately.
    syncEditorClip: function() {
        var me = this,
            overflow = me.getScrollDelta(),
            el = me.el,
            floatingButtons = me.floatingButtons,
            btnEl = floatingButtons.el,
            max = Math.max,
            body, btnHeight, editorHeight;

        if (overflow) {
            // The editor is overflowing outside of the view area, either above or below
            me.isOverflowing = true;
            body = me.body;
            btnHeight = floatingButtons.getHeight();
            editorHeight = me.getHeight();

            max = Math.max;

            if (overflow &gt; 0) {
                // editor is overflowing the bottom of the view
                if (me._buttonsOnTop) {
                    overflow -= (btnHeight - body.getBorderWidth(&#39;b&#39;));
                    me.clipBottom(el, max(editorHeight - overflow), 0);
                    overflow -= (editorHeight - body.getBorderWidth(&#39;t&#39;));
                    if (overflow &gt; 0) {
                        me.clipBottom(btnEl, max(btnHeight - overflow, 0));
                    } else {
                        me.clearClip(btnEl);
                    }
                } else {
                    me.clipBottom(btnEl, max(btnHeight - overflow, 0));
                    overflow -= (btnHeight - body.getBorderWidth(&#39;b&#39;));
                    if (overflow &gt; 0) {
                        me.clipBottom(el, max(editorHeight - overflow, 0));
                    } else {
                        me.clearClip(el);
                    }
                }
            } else if (overflow &lt; 0) {
                // editor is overflowing the top of the view
                overflow = Math.abs(overflow);
                me.clipTop(el, overflow);


                overflow -= (editorHeight - body.getBorderWidth(&#39;b&#39;));
                if (overflow &gt; 0) {
                    me.clipTop(btnEl, overflow);
                } else {
                    me.clearClip(btnEl);
                }
            }
        } else if (me.isOverflowing) {
            me.clearClip(btnEl);
            me.clearClip(el);
            me.isOverflowing = false;
        }
    },

<span id='Ext-grid-RowEditor-method-focusColumnField'>    focusColumnField: function(column) {
</span>        var field, didFocus;
        
        if (column &amp;&amp; !column.isDestroyed) {   
            if (column.isVisible()) {
                field = this.getEditor(column);   
                if (field &amp;&amp; field.isFocusable(true)) {
                    didFocus = true;
                    field.focus();
                }
            }
            if (!didFocus) {
                this.focusColumnField(column.next());
            }
        }
    },

<span id='Ext-grid-RowEditor-method-cancelEdit'>    cancelEdit: function() {
</span>        var me     = this,
            form   = me.getForm(),
            fields = form.getFields(),
            items  = fields.items,
            length = items.length,
            i;

        me.hide();
        form.clearInvalid();

        // temporarily suspend events on form fields before reseting the form to prevent the fields&#39; change events from firing
        for (i = 0; i &lt; length; i++) {
            items[i].suspendEvents();
        }

        form.reset();

        for (i = 0; i &lt; length; i++) {
            items[i].resumeEvents();
        }
    },

<span id='Ext-grid-RowEditor-method-completeEdit'>    completeEdit: function() {
</span>        var me = this,
            form = me.getForm();

        if (!form.isValid()) {
            return false;
        }

        form.updateRecord(me.context.record);
        me.hide();
        return true;
    },

<span id='Ext-grid-RowEditor-method-onShow'>    onShow: function() {
</span>        var me = this;

        me.wrapEl.show();
        me.previousFocus = Ext.Element.getActiveElement();
        me.callParent(arguments);
        if (me.needsSyncFieldWidths) {
            me.suspendLayouts();
            me.syncAllFieldWidths();
            me.resumeLayouts(true);
        }
        delete me.needsSyncFieldWidths;

        me.reposition();
    },

<span id='Ext-grid-RowEditor-method-onHide'>    onHide: function() {
</span>        var me = this;

        // Prevent hiding from focusing the body element.
        if (me.el.contains(Ext.Element.getActiveElement())) {
            if (me.context) {
                me.context.view.grid.focus();
                me.context = null;
            } else {
                me.previousFocus.focus();
            }
        }
        me.wrapEl.hide();
        me.callParent(arguments);
        if (me.tooltip) {
            me.hideToolTip();
        }
    },

<span id='Ext-grid-RowEditor-method-onResize'>    onResize: function(width, height) {
</span>        this.wrapEl.setSize(width, height);
    },

<span id='Ext-grid-RowEditor-method-isDirty'>    isDirty: function() {
</span>        return this.getForm().isDirty();
    },

<span id='Ext-grid-RowEditor-method-getToolTip'>    getToolTip: function() {
</span>        var me = this,
            tip = me.tooltip,
            grid = me.editingPlugin.grid;

        if (!tip) {
            me.tooltip = tip = new Ext.tip.ToolTip({
                cls: Ext.baseCSSPrefix + &#39;grid-row-editor-errors&#39;,
                title: me.errorsText,
                autoHide: false,
                closable: true,
                closeAction: &#39;disable&#39;,
                anchor: &#39;left&#39;,
                anchorToTarget: true,
                constrainPosition: true,
                constrainTo: document.body
            });
            grid.add(tip);

            // Layout may change the grid&#39;s positioning.
            me.mon(grid, {
                afterlayout: me.onGridLayout,
                scope: me
            });
        }
        return tip;
    },

<span id='Ext-grid-RowEditor-method-hideToolTip'>    hideToolTip: function() {
</span>        var me = this,
            tip = me.getToolTip();
        if (tip.rendered) {
            tip.disable();
        }
        me.hiddenTip = false;
    },

<span id='Ext-grid-RowEditor-method-showToolTip'>    showToolTip: function() {
</span>        var me = this,
            tip = me.getToolTip();

        tip.update(me.getErrors());
        me.repositionTip();
        tip.enable();
    },

<span id='Ext-grid-RowEditor-method-onGridLayout'>    onGridLayout: function() {
</span>        if (this.tooltip &amp;&amp; this.tooltip.isVisible()) {
            this.repositionTip();
        }
    },

<span id='Ext-grid-RowEditor-method-repositionTip'>    repositionTip: function() {
</span>        var me = this,
            tip = me.getToolTip(),
            context = me.context,
            row = Ext.get(context.row),
            viewEl = me.scrollingViewEl,
            viewHeight = viewEl.dom.clientHeight,
            viewTop = me.lastScrollTop,
            viewBottom = viewTop + viewHeight,
            rowHeight = row.getHeight(),
            rowTop = row.getOffsetsTo(me.context.view.body)[1],
            rowBottom = rowTop + rowHeight;

        if (rowBottom &gt; viewTop &amp;&amp; rowTop &lt; viewBottom) {

            // Use the ToolTip&#39;s anchoring to get the left/right positioning correct with
            // respect to space available on the default (right) side.
            tip.anchorTarget = me.editingPlugin.grid.view.el;
            tip.mouseOffset = [0, row.getOffsetsTo(viewEl)[1]];

            // The tip will realign itself based upon its new offset
            tip.show()
            me.hiddenTip = false;
        } else {
            tip.hide();
            me.hiddenTip = true;
        }
    },

<span id='Ext-grid-RowEditor-method-getErrors'>    getErrors: function() {
</span>        var me        = this,
            errors    = [],
            fields    = me.query(&#39;&gt;[isFormField]&#39;),
            length    = fields.length,
            i, fieldErrors, field;

        for (i = 0; i &lt; length; i++) {
            field = fields[i];
            fieldErrors = field.getErrors();
            if (fieldErrors.length) {
                errors.push(me.createErrorListItem(fieldErrors[0], field.column.text));
            }
        }

        // Only complain about unsaved changes if all the fields are valid
        if (!errors.length &amp;&amp; !me.autoCancel &amp;&amp; me.isDirty()) {
            errors[0] = me.createErrorListItem(me.dirtyText);
        }

        return &#39;&lt;ul class=&quot;&#39; + Ext.baseCSSPrefix + &#39;list-plain&quot;&gt;&#39; + errors.join(&#39;&#39;) + &#39;&lt;/ul&gt;&#39;;
    },

<span id='Ext-grid-RowEditor-method-createErrorListItem'>    createErrorListItem: function(e, name) {
</span>        e = name ? name + &#39;: &#39; + e : e;
        return &#39;&lt;li class=&quot;&#39; + this.errorCls + &#39;&quot;&gt;&#39; + e + &#39;&lt;/li&gt;&#39;;
    },

<span id='Ext-grid-RowEditor-method-beforeDestroy'>    beforeDestroy: function(){
</span>        Ext.destroy(this.floatingButtons, this.tooltip);
        this.callParent();    
    },

<span id='Ext-grid-RowEditor-method-clipBottom'>    clipBottom: function(el, value) {
</span>        el.setStyle(&#39;clip&#39;, &#39;rect(0 auto &#39; + value + &#39;px 0)&#39;);
    },

<span id='Ext-grid-RowEditor-method-clipTop'>    clipTop: function(el, value) {
</span>        el.setStyle(&#39;clip&#39;, &#39;rect(&#39; + value + &#39;px, auto, auto, 0)&#39;);
    },

<span id='Ext-grid-RowEditor-method-clearClip'>    clearClip: function(el) {
</span>        el.setStyle(
            &#39;clip&#39;,
            Ext.isIE8 ? &#39;rect(-1000px auto 1000px auto)&#39; : &#39;auto&#39;
        );
    }
});
</pre>
</body>
</html>
