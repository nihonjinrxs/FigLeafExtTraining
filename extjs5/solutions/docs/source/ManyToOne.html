<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-data-schema-ManyToOne'>/**
</span> * This type of association describes the case where one entity is referenced by zero or
 * more other entities typically using a &quot;foreign key&quot; field.
 * 
 * The way this is defined is for one entity to have a field that holds the unique id (also
 * known as &quot;Primary Key&quot; or, more specifically, as the {@link Ext.data.Model#idProperty}
 * field) of the related entity. These fields have a {@link Ext.data.field.Field#reference}
 * in their definition. The value in the `reference` field of an entity instance holds the
 * value of the id of the related entity instance. Since many entities can hold the same
 * value in a `reference` field, this allows many entities to reference one entity.
 * OrderItem has a foreign key to Order.
 * 
 *      OrderItem -&gt; Order
 * 
 * OrderItem is on the &quot;left&quot; and Order is on the &quot;right&quot;. This is because the owner of
 * the foreign key is always on the &quot;left&quot;. Many OrderItems refer to one Order. The
 * default name of this association would be &quot;Order_OrderItems&quot;.
 * 
 *      var Order_OrderItems = {
 *          name: &#39;Order_OrderItems&#39;,
 *          owner: Order_OrderItems.right,
 *          left: {
 *              cls: OrderItem,
 *              type: &#39;OrderItem&#39;,
 *              association: Order_OrderItems,
 *              left: true,
 *              owner: false,
 *              autoLoad: true,
 *              isMany: true,
 *              inverse: Order_OrderItems.right,
 *              role: &#39;orderItems&#39;
 *          },
 *          right: {
 *              cls: Order,
 *              type: &#39;Order&#39;,
 *              association: Order_OrderItems,
 *              left: false,
 *              owner: true,
 *              autoLoad: true,
 *              isMany: false,
 *              inverse: Order_OrderItems.left,
 *              role: &#39;order&#39;
 *          }
 *      };
 *      
 *      OrderItem.associations.order = Order_OrderItems.left;
 *      Order.associations.orderItems = Order_OrderItems.right;
 */
Ext.define(&#39;Ext.data.schema.ManyToOne&#39;, {
    extend: &#39;Ext.data.schema.Association&#39;,

<span id='Ext-data-schema-ManyToOne-property-isManyToOne'>    isManyToOne: true,
</span>
<span id='Ext-data-schema-ManyToOne-property-isToOne'>    isToOne: true,
</span>
<span id='Ext-data-schema-ManyToOne-property-kind'>    kind: &#39;many-to-one&#39;,
</span>
<span id='Ext-data-schema-ManyToOne-property-Left'>    Left: Ext.define(null, {
</span>        extend: &#39;Ext.data.schema.Role&#39;,

        isMany: true,

        onDrop: function(rightRecord, session) {
            var me = this,
                store = me.getAssociatedItem(rightRecord),
                leftRecords, len, i, refs, id;

            if (store) {
                // Removing will cause the foreign key to be set to null.
                leftRecords = store.removeAll();
                if (leftRecords &amp;&amp; me.inverse.owner) {
                    // If we&#39;re a child, we need to destroy all the &quot;tickets&quot;
                    for (i = 0, len = leftRecords.length; i &lt; len; ++i) {
                        leftRecords[i].drop();
                    }
                }

                store.destroy();
                rightRecord[me.getStoreName()] = null;
            } else if (session) {
                leftRecords = session.getRefs(rightRecord, me);
                if (leftRecords) {
                    for (id in leftRecords) {
                        leftRecords[id].drop();
                    }
                }
            }
        },

        processUpdate: function(session, associationData) {
            var me = this,
                entityType = me.inverse.cls,
                items = associationData.R,
                id, rightRecord, store, leftRecords;

            if (items) {
                for (id in items) {
                    rightRecord = session.peekRecord(entityType, id);
                    if (rightRecord) {
                        leftRecords = session.getEntityList(me.cls, items[id]);
                        store = me.getAssociatedItem(rightRecord);
                        if (store) {
                            store.loadData(leftRecords);
                            store.complete = true;
                        } else {
                            // We don&#39;t have a store. Create it and add the records.
                            rightRecord[me.getterName](null, null, leftRecords);
                        }
                    } else {
                        session.onInvalidAssociationEntity(entityType, id);
                    }
                }
            }
        },

        findRecords: function(session, rightRecord, leftRecords) {
            var ret = leftRecords,
                refs = session.getRefs(rightRecord, this, true),
                leftRecord, id, i, len, seen;

            if (!rightRecord.phantom) {
                ret = [];
                if (refs) {
                    if (leftRecords) {
                        seen = {};
                        // Loop over the records returned by the server and
                        // check they all still belong
                        for (i = 0, len = leftRecords.length; i &lt; len; ++i) {
                            leftRecord = leftRecords[i];
                            id = leftRecord.id;
                            if (refs[id]) {
                                ret.push(leftRecord);
                            }
                            seen[id] = true;
                        }
                    }

                    // Loop over the expected set and include any missing records.
                    for (id in refs) {
                        if (!seen || !seen[id]) {
                            ret.push(refs[id]);
                        }
                    }
                }
            }
            return ret;
        },

        processLoad: function(store, rightRecord, leftRecords, session) {
            var ret = leftRecords;

            if (session) {
                ret = this.findRecords(session, rightRecord, leftRecords);
            }
            this.onLoadMany(rightRecord, ret, session);
            return ret;
        },

        adoptAssociated: function(rightRecord, session) {
            var store = this.getAssociatedItem(rightRecord),
                leftRecords, i, len;
            if (store) {
                store.setSession(session);
                leftRecords = store.getData().items;
                for (i = 0, len = leftRecords.length; i &lt; len; ++i) {
                    session.adopt(leftRecords[i]);
                }
            }
        },

        createGetter: function() {
            var me = this;
            return function (options, scope, leftRecords) {
                // &#39;this&#39; refers to the Model instance inside this function
                var session = this.session,
                    hadRecords = !!leftRecords;

                if (session) {
                    leftRecords = me.findRecords(session, this, leftRecords);
                    if (!hadRecords &amp;&amp; (!leftRecords || !leftRecords.length)) {
                        leftRecords = null;
                    }
                }
                return me.getAssociatedStore(this, options, scope, leftRecords, hadRecords);
            };
        },

        createSetter: null, // no setter for an isMany side

        onAddToMany: function (store, leftRecords) {
            this.syncFK(leftRecords, store.getAssociatedEntity(), false);
        },

        onLoadMany: function(rightRecord, leftRecords, session) {
            var instanceName = this.inverse.getInstanceName(),
                id = rightRecord.getId(),
                field = this.association.field,
                i, len, leftRecord, oldId, data, name;

            if (field) {
                for (i = 0, len = leftRecords.length; i &lt; len; ++i) {
                    leftRecord = leftRecords[i];
                    leftRecord[instanceName] = rightRecord;
                    if (field) {
                        name = field.name;
                        data = leftRecord.data;
                        oldId = data[name];
                        if (oldId !== id) {
                            data[name] = id;
                            if (session) {
                                session.updateReference(leftRecord, field, id, oldId);
                            }
                        }
                    }
                }
            }
        },

        onRemoveFromMany: function (store, leftRecords) {
            this.syncFK(leftRecords, store.getAssociatedEntity(), true);
        },

        read: function(rightRecord, node, fromReader, readOptions) {
            var me = this,
                // We use the inverse role here since we&#39;re setting ourselves
                // on the other record
                instanceName = me.inverse.getInstanceName(),
                result = me.callParent([ rightRecord, node, fromReader, readOptions ]),
                store, leftRecords, len, i;
            
            // Did the root exist in the data?
            if (result.getReadRoot()) {
                // Create the store and dump the data
                store = rightRecord[me.getterName](null, null, result.getRecords());
                // Inline associations should *not* arrive on the &quot;data&quot; object:
                delete rightRecord.data[me.role];

                leftRecords = store.getData().items;

                for (i = 0, len = leftRecords.length; i &lt; len; ++i) {
                    leftRecords[i][instanceName] = rightRecord;
                }
            }
        },

        syncFK: function (leftRecords, rightRecord, clearing) {
            // We are called to set things like the FK (ticketId) of an array of Comment
            // entities. The best way to do that is call the setter on the Comment to set
            // the Ticket. Since we are setting the Ticket, the name of that setter is on
            // our inverse role.

            var foreignKeyName = this.association.getFieldName(),
                setter = this.inverse.setterName, // setTicket
                i = leftRecords.length,
                id = rightRecord.getId(),
                different, leftRecord;

            while (i-- &gt; 0) {
                leftRecord = leftRecords[i];
                different = !leftRecord.isEqual(id, leftRecord.get(foreignKeyName));

                if (different !== clearing) {
                    // clearing === true
                    //      different === true  :: leave alone (not associated anymore)
                    //   ** different === false :: null the value (no longer associated)
                    //
                    // clearing === false
                    //   ** different === true  :: set the value (now associated)
                    //      different === false :: leave alone (already associated)
                    //
                    leftRecord.changingKey = true;
                    if (setter) {
                        leftRecord[setter](clearing ? null : rightRecord);
                    } else {
                        leftRecord.set(foreignKeyName, clearing ? null : id);
                    }
                    leftRecord.changingKey = false;
                }
            }
        }
    }),

<span id='Ext-data-schema-ManyToOne-property-Right'>    Right: Ext.define(null, {
</span>        extend: &#39;Ext.data.schema.Role&#39;,

        left: false,
        side: &#39;right&#39;,

        onDrop: function(leftRecord, session) {
            // By virtue of being dropped, this record will be removed
            // from any stores it belonged to. The only case we have
            // to worry about is if we have a session but were not yet
            // part of any stores, so we need to clear the foreign key.
            var field = this.association.field;
            if (field) {
                leftRecord.set(field.name, null);
            }
            leftRecord[this.getInstanceName()] = null;
        },

        createGetter: function() {
            // As the target of the FK (say &quot;ticket&quot; for the Comment entity) this
            // getter is responsible for getting the entity referenced by the FK value.
            var me = this;

            return function (options, scope) {
                // &#39;this&#39; refers to the Comment instance inside this function
                return me.doGetFK(this, options, scope);
            };
        },
        
        createSetter: function() {
            var me = this;

            return function (rightRecord, options, scope) {
                // &#39;this&#39; refers to the Comment instance inside this function
                return me.doSetFK(this, rightRecord, options, scope);
            };
        },

        checkMembership: function(session, leftRecord) {
            var field = this.association.field,
                store;

            store = this.getSessionStore(session, leftRecord.get(field.name));
            // Check we&#39;re not in the middle of an add to the store.
            if (store &amp;&amp; !store.contains(leftRecord)) {
                store.add(leftRecord);
            }
        },

        onValueChange: function(leftRecord, session, newValue, oldValue) {
            // If we have a session, we may be able to find the new store this belongs to
            // If not, the best we can do is to remove the record from the associated store/s.
            var me = this,
                instanceName = me.getInstanceName(),
                cls = me.cls,
                hasNewValue,
                joined, store, i, len, associated, rightRecord;

            if (!leftRecord.changingKey) {
                hasNewValue = newValue || newValue === 0;
                if (!hasNewValue) {
                    leftRecord[instanceName] = null;
                }
                if (session) {
                    // Find the store that holds this record and remove it if possible.
                    store = me.getSessionStore(session, oldValue);
                    if (store) {
                        store.remove(leftRecord);
                    }
                    // If we have a new value, try and find it and push it into the new store.
                    if (hasNewValue) {
                        store = me.getSessionStore(session, newValue);
                        if (store &amp;&amp; !store.isLoading()) {
                            store.add(leftRecord);
                        }
                        if (cls) {
                            rightRecord = session.peekRecord(cls, newValue);
                        }
                        // Setting to undefined is important so that we can load the record later.
                        leftRecord[instanceName] = rightRecord || undefined;
                    }
                } else {
                    joined = leftRecord.joined;
                    if (joined) {
                        for (i = 0, len = joined.length; i &lt; len; ++i) {
                            store = joined[i];
                            if (store.isStore) {
                                associated = store.getAssociatedEntity();
                                if (associated &amp;&amp; associated.self === me.cls &amp;&amp; associated.getId() === oldValue) {
                                    store.remove(leftRecord);
                                }
                            }
                        }
                    }
                }
            }

            if (me.owner &amp;&amp; newValue === null) {
                me.association.schema.queueKeyCheck(leftRecord, me);
            }
        },

        checkKeyForDrop: function(leftRecord) {
            var field = this.association.field;
            if (leftRecord.get(field.name) === null) {
                leftRecord.drop();
            }
        },

        getSessionStore: function(session, value) {
            // May not have the cls loaded yet
            var cls = this.cls,
                rec;

            if (cls) {
                rec = session.peekRecord(cls, value);

                if (rec) {
                    return this.inverse.getAssociatedItem(rec);
                }
            }
        },
        
        read: function(leftRecord, node, fromReader, readOptions) {
            var result = this.callParent([ leftRecord, node, fromReader, readOptions ]),
                rightRecord = result.getRecords()[0];

            if (rightRecord) {
                leftRecord[this.getInstanceName()] = rightRecord;
                delete leftRecord.data[this.role];
            }
        }
    })
});
</pre>
</body>
</html>
