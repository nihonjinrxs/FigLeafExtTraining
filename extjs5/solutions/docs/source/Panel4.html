<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-panel-Panel'>/**
</span> * Panel is a container that has specific functionality and structural components that make it the perfect building
 * block for application-oriented user interfaces.
 *
 * Panels are, by virtue of their inheritance from {@link Ext.container.Container}, capable of being configured with a
 * {@link Ext.container.Container#layout layout}, and containing child Components.
 *
 * When either specifying child {@link #cfg-items} of a Panel, or dynamically {@link Ext.container.Container#method-add adding}
 * Components to a Panel, remember to consider how you wish the Panel to arrange those child elements, and whether those
 * child elements need to be sized using one of Ext&#39;s built-in `{@link Ext.container.Container#layout layout}`
 * schemes. By default, Panels use the {@link Ext.layout.container.Auto Auto} scheme. This simply renders child
 * components, appending them one after the other inside the Container, and **does not apply any sizing** at all.
 *
 * {@img Ext.panel.Panel/panel.png Panel components}
 *
 * A Panel may also contain {@link #bbar bottom} and {@link #tbar top} toolbars, along with separate {@link
 * Ext.panel.Header header}, {@link #fbar footer} and body sections.
 *
 * Panel also provides built-in {@link #collapsible collapsible, expandable} and {@link #closable} behavior. Panels can
 * be easily dropped into any {@link Ext.container.Container Container} or layout, and the layout and rendering pipeline
 * is {@link Ext.container.Container#method-add completely managed by the framework}.
 *
 * **Note:** By default, the `{@link #closable close}` header tool _destroys_ the Panel resulting in removal of the
 * Panel and the destruction of any descendant Components. This makes the Panel object, and all its descendants
 * **unusable**. To enable the close tool to simply _hide_ a Panel for later re-use, configure the Panel with
 * `{@link #closeAction closeAction}: &#39;hide&#39;`.
 *
 * Usually, Panels are used as constituents within an application, in which case, they would be used as child items of
 * Containers, and would themselves use Ext.Components as child {@link #cfg-items}. However to illustrate simply rendering a
 * Panel into the document, here&#39;s how to do it:
 *
 *     @example
 *     Ext.create(&#39;Ext.panel.Panel&#39;, {
 *         title: &#39;Hello&#39;,
 *         width: 200,
 *         html: &#39;&lt;p&gt;World!&lt;/p&gt;&#39;,
 *         renderTo: Ext.getBody()
 *     });
 *
 * A more realistic scenario is a Panel created to house input fields which will not be rendered, but used as a
 * constituent part of a Container:
 *
 *     @example
 *     var filterPanel = Ext.create(&#39;Ext.panel.Panel&#39;, {
 *         bodyPadding: 5,  // Don&#39;t want content to crunch against the borders
 *         width: 300,
 *         title: &#39;Filters&#39;,
 *         items: [{
 *             xtype: &#39;datefield&#39;,
 *             fieldLabel: &#39;Start date&#39;
 *         }, {
 *             xtype: &#39;datefield&#39;,
 *             fieldLabel: &#39;End date&#39;
 *         }],
 *         renderTo: Ext.getBody()
 *     });
 *
 * Note that the Panel above is configured to render into the document and assigned a size. In a real world scenario,
 * the Panel will often be added inside a Container which will use a {@link #layout} to render, size and position its
 * child Components.
 *
 * Panels will often use specific {@link #layout}s to provide an application with shape and structure by containing and
 * arranging child Components:
 *
 *     @example
 *     var resultsPanel = Ext.create(&#39;Ext.panel.Panel&#39;, {
 *         title: &#39;Results&#39;,
 *         width: 600,
 *         height: 400,
 *         renderTo: Ext.getBody(),
 *         layout: {
 *             type: &#39;vbox&#39;,       // Arrange child items vertically
 *             align: &#39;stretch&#39;,    // Each takes up full width
 *             padding: 5
 *         },
 *         items: [{               // Results grid specified as a config object with an xtype of &#39;grid&#39;
 *             xtype: &#39;grid&#39;,
 *             columns: [{header: &#39;Column One&#39;}],            // One header just for show. There&#39;s no data,
 *             store: Ext.create(&#39;Ext.data.ArrayStore&#39;, {}), // A dummy empty data store
 *             flex: 1                                       // Use 1/3 of Container&#39;s height (hint to Box layout)
 *         }, {
 *             xtype: &#39;splitter&#39;   // A splitter between the two child items
 *         }, {                    // Details Panel specified as a config object (no xtype defaults to &#39;panel&#39;).
 *             title: &#39;Details&#39;,
 *             bodyPadding: 5,
 *             items: [{
 *                 fieldLabel: &#39;Data item&#39;,
 *                 xtype: &#39;textfield&#39;
 *             }], // An array of form fields
 *             flex: 2             // Use 2/3 of Container&#39;s height (hint to Box layout)
 *         }]
 *     });
 *
 * The example illustrates one possible method of displaying search results. The Panel contains a grid with the
 * resulting data arranged in rows. Each selected row may be displayed in detail in the Panel below. The {@link
 * Ext.layout.container.VBox vbox} layout is used to arrange the two vertically. It is configured to stretch child items
 * horizontally to full width. Child items may either be configured with a numeric height, or with a `flex` value to
 * distribute available space proportionately.
 *
 * This Panel itself may be a child item of, for exaple, a {@link Ext.tab.Panel} which will size its child items to fit
 * within its content area.
 *
 * Using these techniques, as long as the **layout** is chosen and configured correctly, an application may have any
 * level of nested containment, all dynamically sized according to configuration, the user&#39;s preference and available
 * browser size.
 */
Ext.define(&#39;Ext.panel.Panel&#39;, {
    extend: &#39;Ext.container.Container&#39;,
    alias: &#39;widget.panel&#39;,
    alternateClassName: &#39;Ext.Panel&#39;,

    requires: [
        &#39;Ext.panel.Header&#39;,
        &#39;Ext.util.MixedCollection&#39;,
        &#39;Ext.toolbar.Toolbar&#39;,
        &#39;Ext.fx.Anim&#39;,
        &#39;Ext.util.KeyMap&#39;,
        &#39;Ext.panel.DD&#39;,
        &#39;Ext.XTemplate&#39;,
        &#39;Ext.layout.component.Dock&#39;,
        &#39;Ext.util.Memento&#39;
    ],

    mixins: {
        docking: &#39;Ext.container.DockingContainer&#39;
    },

<span id='Ext-panel-Panel-cfg-childEls'>    childEls: [
</span>        &#39;body&#39;
    ],

<span id='Ext-panel-Panel-cfg-renderTpl'>    renderTpl: [
</span>        // If this Panel is framed, the framing template renders the docked items round the frame
        &#39;{% this.renderDockedItems(out,values,0); %}&#39;,
        &#39;&lt;div id=&quot;{id}-body&quot; data-ref=&quot;body&quot; class=&quot;{baseCls}-body&lt;tpl if=&quot;bodyCls&quot;&gt; {bodyCls}&lt;/tpl&gt;&#39;,
            &#39; {baseCls}-body-{ui}&lt;tpl if=&quot;uiCls&quot;&gt;&#39;,
                &#39;&lt;tpl for=&quot;uiCls&quot;&gt; {parent.baseCls}-body-{parent.ui}-{.}&lt;/tpl&gt;&#39;,
            &#39;&lt;/tpl&gt;{childElCls}&quot;&#39;,
            &#39;&lt;tpl if=&quot;bodyRole&quot;&gt; role=&quot;{bodyRole}&quot;&lt;tpl else&gt; role=&quot;presentation&quot;&lt;/tpl&gt;&#39;,
            &#39;&lt;tpl if=&quot;bodyStyle&quot;&gt; style=&quot;{bodyStyle}&quot;&lt;/tpl&gt;&gt;&#39;,
            &#39;{%this.renderContainer(out,values);%}&#39;,
        &#39;&lt;/div&gt;&#39;,
        &#39;{% this.renderDockedItems(out,values,1); %}&#39;
    ],

    // &lt;editor-fold desc=&quot;Config&quot;&gt;
    // ***********************************************************************************
    // Begin Config
    // ***********************************************************************************

<span id='Ext-panel-Panel-property-headerPosition'>    // For performance reasons we give the following configs their default values on
</span>    // the class body.  This prevents the updaters from running on initialization in the
    // default configuration scenario
    headerPosition: &#39;top&#39;,
<span id='Ext-panel-Panel-property-iconAlign'>    iconAlign: &#39;left&#39;,
</span><span id='Ext-panel-Panel-property-titleAlign'>    titleAlign: &#39;left&#39;,
</span><span id='Ext-panel-Panel-property-titleRotation'>    titleRotation: &#39;default&#39;,
</span>
<span id='Ext-panel-Panel-property-beforeRenderConfig'>    beforeRenderConfig: {
</span><span id='Ext-panel-Panel-cfg-glyph'>        /**
</span>         * @cfg {Number/String} glyph
         * @inheritdoc Ext.panel.Header#glyph
         */
        glyph: null,

<span id='Ext-panel-Panel-cfg-headerPosition'>        /**
</span>         * @cfg {String} [headerPosition=&#39;top&#39;]
         * Specify as `&#39;top&#39;`, `&#39;bottom&#39;`, `&#39;left&#39;` or `&#39;right&#39;`.
         */
        headerPosition: null,

<span id='Ext-panel-Panel-cfg-icon'>        /**
</span>         * @cfg {String} icon
         * @inheritdoc Ext.panel.Header#icon
         */
        icon: null,

<span id='Ext-panel-Panel-cfg-iconAlign'>        /**
</span>         * @cfg {&#39;top&#39;/&#39;right&#39;/&#39;bottom&#39;/&#39;left&#39;} [iconAlign=&#39;left&#39;]
         * The side of the title to render the icon.
         */
        iconAlign: null,

<span id='Ext-panel-Panel-cfg-iconCls'>        /**
</span>         * @cfg {String} iconCls
         * @inheritdoc Ext.panel.Header#iconCls
         */
        iconCls: null,

<span id='Ext-panel-Panel-cfg-title'>        /**
</span>         * @cfg {String}
         * The title text to be used to display in the {@link Ext.panel.Header Panel Header}.
         * Or a config object for a {@link Ext.panel.Title Panel Title}. When a `title` is
         * specified the {@link Ext.panel.Header} will automatically be created and
         * displayed unless {@link #header} is set to `false`.
         */
        title: null,

<span id='Ext-panel-Panel-cfg-titleAlign'>        /**
</span>         * @cfg {String} [titleAlign=&#39;left&#39;]
         * The alignment of the title text within the available space between the
         * icon and the tools.
         */
        titleAlign: null,

<span id='Ext-panel-Panel-cfg-titleRotation'>        /**
</span>         * @cfg {&#39;default&#39;/0/1/2} [titleRotation=&#39;default&#39;]
         * The rotation of the header&#39;s title text.  Can be one of the following values:
         *
         * - `&#39;default&#39;` - use the default rotation, depending on the dock position of the header
         * - `0` - no rotation
         * - `1` - rotate 90deg clockwise
         * - `2` - rotate 90deg counter-clockwise
         *
         * The default behavior of this config depends on the dock position of the header:
         *
         * - `&#39;top&#39;` or `&#39;bottom&#39;` - `0`
         * - `&#39;right&#39;` - `1`
         * - `&#39;left&#39;` - `1`
         */
        titleRotation: null
    },

<span id='Ext-panel-Panel-cfg-animCollapse'>    /**
</span>     * @cfg {Boolean} animCollapse
     * `true` to animate the transition when the panel is collapsed, `false` to skip the animation (defaults to `true`
     * if the {@link Ext.fx.Anim} class is available, otherwise `false`). May also be specified as the animation
     * duration in milliseconds.
     */
    animCollapse: Ext.enableFx,

<span id='Ext-panel-Panel-cfg-bodyBorder'>    /**
</span>     * @cfg {Boolean} bodyBorder
     * A shortcut to add or remove the border on the body of a panel. In the classic theme
     * this only applies to a panel which has the {@link #frame} configuration set to `true`.
     * @since 2.3.0
     */

<span id='Ext-panel-Panel-cfg-bodyCls'>    /**
</span>     * @cfg {String/String[]} bodyCls
     * A CSS class, space-delimited string of classes, or array of classes to be applied to the panel&#39;s body element.
     * The following examples are all valid:
     *
     *     bodyCls: &#39;foo&#39;
     *     bodyCls: &#39;foo bar&#39;
     *     bodyCls: [&#39;foo&#39;, &#39;bar&#39;]
     */

<span id='Ext-panel-Panel-cfg-bodyPadding'>    /**
</span>     * @cfg {Number/String} [bodyPadding=undefined]
     * A shortcut for setting a padding style on the body element. The value can either be
     * a number to be applied to all sides, or a normal css string describing padding.
     */

<span id='Ext-panel-Panel-cfg-bodyStyle'>    /**
</span>     * @cfg {String/Object/Function} bodyStyle
     * Custom CSS styles to be applied to the panel&#39;s body element, which can be supplied as a valid CSS style string,
     * an object containing style property name/value pairs or a function that returns such a string or object.
     * For example, these two formats are interpreted to be equivalent:
     *
     *     bodyStyle: &#39;background:#ffc; padding:10px;&#39;
     *
     *     bodyStyle: {
     *         background: &#39;#ffc&#39;,
     *         padding: &#39;10px&#39;
     *     }
     *
     * @since 2.3.0
     */

<span id='Ext-panel-Panel-cfg-border'>    /**
</span>     * @override
     * @cfg {Boolean} [border=true]
     * Specify as `false` to render the Panel with zero width borders.
     *
     * Leaving the value as `true` uses the selected theme&#39;s {@link Ext.panel.Panel#$panel-border-width}
     *
     * Defaults to `false` when using or extending Neptune.
     */
    border: true,

<span id='Ext-panel-Panel-cfg-closable'>    /**
</span>     * @cfg {Boolean} closable
     * True to display the &#39;close&#39; tool button and allow the user to close the window, false to hide the button and
     * disallow closing the window.
     *
     * By default, when close is requested by clicking the close button in the header, the {@link #method-close} method will be
     * called. This will _{@link Ext.Component#method-destroy destroy}_ the Panel and its content meaning that it may not be
     * reused.
     *
     * To make closing a Panel _hide_ the Panel so that it may be reused, set {@link #closeAction} to &#39;hide&#39;.
     */
    closable: false,

<span id='Ext-panel-Panel-cfg-closeAction'>    /**
</span>     * @cfg {String} closeAction
     * The action to take when the close header tool is clicked:
     *
     * - **`&#39;{@link #method-destroy}&#39;`** :
     *
     *   {@link #method-remove remove} the window from the DOM and {@link Ext.Component#method-destroy destroy} it and all descendant
     *   Components. The window will **not** be available to be redisplayed via the {@link #method-show} method.
     *
     * - **`&#39;{@link #method-hide}&#39;`** :
     *
     *   {@link #method-hide} the window by setting visibility to hidden and applying negative offsets. The window will be
     *   available to be redisplayed via the {@link #method-show} method.
     *
     * **Note:** This behavior has changed! setting *does* affect the {@link #method-close} method which will invoke the
     * approriate closeAction.
     */
    closeAction: &#39;destroy&#39;,

<span id='Ext-panel-Panel-cfg-collapsed'>    /**
</span>     * @cfg {Boolean} collapsed
     * `true` to render the panel collapsed, `false` to render it expanded.
     */
    collapsed: false,

<span id='Ext-panel-Panel-cfg-collapsedCls'>    /**
</span>     * @cfg {String} collapsedCls
     * A CSS class to add to the panel&#39;s element after it has been collapsed.
     */
    collapsedCls: &#39;collapsed&#39;,

<span id='Ext-panel-Panel-cfg-collapseDirection'>    /**
</span>     * @cfg {String} collapseDirection
     * The direction to collapse the Panel when the toggle button is clicked.
     *
     * Defaults to the {@link #cfg-headerPosition}
     *
     * **Important: This config is _ignored_ for {@link #collapsible} Panels which are direct child items of a {@link
     * Ext.layout.container.Border border layout}.**
     *
     * Specify as `&#39;top&#39;`, `&#39;bottom&#39;`, `&#39;left&#39;` or `&#39;right&#39;`.
     */

<span id='Ext-panel-Panel-cfg-collapseFirst'>    /**
</span>     * @cfg {Boolean} collapseFirst
     * `true` to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in
     * the panel&#39;s title bar, `false` to render it last.
     */
    collapseFirst: true,

<span id='Ext-panel-Panel-cfg-collapsible'>    /**
</span>     * @cfg {Boolean} collapsible
     * True to make the panel collapsible and have an expand/collapse toggle Tool added into the header tool button
     * area. False to keep the panel sized either statically, or by an owning layout manager, with no toggle Tool.
     * When a panel is used in a {@link Ext.layout.container.Border border layout}, the {@link #floatable} option
     * can influence the behavior of collapsing.
     * See {@link #collapseMode} and {@link #collapseDirection}
     */
    collapsible: undefined,

<span id='Ext-panel-Panel-cfg-collapseMode'>    /**
</span>     * @cfg {String} collapseMode
     * **Important: this config is only effective for {@link #collapsible} Panels which are direct child items of a
     * {@link Ext.layout.container.Border border layout}.**
     *
     * When _not_ a direct child item of a {@link Ext.layout.container.Border border layout}, then the Panel&#39;s header
     * remains visible, and the body is collapsed to zero dimensions. If the Panel has no header, then a new header
     * (orientated correctly depending on the {@link #collapseDirection}) will be inserted to show a the title and a re-
     * expand tool.
     *
     * When a child item of a {@link Ext.layout.container.Border border layout}, this config has three possible values:
     *
     * - `undefined` - When collapsed, a placeholder {@link Ext.panel.Header Header} is injected into the layout to
     *   represent the Panel and to provide a UI with a Tool to allow the user to re-expand the Panel.
     *
     * - `&quot;header&quot;` - The Panel collapses to leave its header visible as when not inside a
     *   {@link Ext.layout.container.Border border layout}.
     *
     * - `&quot;mini&quot;` - The Panel collapses without a visible header.
     */

<span id='Ext-panel-Panel-cfg-constrain'>    /**
</span>     * @override
     * @cfg {Boolean} constrain
     * True to constrain the panel within its containing element, false to allow it to fall outside of its containing
     * element. By default floating components such as Windows will be rendered to `document.body`. To render and constrain the window within
     * another element specify {@link #renderTo}. Optionally the header only can be constrained
     * using {@link #constrainHeader}.
     */
    constrain: false,

<span id='Ext-panel-Panel-cfg-constrainHeader'>    /**
</span>     * @cfg {Boolean} constrainHeader
     * True to constrain the panel header within its containing element (allowing the panel body to fall outside of
     * its containing element) or false to allow the header to fall outside its containing element.
     * Optionally the entire panel can be constrained using {@link #constrain}.
     */
    constrainHeader: false,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;}
<span id='Ext-panel-Panel-cfg-dockedItems'>    /**
</span>     * @cfg {Object/Object[]} dockedItems
     * A component or series of components to be added as docked items to this panel. The docked items can be docked to
     * either the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars:
     *
     *     var panel = new Ext.panel.Panel({
     *         dockedItems: [{
     *             xtype: &#39;toolbar&#39;,
     *             dock: &#39;top&#39;,
     *             items: [{
     *                 text: &#39;Docked to the top&#39;
     *             }]
     *         }]
     *     });
     */
    dockedItems: null,

<span id='Ext-panel-Panel-cfg-buttonAlign'>    /**
</span>     * @cfg {String} buttonAlign
     * The alignment of any buttons added to this panel. Valid values are &#39;right&#39;, &#39;left&#39; and &#39;center&#39; (defaults to
     * &#39;right&#39; for buttons/fbar, &#39;left&#39; for other toolbar types).
     *
     * **NOTE:** The prefered way to specify toolbars is to use the dockedItems config. Instead of buttonAlign you
     * would add the layout: { pack: &#39;start&#39; | &#39;center&#39; | &#39;end&#39; } option to the dockedItem config.
     */

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-tbar'>    /**
</span>     * @cfg {Object/Object[]} tbar
     * Convenience config. Short for &#39;Top Bar&#39;.
     *
     *     tbar: [
     *       { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;top&#39;,
     *         items: [
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     */
    tbar: null,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-bbar'>    /**
</span>     * @cfg {Object/Object[]} bbar
     * Convenience config. Short for &#39;Bottom Bar&#39;.
     *
     *     bbar: [
     *       { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;bottom&#39;,
     *         items: [
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     */
    bbar: null,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-fbar'>    /**
</span>     * @cfg {Object/Object[]} fbar
     * Convenience config used for adding items to the bottom of the panel. Short for Footer Bar.
     *
     *     fbar: [
     *       { type: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;bottom&#39;,
     *         ui: &#39;footer&#39;,
     *         defaults: {minWidth: {@link #minButtonWidth}},
     *         items: [
     *             { xtype: &#39;component&#39;, flex: 1 },
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     *
     * The {@link #minButtonWidth} is used as the default {@link Ext.button.Button#minWidth minWidth} for
     * each of the buttons in the fbar.
     */
    fbar: null,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-lbar'>    /**
</span>     * @cfg {Object/Object[]} lbar
     * Convenience config. Short for &#39;Left Bar&#39; (left-docked, vertical toolbar).
     *
     *     lbar: [
     *       { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;left&#39;,
     *         items: [
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     */
    lbar: null,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-rbar'>    /**
</span>     * @cfg {Object/Object[]} rbar
     * Convenience config. Short for &#39;Right Bar&#39; (right-docked, vertical toolbar).
     *
     *     rbar: [
     *       { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;right&#39;,
     *         items: [
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     */
    rbar: null,

<span id='Ext-panel-Panel-cfg-buttons'>    /**
</span>     * @cfg {Object/Object[]} buttons
     * Convenience config used for adding buttons docked to the bottom of the panel. This is a
     * synonym for the {@link #fbar} config.
     *
     *     buttons: [
     *       { text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;bottom&#39;,
     *         ui: &#39;footer&#39;,
     *         defaults: {minWidth: {@link #minButtonWidth}},
     *         items: [
     *             { xtype: &#39;component&#39;, flex: 1 },
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     *
     * The {@link #minButtonWidth} is used as the default {@link Ext.button.Button#minWidth minWidth} for
     * each of the buttons in the buttons toolbar.
     */
    buttons: null,

<span id='Ext-panel-Panel-cfg-floatable'>    /**
</span>     * @cfg {Boolean} floatable
     * **Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a
     * {@link Ext.layout.container.Border border layout}.**
     *
     * true to allow clicking a collapsed Panel&#39;s {@link #placeholder} to display the Panel floated above the layout,
     * false to force the user to fully expand a collapsed region by clicking the expand button to see it again.
     */
    floatable: true,

<span id='Ext-panel-Panel-cfg-frame'>    /**
</span>     * @cfg {Boolean} frame
     * True to apply a frame to the panel.
     */
    frame: false,

<span id='Ext-panel-Panel-cfg-frameHeader'>    /**
</span>     * @cfg {Boolean} frameHeader
     * True to apply a frame to the panel panels header (if &#39;frame&#39; is true).
     */
    frameHeader: true,


<span id='Ext-panel-Panel-cfg-header'>    /**
</span>     * @cfg {Boolean/Object} [header]
     * Pass as `false` to prevent a Header from being created and shown.
     *
     * Pass as a config object (optionally containing an `xtype`) to custom-configure this Panel&#39;s header.
     *
     * See {@link Ext.panel.Header} for all the options that may be specified here.
     *
     * A {@link Ext.panel.Header panel header} is a {@link Ext.container.Container} which contains the Panel&#39;s {@link #title} and {@link #tools}.
     * You may also configure the Panel&#39;s `header` option with its own child items which go *before* the {@link #tools}
     *
     * By default the panel {@link #title} is inserted after items configured in this config, but before any tools.
     * To insert the title at any point in the full array, specify the {@link Ext.panel.Header#cfg-titlePosition titlePosition} config:
     *
     *     new Ext.panel.Panel({
     *         title: &#39;Test&#39;,
     *         tools: [{
     *             type: &#39;refresh&#39;
     *         }, {
     *             type: &#39;help&#39;
     *         }],
     *         titlePosition: 2 // Title will come AFTER the two tools
     *         ...
     *     });
     *
     */

<span id='Ext-panel-Panel-cfg-headerOverCls'>    /**
</span>     * @cfg {String} headerOverCls
     * Optional CSS class to apply to the header element on mouseover
     */

<span id='Ext-panel-Panel-cfg-hideCollapseTool'>    /**
</span>     * @cfg {Boolean} hideCollapseTool
     * `true` to hide the expand/collapse toggle button when `{@link #collapsible} == true`, `false` to display it.
     */
    hideCollapseTool: false,


<span id='Ext-panel-Panel-cfg-manageHeight'>    /**
</span>     * @cfg {Boolean} [manageHeight=true] When true, the dock component layout writes
     * height information to the panel&#39;s DOM elements based on its shrink wrap height
     * calculation. This ensures that the browser respects the calculated height.
     * When false, the dock component layout will not write heights on the panel or its
     * body element. In some simple layout cases, not writing the heights to the DOM may
     * be desired because this allows the browser to respond to direct DOM manipulations
     * (like animations).
     */
    manageHeight: true,

<span id='Ext-panel-Panel-cfg-maskElement'>    /**
</span>     * @override
     * @cfg {String} [maskElement=&quot;el&quot;]
     *
     * The name of the element property in this Panel to mask when masked by a LoadMask.
     *
     * Defaults to `&quot;el&quot;` to indicate that any LoadMask should be rendered into this Panel&#39;s encapsulating element.
     *
     * This could be configured to be `&quot;body&quot;` so that only the body is masked and toolbars and the header are still mouse-accessible.
     */
    maskElement: &#39;el&#39;,

<span id='Ext-panel-Panel-cfg-minButtonWidth'>    /**
</span>     * @cfg {Number} minButtonWidth
     * Minimum width of all footer toolbar buttons in pixels. If set, this will be used as the default
     * value for the {@link Ext.button.Button#minWidth} config of each Button added to the **footer toolbar** via the
     * {@link #fbar} or {@link #buttons} configurations. It will be ignored for buttons that have a minWidth configured
     * some other way, e.g. in their own config object or via the {@link Ext.container.Container#defaults defaults} of
     * their parent container.
     */
    minButtonWidth: 75,

<span id='Ext-panel-Panel-cfg-overlapHeader'>    /**
</span>     * @cfg {Boolean} overlapHeader
     * True to overlap the header in a panel over the framing of the panel itself. This is needed when frame:true (and
     * is done automatically for you). Otherwise it is undefined. If you manually add rounded corners to a panel header
     * which does not have frame:true, this will need to be set to true.
     */

<span id='Ext-panel-Panel-cfg-placeholder'>    /**
</span>     * @cfg {Ext.Component/Object} placeholder
     * **Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a
     * {@link Ext.layout.container.Border border layout} when not using the `&#39;header&#39;` {@link #collapseMode}.**
     *
     * **Optional.** A Component (or config object for a Component) to show in place of this Panel when this Panel is
     * collapsed by a {@link Ext.layout.container.Border border layout}. Defaults to a generated {@link Ext.panel.Header
     * Header} containing a {@link Ext.panel.Tool Tool} to re-expand the Panel.
     */

<span id='Ext-panel-Panel-cfg-placeholderCollapseHideMode'>    /**
</span>     * @cfg {Number} [placeholderCollapseHideMode=Ext.Element.VISIBILITY]
     * The {@link Ext.dom.Element#setVisibilityMode mode} for hiding collapsed panels when
     * using {@link #collapseMode} &quot;placeholder&quot;.
     */
    //placeholderCollapseHideMode: Ext.Element.VISIBILITY,

<span id='Ext-panel-Panel-cfg-preventHeader'>    /**
</span>     * @cfg {Boolean} preventHeader
     * @deprecated 4.1.0 Use {@link #header} instead.
     * Prevent a Header from being created and shown.
     */
     preventHeader: false,

<span id='Ext-panel-Panel-cfg-shrinkWrapDock'>    /**
</span>     * @cfg {Boolean/Number} shrinkWrapDock
     * Allows for this panel to include the {@link #dockedItems} when trying to determine the overall
     * size of the panel. This option is only applicable when this panel is also shrink wrapping in the
     * same dimensions. See {@link Ext.Component#shrinkWrap} for an explanation of the configuration options.
     */
    shrinkWrapDock: false,

<span id='Ext-panel-Panel-cfg-simpleDrag'>    /**
</span>     * @cfg {Boolean} [simpleDrag=false]
     * When {@link #cfg-draggable} is `true`, Specify this as `true` to  cause the `draggable` config
     * to work the same as it does in {@link Ext.window.Window Window}. This Panel
     * just becomes movable. No DragDrop instances receive any notifications.
     * For example:
     *
     *     @example
     *     var win = Ext.create(&#39;widget.window&#39;, {
     *         height: 300,
     *         width: 300,
     *         title: &#39;Constraining Window&#39;,
     *         closable: false,
     *         items: {
     *             title: &quot;Floating Panel&quot;,
     *             width: 100,
     *             height: 100,
     *             floating: true,
     *             draggable: true,
     *             constrain: true,
     *             simpleDrag: true
     *         }
     *     });
     *     win.show();
     *     // Floating components begin life hidden
     *     win.child(&#39;[title=Floating Panel]&#39;).show();
     *
     */

<span id='Ext-panel-Panel-cfg-titleCollapse'>    /**
</span>     * @cfg {Boolean} titleCollapse
     * `true` to allow expanding and collapsing the panel (when `{@link #collapsible} = true`) by clicking anywhere in
     * the header bar, `false`) to allow it only by clicking to tool button). When a panel is used in a
     * {@link Ext.layout.container.Border border layout}, the {@link #floatable} option can influence the behavior of collapsing.
     */
    titleCollapse: undefined,

<span id='Ext-panel-Panel-cfg-tools'>    /**
</span>     * @cfg {Object[]/Ext.panel.Tool[]} tools
     * An array of {@link Ext.panel.Tool} configs/instances to be added to the header tool area. The tools are stored as
     * child components of the header container. They can be accessed using {@link #down} and {#query}, as well as the
     * other component methods. The toggle tool is automatically created if {@link #collapsible} is set to true.
     *
     * Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the
     * visual button. Any required functionality must be provided by adding handlers that implement the necessary
     * behavior.
     *
     * Example usage:
     *
     *     tools:[{
     *         type:&#39;refresh&#39;,
     *         tooltip: &#39;Refresh form Data&#39;,
     *         // hidden:true,
     *         handler: function(event, toolEl, panelHeader) {
     *             // refresh logic
     *         }
     *     },
     *     {
     *         type:&#39;help&#39;,
     *         tooltip: &#39;Get Help&#39;,
     *         callback: function(panel, tool, event) {
     *             // show help here
     *         }
     *     }]
     *
     * The difference between `handler` and `callback` is the signature. For details on
     * the distinction, see {@link Ext.panel.Tool}.
     */

    // ***********************************************************************************
    // End Config
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

<span id='Ext-panel-Panel-cfg-baseCls'>    // &lt;editor-fold desc=&quot;Properties&quot;&gt;
</span>    // ***********************************************************************************
    // Begin Properties
    // ***********************************************************************************

    baseCls: Ext.baseCSSPrefix + &#39;panel&#39;,

<span id='Ext-panel-Panel-property-body'>    /**
</span>     * @property {Ext.dom.Element} body
     * The Panel&#39;s body {@link Ext.dom.Element Element} which may be used to contain HTML content.
     * The content may be specified in the {@link #html} config, or it may be loaded using the
     * {@link #loader} config. Read-only.
     *
     * If this is used to load visible HTML elements in either way, then
     * the Panel may not be used as a Layout for hosting nested Panels.
     *
     * If this Panel is intended to be used as the host of a Layout (See {@link #layout}
     * then the body Element must not be loaded or changed - it is under the control
     * of the Panel&#39;s Layout.
     *
     * @readonly
     */

    bodyPosProps: {
        x: &#39;x&#39;,
        y: &#39;y&#39;
    },

<span id='Ext-panel-Panel-cfg-componentLayout'>    componentLayout: &#39;dock&#39;,
</span>
<span id='Ext-panel-Panel-property-contentPaddingProperty'>    /**
</span>     * @property {String} [contentPaddingProperty=&#39;bodyPadding&#39;]
     * @inheritdoc
     */
    contentPaddingProperty: &#39;bodyPadding&#39;,

<span id='Ext-panel-Panel-property-emptyArray'>    emptyArray: [],
</span>
<span id='Ext-panel-Panel-property-isPanel'>    /**
</span>     * @property {Boolean} isPanel
     * `true` in this class to identify an object as an instantiated Panel, or subclass thereof.
     */
    isPanel: true,

<span id='Ext-panel-Panel-property-defaultBindProperty'>    defaultBindProperty: &#39;title&#39;,
</span>
    // ***********************************************************************************
    // End Properties
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

    // &lt;editor-fold desc=&quot;Events&quot;&gt;
    // ***********************************************************************************
    // Begin Events
    // ***********************************************************************************

<span id='Ext-panel-Panel-event-beforeclose'>    /**
</span>     * @event beforeclose
     * Fires before the user closes the panel. Return false from any listener to stop the close event being
     * fired
     * @param {Ext.panel.Panel} panel The Panel object
     */

<span id='Ext-panel-Panel-event-beforecollapse'>    /**
</span>     * @event beforecollapse
     * Fires before this panel is collapsed. Return false to prevent the collapse.
     * @param {Ext.panel.Panel} p The Panel being collapsed.
     * @param {String} direction . The direction of the collapse. One of
     *
     *   - Ext.Component.DIRECTION_TOP
     *   - Ext.Component.DIRECTION_RIGHT
     *   - Ext.Component.DIRECTION_BOTTOM
     *   - Ext.Component.DIRECTION_LEFT
     *
     * @param {Boolean} animate True if the collapse is animated, else false.
     */

<span id='Ext-panel-Panel-event-beforeexpand'>    /**
</span>     * @event beforeexpand
     * Fires before this panel is expanded. Return false to prevent the expand.
     * @param {Ext.panel.Panel} p The Panel being expanded.
     * @param {Boolean} animate True if the expand is animated, else false.
     */

<span id='Ext-panel-Panel-event-close'>    /**
</span>     * @event close
     * Fires when the user closes the panel.
     * @param {Ext.panel.Panel} panel The Panel object
     */

<span id='Ext-panel-Panel-event-collapse'>    /**
</span>     * @event collapse
     * Fires after this Panel has collapsed.
     * @param {Ext.panel.Panel} p The Panel that has been collapsed.
     */

<span id='Ext-panel-Panel-event-expand'>    /**
</span>     * @event expand
     * Fires after this Panel has expanded.
     * @param {Ext.panel.Panel} p The Panel that has been expanded.
     */

<span id='Ext-panel-Panel-event-float'>    /**
</span>     * @event float
     * Fires after a collapsed Panel has been &quot;floated&quot; by clicking on
     * it&#39;s header. Only applicable when the Panel is an item in a
     * {@link Ext.layout.container.Border Border Layout}.
     */

<span id='Ext-panel-Panel-event-glyphchange'>    /**
</span>     * @event glyphchange
     * Fired when the Panel glyph has been changed by the {@link #setGlyph} method.
     * @param {Ext.panel.Panel} this
     * @param {Number/String} newGlyph
     * @param {Number/String} oldGlyph
     */

<span id='Ext-panel-Panel-event-iconchange'>    /**
</span>     * @event iconchange
     * Fires after the Panel icon has been set or changed.
     * @param {Ext.panel.Panel} p The Panel which has the icon changed.
     * @param {String} newIcon The path to the new icon image.
     * @param {String} oldIcon The path to the previous panel icon image.
     */

<span id='Ext-panel-Panel-event-iconclschange'>    /**
</span>     * @event iconclschange
     * Fires after the Panel iconCls has been set or changed.
     * @param {Ext.panel.Panel} p The Panel which has the iconCls changed.
     * @param {String} newIconCls The new iconCls.
     * @param {String} oldIconCls The previous panel iconCls.
     */

<span id='Ext-panel-Panel-event-titlechange'>    /**
</span>     * @event titlechange
     * Fires after the Panel title has been set or changed.
     * @param {Ext.panel.Panel} p the Panel which has been resized.
     * @param {String} newTitle The new title.
     * @param {String} oldTitle The previous panel title.
     */

<span id='Ext-panel-Panel-event-unfloat'>    /**
</span>     * @event unfloat
     * Fires after a &quot;floated&quot; Panel has returned to it&#39;s collapsed state
     * as a result of the mouse leaving the Panel. Only applicable when
     * the Panel is an item in a
     * {@link Ext.layout.container.Border Border Layout}.
     */

    // ***********************************************************************************
    // End Events
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

    // &lt;editor-fold desc=&quot;Component Methods&quot;&gt;
    // ***********************************************************************************
    // Begin Methods
    // ***********************************************************************************

<span id='Ext-panel-Panel-method-addBodyCls'>    /**
</span>     * Adds a CSS class to the body element. If not rendered, the class will
     * be added when the panel is rendered.
     * @param {String} cls The class to add
     * @return {Ext.panel.Panel} this
     */
    addBodyCls: function(cls) {
        var me = this,
            body = me.rendered ? me.body : me.getProtoBody();

        body.addCls(cls);
        return me;
    },

<span id='Ext-panel-Panel-method-addTool'>    /**
</span>     * Add tools to this panel
     * @param {Object[]/Ext.panel.Tool[]} tools The tools to add
     */
    addTool: function(tools) {
        if (!Ext.isArray(tools)) {
            tools = [tools];
        }

        var me     = this,
            header = me.header,
            tLen   = tools.length,
            curTools = me.tools,
            t, tool;

        if (!header || !header.isHeader) {
            header = null;
            if (!curTools) {
                me.tools = curTools = [];
            }
        }

        for (t = 0; t &lt; tLen; t++) {
            tool = tools[t];
            tool.toolOwner = me;

            if (header) {
                header.addTool(tool);
            } else {
                // only modify the tools array if the header isn&#39;t created,
                // otherwise, defer to the header to manage
                curTools.push(tool);
            }
        }

        me.updateHeader();
    },

<span id='Ext-panel-Panel-method-addTools'>    /**
</span>     * @protected
     * @template
     * Template method to be implemented in subclasses to add their tools after the collapsible tool.
     */
    addTools: Ext.emptyFn,

<span id='Ext-panel-Panel-method-setCollapsible'>    setCollapsible: function (collapsible) {
</span>        var me = this,
            current = me.collapsible,
            collapseTool = me.collapseTool;

        me.collapsible = collapsible;

        if (collapsible &amp;&amp; !current) {
            me.updateCollapseTool();

            collapseTool = me.collapseTool;
            if (collapseTool) {
                collapseTool.show();
            }
        } else if (!collapsible &amp;&amp; current) {
            if (collapseTool) {
                collapseTool.hide();
            }
        }
    },

<span id='Ext-panel-Panel-method-addUIClsToElement'>    // inherit docs
</span>    addUIClsToElement: function(cls) {
        var me = this,
            result = me.callParent(arguments);

        me.addBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + &#39;-body-&#39; + cls, me.baseCls + &#39;-body-&#39; + me.ui + &#39;-&#39; + cls]);
        return result;
    },

<span id='Ext-panel-Panel-method-afterCollapse'>    /**
</span>     * Invoked after the Panel is Collapsed.
     *
     * @param {Boolean} animated
     *
     * @template
     * @protected
     */
    afterCollapse: function(animated) {
        var me = this,
            ownerLayout = me.ownerLayout;

        me.isCollapsingOrExpanding = 0;
        me.updateCollapseTool();

        // The x-animating-size class sets overflow:hidden so that overflowing
        // content is clipped during animation.
        if (animated) {
            me.removeCls(Ext.baseCSSPrefix + &#39;animating-size&#39;);
        }

        if (ownerLayout) {
            ownerLayout.afterCollapse(me, animated);
        }

        me.setHiddenDocked();
        me.fireEvent(&#39;collapse&#39;, me);
    },

<span id='Ext-panel-Panel-method-afterExpand'>    /**
</span>     * Invoked after the Panel is Expanded.
     *
     * @param {Boolean} animated
     *
     * @template
     * @protected
     */
    afterExpand: function(animated) {
        var me = this,
            ownerLayout = me.ownerLayout;

        me.isCollapsingOrExpanding = 0;
        me.updateCollapseTool();

        // The x-animating-size class sets overflow:hidden so that overflowing
        // content is clipped during animation.
        if (animated) {
            me.removeCls(Ext.baseCSSPrefix + &#39;animating-size&#39;);
        }

        if (ownerLayout) {
            ownerLayout.afterExpand(me, animated);
        }

        me.fireEvent(&#39;expand&#39;, me);
        me.fireHierarchyEvent(&#39;expand&#39;);
    },

<span id='Ext-panel-Panel-method-beforeDestroy'>    beforeDestroy: function() {
</span>        var me = this;
        Ext.destroy(
            me.placeholder,
            me.ghostPanel,
            me.dd
        );
        this.destroyDockedItems();
        me.callParent();
    },

<span id='Ext-panel-Panel-method-beforeRender'>    beforeRender: function() {
</span>        var me = this,
            wasCollapsed;

        me.callParent();

        // Add class-specific header tools.
        // Panel adds collapsible and closable.
        me.initTools();

        // Dock the header/title unless we are configured specifically not to create a header
        if (!(me.preventHeader || (me.header === false))) {
            me.updateHeader();
        }
        me.afterHeaderInit = true;

        // If we are rendering collapsed, we still need to save and modify various configs
        if (me.collapsed) {
            if (me.isPlaceHolderCollapse()) {
                if (!me.hidden) {
                    me.setHiddenState(true);

                    // This will insert the placeholder Component into the ownerCt&#39;s child collection
                    // Its getRenderTree call which is calling this will then iterate again and
                    // recreate the child items array to include the new Component. Prevent the first
                    // collapse from firing
                    me.preventCollapseFire = true;
                    me.placeholderCollapse();
                    delete me.preventCollapseFire;
                    wasCollapsed = me.collapsed;

                    // Temporarily clear the flag so that the header is rendered with a collapse tool in it.
                    // Placeholder collapse panels never really collapse, they just hide. The tool is always
                    // a collapse tool.
                    me.collapsed = false;
                }
            } else {
                me.beginCollapse();
                me.addClsWithUI(me.collapsedCls);
            }
        }

        // Restore the flag if we are being rendered initially placeholder collapsed.
        if (wasCollapsed) {
            me.collapsed = wasCollapsed;
        }
    },

<span id='Ext-panel-Panel-method-getMemento'>    /**
</span>     * @private
     * Memento Factory method
     * @param {String} name Name of the Memento (used as prefix for named Memento)
    s */
    getMemento :function (name) {
        var me = this;
        if(name &amp;&amp; typeof name == &#39;string&#39;) {
            name += &#39;Memento&#39;;
            return me[name] || (me[name] = new Ext.util.Memento(me));
        }
    },


<span id='Ext-panel-Panel-method-beginCollapse'>    /**
</span>     * @private
     * Called before the change from default, configured state into the collapsed state.
     * This method may be called at render time to enable rendering in an initially collapsed state,
     * or at runtime when an existing, fully layed out Panel may be collapsed.
     * It basically saves configs which need to be clobbered for the duration of the collapsed state.
     */
    beginCollapse: function() {
        var me = this,
            lastBox = me.lastBox,
            rendered = me.rendered,
            collapseMemento = me.getMemento(&#39;collapse&#39;),
            sizeModel = me.getSizeModel(),
            header = me.header,
            reExpander;

        // When we collapse a panel, the panel is in control of one dimension (depending on
        // collapse direction) and sets that on the component. We must restore the user&#39;s
        // original value (including non-existance) when we expand. Using this technique, we
        // mimic setCalculatedSize for the dimension we do not control and setSize for the
        // one we do (only while collapsed).
        // Additionally, the panel may have a shrink wrapped width and/or height. For shrinkWrapped
        // panels this can be problematic, since a collapsed, shrink-wrapped panel has no way
        // of determining its width (or height if the collapse direction is horizontal). It is
        // therefore necessary to capture both the width and height regardless of collapse direction.
        // This allows us to set a configured width or height on the panel when it is collapsed,
        // and it will be restored to an unconfigured-width shrinkWrapped state on expand.
        collapseMemento.capture([&#39;height&#39;, &#39;minHeight&#39;, &#39;width&#39;, &#39;minWidth&#39;]);
        if (lastBox) {
            collapseMemento.capture(me.restoreDimension(), lastBox, &#39;last.&#39;);
        }
        // If the panel has a shrinkWrapped height/width and is already rendered, configure its width/height as its calculated width/height,
        // so that the collapsed header will have the same width or height as the panel did before it was collapsed.
        // If the shrinkWrapped panel has not yet been rendered, as will be the case when a panel is initially configured with
        // collapsed:true, we attempt to use the configured width/height, and fall back to minWidth or minHeight if
        // width/height has not been configured, and fall back to a value of 100 if a minWidth/minHeight has not been configured.
        if (me.collapsedVertical()) {
            if (sizeModel.width.shrinkWrap) {
                me.width = rendered ? me.getWidth() : me.width || me.minWidth || 100;
            }
            delete me.height;
            me.minHeight = 0;
        } else if (me.collapsedHorizontal()) {
            if (sizeModel.height.shrinkWrap) {
                me.height = rendered ? me.getHeight() : me.height || me.minHeight || 100;
            }
            delete me.width;
            me.minWidth = 0;
        }

        if (me.ownerCt) {
            me.ownerCt.getLayout().beginCollapse(me);
        }

        // Get a reExpander header. This will return the Panel Header if the Header is in the correct orientation
        // If we are using the Header as the reExpander, change its UI to collapsed state
        if (!me.isPlaceHolderCollapse() &amp;&amp; header !== false) {
            if (header === (reExpander = me.getReExpander())) {
                header.collapseImmune = true;
                header.getInherited().collapseImmune = true;
                header.addClsWithUI(me.getHeaderCollapsedClasses(header));

                // Ensure that the reExpander has the correct framing applied.
                if (header.rendered) {
                    header.updateFrame();
                }
            } else if (reExpander.el) {
                // We&#39;re going to use a temporary reExpander: show it.
                reExpander.el.show();
                reExpander.hidden = false;
            }
        }
        if (me.resizer) {
            me.resizer.disable();
        }
    },

<span id='Ext-panel-Panel-method-beginDrag'>    beginDrag: function() {
</span>        if (this.floatingDescendants) {
            this.floatingDescendants.hide();
        }
    },

<span id='Ext-panel-Panel-method-beginExpand'>    beginExpand: function() {
</span>        var me = this,
            lastBox = me.lastBox,
            collapseMemento = me.getMemento(&#39;collapse&#39;),
            restoreDimension = me.restoreDimension(),
            header = me.header,
            reExpander;

        if (collapseMemento) {
            collapseMemento.restore([&#39;minHeight&#39;, &#39;minWidth&#39;, restoreDimension]);
            if (lastBox) {
                collapseMemento.restore(restoreDimension, true, lastBox, &#39;last.&#39;);
            }
        }

        if (me.ownerCt) {
            me.ownerCt.getLayout().beginExpand(me);
        }

        if (!me.isPlaceHolderCollapse() &amp;&amp; header !== false) {
            // If we have been using our Header as the reExpander then restore the Header to expanded UI
            if (header === (reExpander = me.getReExpander())) {
                delete header.collapseImmune;
                delete header.getInherited().collapseImmune;
                header.removeClsWithUI(me.getHeaderCollapsedClasses(header));

                // Ensure that the reExpander has the correct framing applied.
                if (header.rendered) {
                    header.expanding = true;
                    header.updateFrame();
                    delete header.expanding;
                }
            } else {
                // We&#39;ve been using a temporary reExpander: hide it.
                reExpander.hidden = true;
                reExpander.el.hide();
            }
        }
        if (me.resizer) {
            me.resizer.enable();
        }
    },

<span id='Ext-panel-Panel-method-bridgeToolbars'>    bridgeToolbars: function() {
</span>        var me = this,
            docked = [],
            minButtonWidth = me.minButtonWidth,
            fbar, fbarDefaults;

        function initToolbar (toolbar, pos, useButtonAlign) {
            if (Ext.isArray(toolbar)) {
                toolbar = {
                    xtype: &#39;toolbar&#39;,
                    items: toolbar
                };
            }
            else if (!toolbar.xtype) {
                toolbar.xtype = &#39;toolbar&#39;;
            }
            toolbar.dock = pos;
            if (pos == &#39;left&#39; || pos == &#39;right&#39;) {
                toolbar.vertical = true;
            }

            // Legacy support for buttonAlign (only used by buttons/fbar)
            if (useButtonAlign) {
                toolbar.layout = Ext.applyIf(toolbar.layout || {}, {
                    // default to &#39;end&#39; (right-aligned) if me.buttonAlign is undefined or invalid
                    pack: { left:&#39;start&#39;, center:&#39;center&#39; }[me.buttonAlign] || &#39;end&#39;
                });
            }
            return toolbar;
        }

        if (me.tbar) {
            docked.push(initToolbar(me.tbar, &#39;top&#39;));
            me.tbar = null;
        }

        if (me.bbar) {
            docked.push(initToolbar(me.bbar, &#39;bottom&#39;));
            me.bbar = null;
        }

        if (me.buttons) {
            me.fbar = me.buttons;
            me.buttons = null;
        }

        if (me.fbar) {
            fbar = initToolbar(me.fbar, &#39;bottom&#39;, true); // only we useButtonAlign
            fbar.ui = &#39;footer&#39;;

            // Apply the minButtonWidth config to buttons in the toolbar
            if (minButtonWidth) {
                fbarDefaults = fbar.defaults;
                fbar.defaults = function(config) {
                    var defaults = fbarDefaults || {},
                        // no xtype or a button instance
                        isButton = !config.xtype || config.isButton,
                        cls;

                    // Here we have an object config with an xtype, check if it&#39;s a button
                    // or a button subclass
                    if (!isButton) {
                        cls = Ext.ClassManager.getByAlias(&#39;widget.&#39; + config.xtype);
                        if (cls) {
                            isButton = cls.prototype.isButton;
                        }
                    }
                    if (isButton &amp;&amp; !(&#39;minWidth&#39; in defaults)) {
                        defaults = Ext.apply({minWidth: minButtonWidth}, defaults);
                    }
                    return defaults;
                };
            }

            docked.push(fbar);
            me.fbar = null;
        }

        if (me.lbar) {
            docked.push(initToolbar(me.lbar, &#39;left&#39;));
            me.lbar = null;
        }

        if (me.rbar) {
            docked.push(initToolbar(me.rbar, &#39;right&#39;));
            me.rbar = null;
        }

        if (me.dockedItems) {
            if (me.dockedItems.isMixedCollection) {
                me.addDocked(docked);
            } else {
                if (!Ext.isArray(me.dockedItems)) {
                    me.dockedItems = [me.dockedItems];
                }
                me.dockedItems = me.dockedItems.concat(docked);
            }
        } else {
            me.dockedItems = docked;
        }
    },

<span id='Ext-panel-Panel-method-close'>    /**
</span>     * Closes the Panel. By default, this method, removes it from the DOM, {@link Ext.Component#method-destroy destroy}s the
     * Panel object and all its descendant Components. The {@link #beforeclose beforeclose} event is fired before the
     * close happens and will cancel the close action if it returns false.
     *
     * **Note:** This method is also affected by the {@link #closeAction} setting. For more explicit control use
     * {@link #method-destroy} and {@link #method-hide} methods.
     */
    close: function() {
        if (this.fireEvent(&#39;beforeclose&#39;, this) !== false) {
            this.doClose();
        }
    },

<span id='Ext-panel-Panel-method-collapse'>    /**
</span>     * Collapses the panel body so that the body becomes hidden. Docked Components parallel to the border towards which
     * the collapse takes place will remain visible. Fires the {@link #beforecollapse} event which will cancel the
     * collapse action if it returns false.
     *
     * @param {String} [direction] The direction to collapse towards. Must be one of
     *
     *   - Ext.Component.DIRECTION_TOP
     *   - Ext.Component.DIRECTION_RIGHT
     *   - Ext.Component.DIRECTION_BOTTOM
     *   - Ext.Component.DIRECTION_LEFT
     *
     * Defaults to {@link #collapseDirection}.
     *
     * @param {Boolean} [animate] True to animate the transition, else false
     * (defaults to the value of the {@link #animCollapse} panel config). May
     * also be specified as the animation duration in milliseconds.
     * @return {Ext.panel.Panel} this
     */
    collapse: function(direction, animate) {
        var me = this,
            collapseDir = direction || me.collapseDirection,
            ownerCt = me.ownerCt,
            layout = me.ownerLayout,
            rendered = me.rendered;

        if (me.isCollapsingOrExpanding) {
            return me;
        }

        if (arguments.length &lt; 2) {
            animate = me.animCollapse;
        }

        if (me.collapsed || me.fireEvent(&#39;beforecollapse&#39;, me, direction, animate) === false) {
            return me;
        }

        if (layout &amp;&amp; layout.onBeforeComponentCollapse) {
            if (layout.onBeforeComponentCollapse(me) === false) {
                return me;
            }
        }

        if (rendered &amp;&amp; ownerCt &amp;&amp; me.isPlaceHolderCollapse()) {
            return me.placeholderCollapse(direction, animate);
        }

        me.collapsed = collapseDir;
        if (rendered) {
            me.beginCollapse();
        }

        me.getInherited().collapsed = true;
        me.fireHierarchyEvent(&#39;collapse&#39;);

        if (rendered) {
            me.doCollapseExpand(1, animate);
        }
        return me;
    },

<span id='Ext-panel-Panel-method-collapsedHorizontal'>    collapsedHorizontal: function () {
</span>        var dir = this.getCollapsed();
        return dir === &#39;left&#39; || dir === &#39;right&#39;;
    },

<span id='Ext-panel-Panel-method-collapsedVertical'>    collapsedVertical: function () {
</span>        var dir = this.getCollapsed();
        return dir === &#39;top&#39; || dir === &#39;bottom&#39;;
    },

<span id='Ext-panel-Panel-method-convertCollapseDir'>    /**
</span>     * converts a collapsdDir into an anchor argument for Element.slideIn
     * overridden in rtl mode to switch &quot;l&quot; and &quot;r&quot;
     */
    convertCollapseDir: function(collapseDir) {
        return collapseDir.substr(0, 1);
    },

<span id='Ext-panel-Panel-method-createGhost'>    createGhost: function(cls) {
</span>         var me = this,
             header = me.header,
             frame = me.frame &amp;&amp; !me.alwaysFramed;

        return {
            xtype: &#39;panel&#39;,
            hidden: false,
            header: header ? {
                titleAlign: header.getTitleAlign()
            } : null,
            ui: frame ? me.ui.replace(/-framed$/, &#39;&#39;) : me.ui,
            id: me.id + &#39;-ghost&#39;,
            renderTo: Ext.getBody(),
            // The ghost&#39;s opacity causes the resize handles to obscure the frame in
            // IE, so always force resizable to be false.
            resizable: false,

            // The ghost must not be draggable (the actual class instantiated my be draggable in its prototype)
            draggable: false,

            // Tools are explicitly copied. We do not want the overhead of a KeyMap for the ghost
            closable: false,

            floating: true,
            shadow: false,
            frame: frame,
            shim: me.shim,
            alwaysFramed: me.alwaysFramed,
            overlapHeader: me.overlapHeader,
            headerPosition: me.getHeaderPosition(),
            titleRotation: me.getTitleRotation(),
            baseCls: me.baseCls,
            getRefOwner: function () {
                return me.getRefOwner();
            },
            cls: me.baseCls + &#39;-ghost &#39; + (cls || &#39;&#39;)
        };
    },

<span id='Ext-panel-Panel-method-createReExpander'>    createReExpander: function(direction, defaults) {
</span>        var me = this,
            isLeft = direction === &#39;left&#39;,
            isRight = direction === &#39;right&#39;,
            isVertical = isLeft || isRight,
            ownerCt = me.ownerCt,
            result = Ext.apply({
                hideMode: &#39;offsets&#39;,
                title: me.getTitle(),
                titleAlign: me.getTitleAlign(),
                vertical: isVertical,
                textCls: me.headerTextCls,
                icon: me.getIcon(),
                iconCls: me.getIconCls(),
                iconAlign: me.getIconAlign(),
                glyph: me.getGlyph(),
                baseCls: me.self.prototype.baseCls + &#39;-header&#39;,
                ui: me.ui,
                frame: me.frame &amp;&amp; me.frameHeader,
                ignoreParentFrame: me.frame || me.overlapHeader,
                ignoreBorderManagement: me.frame || me.ignoreHeaderBorderManagement,
                indicateDrag: me.draggable,
                collapseImmune: true,
                headerRole: me.headerRole,
                ownerCt: (ownerCt &amp;&amp; me.collapseMode === &#39;placeholder&#39;) ? ownerCt : me,
                ownerLayout: me.componentLayout,
                margin: me.margin
            }, defaults);

        // If we&#39;re in mini mode, set the placeholder size to only 1px since
        // we don&#39;t need it to show up.
        if (me.collapseMode === &#39;mini&#39;) {
            if (isVertical) {
                result.width = 1;
            } else {
                result.height = 1;
            }
        }

        // Create the re expand tool
        // For UI consistency reasons, collapse:left reExpanders, and region: &#39;west&#39; placeHolders
        // have the re expand tool at the *top* with a bit of space.
        if (!me.hideCollapseTool) {
            if (isLeft || (isRight &amp;&amp; me.isPlaceHolderCollapse())) {
                // adjust the title position if the collapse tool needs to be at the
                // top of a vertical header
                result.titlePosition = 1;
            }
            result.tools = [{
                xtype: &#39;tool&#39;,
                type: &#39;expand-&#39; + me.getOppositeDirection(direction),
                uiCls: [&#39;top&#39;],
                handler: me.toggleCollapse,
                scope: me
            }];
        }
        result = new Ext.panel.Header(result);
        result.addClsWithUI(me.getHeaderCollapsedClasses(result));
        return result;
    },

<span id='Ext-panel-Panel-method-doClose'>    // @private
</span>    doClose: function() {
        this.fireEvent(&#39;close&#39;, this);
        this[this.closeAction]();
    },

<span id='Ext-panel-Panel-method-doCollapseExpand'>    doCollapseExpand: function (flags, animate) {
</span>        var me = this,
            originalAnimCollapse = me.animCollapse,
            ownerLayout = me.ownerLayout;

        // we need to temporarily set animCollapse to the animate value here because ContextItem
        // uses the animCollapse property to determine if the collapse/expand should be animated
        me.animCollapse = animate;

        // Flag used by the layout ContextItem to impose an animation policy based upon the
        // collapse direction and the animCollapse setting.
        me.isCollapsingOrExpanding = flags;

        // The x-animating-size class sets overflow:hidden so that overflowing
        // content is clipped during animation.
        if (animate) {
            me.addCls(Ext.baseCSSPrefix + &#39;animating-size&#39;);
        }

        if (ownerLayout &amp;&amp; !animate) {
            ownerLayout.onContentChange(me);
        } else {
            me.updateLayout({ isRoot: true });
        }

        // set animCollapse back to its original value
        me.animCollapse = originalAnimCollapse;

        return me;
    },

<span id='Ext-panel-Panel-method-endDrag'>    endDrag: function() {
</span>        if (this.floatingDescendants) {
            this.floatingDescendants.show();
        }
    },

<span id='Ext-panel-Panel-method-expand'>    /**
</span>     * Expands the panel body so that it becomes visible.  Fires the {@link #beforeexpand} event which will
     * cancel the expand action if it returns false.
     * @param {Boolean} [animate] True to animate the transition, else false
     * (defaults to the value of the {@link #animCollapse} panel config).  May
     * also be specified as the animation duration in milliseconds.
     * @return {Ext.panel.Panel} this
     */
    expand: function(animate) {
        var me = this,
            layout = me.ownerLayout,
            rendered = me.rendered;

        if (me.isCollapsingOrExpanding) {
            return me;
        }

        if (!arguments.length) {
            animate = me.animCollapse;
        }

        if (!me.collapsed &amp;&amp; !me.floatedFromCollapse) {
            return me;
        }


        if (me.fireEvent(&#39;beforeexpand&#39;, me, animate) === false) {
            return me;
        }

        if (layout &amp;&amp; layout.onBeforeComponentExpand) {
            if (layout.onBeforeComponentExpand(me) === false) {
                return me;
            }
        }

        delete me.getInherited().collapsed;

        if (rendered &amp;&amp; me.isPlaceHolderCollapse()) {
            return me.placeholderExpand(animate);
        }

        me.restoreHiddenDocked();
        if (rendered) {
            me.beginExpand();
        }
        me.collapsed = false;

        if (me.rendered) {
            me.doCollapseExpand(2, animate);
        }
        return me;
    },

<span id='Ext-panel-Panel-method-findReExpander'>    findReExpander: function (direction) {
</span>        var me = this,
            c = Ext.Component,
            dockedItems = me.dockedItems.items,
            dockedItemCount = dockedItems.length,
            comp, i;

        // never use the header if we&#39;re in collapseMode mini
        if (me.collapseMode === &#39;mini&#39;) {
            return;
        }

        switch (direction) {
            case c.DIRECTION_TOP:
            case c.DIRECTION_BOTTOM:

                // Attempt to find a reExpander Component (docked in a horizontal orientation)
                // Also, collect all other docked items which we must hide after collapse.
                for (i = 0; i &lt; dockedItemCount; i++) {
                    comp = dockedItems[i];
                    if (!comp.hidden) {
                        if (comp.isHeader &amp;&amp; (!comp.dock || comp.dock === &#39;top&#39; || comp.dock === &#39;bottom&#39;)) {
                            return comp;
                        }
                    }
                }
                break;

            case c.DIRECTION_LEFT:
            case c.DIRECTION_RIGHT:

                // Attempt to find a reExpander Component (docked in a vecrtical orientation)
                // Also, collect all other docked items which we must hide after collapse.
                for (i = 0; i &lt; dockedItemCount; i++) {
                    comp = dockedItems[i];
                    if (!comp.hidden) {
                        if (comp.isHeader &amp;&amp; (comp.dock === &#39;left&#39; || comp.dock === &#39;right&#39;)) {
                            return comp;
                        }
                    }
                }
                break;

            default:
                throw(&#39;Panel#findReExpander must be passed a valid collapseDirection&#39;);
        }
    },

<span id='Ext-panel-Panel-method-floatCollapsedPanel'>    floatCollapsedPanel: function() {
</span>        var me = this,
            placeholder = me.placeholder,
            ps = placeholder.getSize(),
            floatCls = Ext.baseCSSPrefix + &#39;border-region-slide-in&#39;,
            collapsed = me.collapsed,
            layoutOwner = me.ownerCt || me,
            slideDirection, onBodyMousedown, myBox;

        if (me.isSliding) {
            return;
        }

        // Already floated
        if (me.el.hasCls(floatCls)) {
            me.slideOutFloatedPanel();
            return;
        }
        me.isSliding = true;

        // Lay out in fully expanded mode to ensure we are at the correct size, and collect our expanded box
        placeholder.el.hide();
        placeholder.hidden = true;
        me.el.show();
        me.setHiddenState(false);
        me.collapsed = false;
        layoutOwner.updateLayout();

        // Then go back immediately to collapsed state from which to initiate the float into view.
        placeholder.el.show();
        placeholder.hidden = false;
        me.el.hide();
        me.setHiddenState(true);
        me.collapsed = collapsed;
        layoutOwner.updateLayout();
        myBox = me.getBox(false, true);

        me.slideOutTask = me.slideOutTask || new Ext.util.DelayedTask(me.slideOutFloatedPanel, me);

        // Tap outside the floated element slides it back.
        if (Ext.supports.Touch) {
            Ext.on(&#39;mousedown&#39;, onBodyMousedown = function(event) {
                if (!event.within(me.el)) {
                    Ext.un(&#39;mousedown&#39;, onBodyMousedown);
                    me.slideOutFloatedPanel();
                }
            });
        }
        if (!me.placeholderListener) {
            me.placeholderListener = placeholder.on({
                resize: me.onPlaceholderResize,
                scope: me,
                destroyable: true
            });
        }
        placeholder.el.on(&#39;mouseleave&#39;, me.onMouseLeaveFloated, me);
        me.el.on(&#39;mouseleave&#39;, me.onMouseLeaveFloated, me);
        placeholder.el.on(&#39;mouseenter&#39;, me.onMouseEnterFloated, me);
        me.el.on(&#39;mouseenter&#39;, me.onMouseEnterFloated, me);

        me.el.addCls(floatCls);
        me.floated = collapsed;

        // Hide collapse tool in header if there is one (we might be headerless)
        if (me.collapseTool) {
            me.collapseTool.el.hide();
        }

        switch (me.collapsed) {
            case &#39;top&#39;:
                me.width = ps.width;
                me.setLocalXY(myBox.x, myBox.y + ps.height);
                break;
            case &#39;right&#39;:
                me.height = ps.height;
                me.setLocalXY(myBox.x - ps.width, myBox.y);
                break;
            case &#39;bottom&#39;:
                me.width = ps.width;
                me.setLocalXY(myBox.x, myBox.y - ps.height);
                break;
            case &#39;left&#39;:
                me.height = ps.height;
                me.setLocalXY(myBox.x + ps.width, myBox.y);
                break;
        }
        slideDirection = me.convertCollapseDir(me.collapsed);

        // Remember how we are really collapsed so we can restore it, but also so we can
        // become a layoutRoot while we are floated:
        me.floatedFromCollapse = me.collapsed;
        me.collapsed = false;
        me.setHiddenState(false);

        me.el.slideIn(slideDirection, {
            preserveScroll: true,
            duration: Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration),
            listeners: {
                afteranimate: function() {
                    me.isSliding = false;
                    me.fireEvent(&#39;float&#39;, me);
                }
            }
        });
    },

<span id='Ext-panel-Panel-method-onPlaceholderResize'>    onPlaceholderResize: function(ph, newWidth, newHeight) {
</span>        var me = this,
            myBox = me.getBox(false, true),
            phBox = ph.getBox(false, true);

        // Position floated panel alongside the placeholder, and sync the parallel dimension
        switch (me.floated) {
            case &#39;top&#39;:
                me.width = newWidth;
                me.setLocalY(phBox.y + phBox.height);
                break;
            case &#39;right&#39;:
                me.height = newHeight;
                me.setLocalX(phBox.x - myBox.width);
                break;
            case &#39;bottom&#39;:
                me.width = newWidth;
                me.setLocalY(phBox.y - myBox.height);
                break;
            case &#39;left&#39;:
                me.height = newHeight;
                me.setLocalX(phBox.x + phBox.width);
                break;
        }

        me.updateLayout({
            isRoot: true
        });
    },

<span id='Ext-panel-Panel-method-getAnimationProps'>    getAnimationProps: function() {
</span>        var me = this,
            animCollapse = me.animCollapse,
            props;

        props = me.callParent();

        if (typeof animCollapse === &#39;number&#39;) {
            props.duration = animCollapse;
        }

        return props;
    },

<span id='Ext-panel-Panel-method-getCollapsed'>    /**
</span>     * Returns the current collapsed state of the panel.
     * @return {Boolean/String} False when not collapsed, otherwise the value of {@link #collapseDirection}.
     */
    getCollapsed: function() {
        var me = this;
        // The collapsed flag, when the Panel is collapsed acts as the direction in which the collapse took
        // place. It can still be tested as truthy/falsy if only a truth value is required.
        if (me.collapsed === true) {
            return me.collapseDirection;
        }
        return me.collapsed;
    },

<span id='Ext-panel-Panel-method-getCollapsedDockedItems'>    getCollapsedDockedItems: function () {
</span>        var me = this;
        return me.header === false || me.collapseMode == &#39;placeholder&#39; ? me.emptyArray : [ me.getReExpander() ];
    },

<span id='Ext-panel-Panel-method-getComponent'>    /**
</span>     * Attempts a default component lookup (see {@link Ext.container.Container#getComponent}). If the component is not found in the normal
     * items, the dockedItems are searched and the matched component (if any) returned (see {@link #getDockedComponent}). Note that docked
     * items will only be matched by component id or itemId -- if you pass a numeric index only non-docked child components will be searched.
     * @param {String/Number} comp The component id, itemId or position to find
     * @return {Ext.Component} The component (if found)
     * @since 2.3.0
     */
    getComponent: function(comp) {
        var component = this.callParent(arguments);
        if (component === undefined &amp;&amp; !Ext.isNumber(comp)) {
            // If the arg is a numeric index skip docked items
            component = this.getDockedComponent(comp);
        }
        return component;
    },

<span id='Ext-panel-Panel-method-getHeader'>    /**
</span>     * Gets the {@link Ext.panel.Header Header} for this panel.
     * @return {Ext.panel.Header}
     */
    getHeader: function() {
        return this.header;
    },

<span id='Ext-panel-Panel-method-getHeaderCollapsedClasses'>    // @private
</span>    // Create the class array to add to the Header when collapsed.
    getHeaderCollapsedClasses: function(header) {
        var me = this,
            collapsedCls = me.collapsedCls,
            collapsedClasses;

        collapsedClasses = [ collapsedCls, collapsedCls + &#39;-&#39; + header.getDockName()];
        if (me.border &amp;&amp; (!me.frame || (me.frame &amp;&amp; Ext.supports.CSS3BorderRadius))) {
            collapsedClasses.push(collapsedCls + &#39;-border-&#39; + header.getDockName());
        }
        return collapsedClasses;
    },

<span id='Ext-panel-Panel-method-getKeyMap'>    // @private
</span>    getKeyMap: function() {
        return this.keyMap || (this.keyMap = new Ext.util.KeyMap(Ext.apply({
            target: this.el
        }, this.keys)));
    },

<span id='Ext-panel-Panel-method-getOppositeDirection'>    getOppositeDirection: function(d) {
</span>        var c = Ext.Component;
        switch (d) {
            case c.DIRECTION_TOP:
                return c.DIRECTION_BOTTOM;
            case c.DIRECTION_RIGHT:
                return c.DIRECTION_LEFT;
            case c.DIRECTION_BOTTOM:
                return c.DIRECTION_TOP;
            case c.DIRECTION_LEFT:
                return c.DIRECTION_RIGHT;
        }
    },

<span id='Ext-panel-Panel-method-getPlaceholder'>    getPlaceholder: function(direction) {
</span>        var me = this,
            collapseDir = direction || me.collapseDirection,
            listeners = null,
            placeholder = me.placeholder,
            floatable = me.floatable,
            titleCollapse = me.titleCollapse;

        if (!placeholder) {
            if (floatable || (me.collapsible &amp;&amp; titleCollapse)) {
                listeners = {
                    click: {
                        // titleCollapse needs to take precedence over floatable
                        fn: (!titleCollapse &amp;&amp; floatable) ? me.floatCollapsedPanel : me.toggleCollapse,
                        element: &#39;el&#39;,
                        scope: me
                    }
                };
            }

            me.placeholder = placeholder = Ext.widget(me.createReExpander(collapseDir, {
                id: me.id + &#39;-placeholder&#39;,
                listeners: listeners
            }));
        }

        // User created placeholder was passed in
        if (!placeholder.placeholderFor) {
            // Handle the case of a placeholder config
            if (!placeholder.isComponent) {
                me.placeholder = placeholder = me.lookupComponent(placeholder);
            }
            Ext.applyIf(placeholder, {
                margin: me.margin,
                placeholderFor: me,
                synthetic: true // not user-defined
            });

            placeholder.addCls([Ext.baseCSSPrefix + &#39;region-collapsed-placeholder&#39;, Ext.baseCSSPrefix + &#39;region-collapsed-&#39; + collapseDir + &#39;-placeholder&#39;, me.collapsedCls]);
        }

        return placeholder;
    },

<span id='Ext-panel-Panel-method-getProtoBody'>    getProtoBody: function () {
</span>        var me = this,
            body = me.protoBody;

        if (!body) {
            me.protoBody = body = new Ext.util.ProtoElement({
                cls: me.bodyCls,
                style: me.bodyStyle,
                clsProp: &#39;bodyCls&#39;,
                styleProp: &#39;bodyStyle&#39;,
                styleIsText: true
            });
        }

        return body;
    },

<span id='Ext-panel-Panel-method-getReExpander'>    getReExpander: function (direction) {
</span>        var me = this,
            collapseDir = direction || me.collapseDirection,
            reExpander = me.reExpander || me.findReExpander(collapseDir);

        me.expandDirection = me.getOppositeDirection(collapseDir);

        if (!reExpander) {
        // We did not find a Header of the required orientation: create one.
            me.reExpander = reExpander = me.createReExpander(collapseDir, {
                dock: collapseDir,
                cls: Ext.baseCSSPrefix + &#39;docked &#39; + me.baseCls + &#39;-&#39; + me.ui + &#39;-collapsed&#39;,
                isCollapsedExpander: true
            });

            me.dockedItems.insert(0, reExpander);
        }
        return reExpander;
    },

<span id='Ext-panel-Panel-method-getRefItems'>    getRefItems: function(deep) {
</span>        var items = this.callParent(arguments);

        return this.getDockingRefItems(deep, items);
    },

<span id='Ext-panel-Panel-method-getState'>    getState: function() {
</span>        var me = this,
            state = me.callParent() || {},
            collapsed = me.collapsed,
            floated = me.floated,
            memento;

        // When taking state to restore on a page refresh, floated means collapsed
        if (floated) {
            me.collapsed = floated;
        }
        state = me.addPropertyToState(state, &#39;collapsed&#39;);
        if (floated) {
            me.collapsed = collapsed;
        }

        // If a collapse has taken place, use remembered values as the dimensions.
        if (me.getCollapsed()) {
            memento = me.getMemento(&#39;collapse&#39;).data;
            state = me.addPropertyToState(state , &#39;collapsed&#39;, memento);

            if (me.collapsedVertical()) {
                delete state.height;
                if (memento) {
                    state = me.addPropertyToState(state, &#39;height&#39;, memento.height);
                }
            } else {
                delete state.width;
                if (memento) {
                    state = me.addPropertyToState(state, &#39;width&#39;, memento.width);
                }
            }
        }
        return state;
    },

<span id='Ext-panel-Panel-method-applyState'>    applyState: function(state) {
</span>        var me = this,
            collapseMemento = {},
            collapsed;

        if (state) {
            collapsed = state.collapsed;
            if(collapsed) {
                collapseMemento = me.getMemento(&#39;collapse&#39;);
                Ext.Object.merge(collapseMemento.data , collapsed);
                state.collapsed = true;
            }

            me.callParent(arguments);
        }
    },

<span id='Ext-panel-Panel-method-ghost'>    // @private
</span>    // used for dragging
    ghost: function(cls) {
        var me = this,
            ghostPanel = me.ghostPanel,
            box = me.getBox(),
            header = me.header,
            ghostHeader, tools, icon, iconCls, glyph, i;

        if (!ghostPanel) {
            me.ghostPanel = ghostPanel = Ext.widget(me.createGhost(cls));
            ghostPanel.el.dom.removeAttribute(&#39;tabIndex&#39;);
        } else {
            ghostPanel.el.show();
        }
        ghostPanel.setHiddenState(false);
        ghostPanel.floatParent = me.floatParent;
        ghostPanel.toFront();
        if (header &amp;&amp; !me.preventHeader) {
            ghostHeader = ghostPanel.header;
            // restore options
            ghostHeader.suspendLayouts();
            tools = ghostHeader.query(&#39;tool&#39;);
            for (i = tools.length; i--;) {
                ghostHeader.remove(tools[i]);
            }
            // reset the title position to ensure that the title gets moved into the correct
            // place after we add the tools (if the position didn&#39;t change the updater won&#39;t run)
            ghostHeader.setTitlePosition(0);
            ghostPanel.addTool(me.ghostTools());
            ghostPanel.setTitle(me.getTitle());
            ghostHeader.setTitlePosition(header.titlePosition);

            iconCls = me.getIconCls();
            if (iconCls) {
                ghostPanel.setIconCls(iconCls);
            } else {
                icon = me.getIcon();
                if (icon) {
                    ghostPanel.setIcon(icon);
                } else {
                    glyph = me.getGlyph();
                    if (glyph) {
                        ghostPanel.setGlyph(glyph);
                    }
                }
            }

            ghostHeader.addCls(Ext.baseCSSPrefix + &#39;header-ghost&#39;);
            ghostHeader.resumeLayouts();
        }

        ghostPanel.setPagePosition(box.x, box.y);
        ghostPanel.setSize(box.width, box.height);
        me.el.hide();
        return ghostPanel;
    },

<span id='Ext-panel-Panel-method-ghostTools'>    // @private
</span>    // helper function for ghost
    ghostTools: function() {
        var tools = [],
            header = this.header,
            headerTools = header ? header.query(&#39;tool[hidden=false]&#39;) : [],
            t, tLen, tool;

        if (headerTools.length) {
            t = 0;
            tLen = headerTools.length;

            for (; t &lt; tLen; t++) {
                tool = headerTools[t];

                // Some tools can be full components, and copying them into the ghost
                // actually removes them from the owning panel. You could also potentially
                // end up with duplicate DOM ids as well. To avoid any issues we just make
                // a simple bare-minimum clone of each tool for ghosting purposes.
                tools.push({
                    type: tool.type
                });
            }
        } else {
            tools = [{
                type: &#39;placeholder&#39;
            }];
        }
        return tools;
    },

<span id='Ext-panel-Panel-method-initBodyBorder'>    initBodyBorder: function() {
</span>        var me = this;

        if (me.frame &amp;&amp; me.bodyBorder) {
            if (!Ext.isNumber(me.bodyBorder)) {
                me.bodyBorder = 1;
            }
            me.getProtoBody().setStyle(&#39;border-width&#39;, this.unitizeBox(me.bodyBorder));
        }
    },

<span id='Ext-panel-Panel-method-initBodyStyles'>    /**
</span>     * Parses the {@link #bodyStyle} config if available to create a style string that will be applied to the body element.
     * This also includes {@link #bodyPadding} and {@link #bodyBorder} if available.
     * @return {String} A CSS style string with body styles, padding and border.
     * @private
     */
    initBodyStyles: function() {
        var me = this,
            body = me.getProtoBody();

        if (me.bodyPadding !== undefined) {
            if (me.layout.managePadding) {
                // If the container layout manages padding, the layout will apply the
                // padding to an inner element rather than the body element.  The
                // assumed intent is for the configured padding to override any padding
                // that is applied to the body element via stylesheet rules.  It is
                // therefore necessary to set the body element&#39;s padding to &quot;0&quot;.
                body.setStyle(&#39;padding&#39;, 0);
            } else {
                body.setStyle(&#39;padding&#39;, this.unitizeBox((me.bodyPadding === true) ? 5 : me.bodyPadding));
            }
        }
        me.initBodyBorder();
    },

<span id='Ext-panel-Panel-method-initBorderProps'>    initBorderProps: function() {
</span>        var me = this;

        if (me.frame &amp;&amp; me.border &amp;&amp; me.bodyBorder === undefined) {
            me.bodyBorder = false;
        }
        if (me.frame &amp;&amp; me.border &amp;&amp; (me.bodyBorder === false || me.bodyBorder === 0)) {
            me.manageBodyBorders = true;
        }
    },

<span id='Ext-panel-Panel-method-initComponent'>    initComponent: function() {
</span>        var me = this;

        if (me.collapsible) {
        // Save state on these two events.
            me.addStateEvents([&#39;expand&#39;, &#39;collapse&#39;]);
        }
        if (me.unstyled) {
            me.setUI(&#39;plain&#39;);
        }

        if (me.frame) {
            me.setUI(me.ui + &#39;-framed&#39;);
        }

        // Backwards compatibility
        me.bridgeToolbars();

        me.initBorderProps();
        me.callParent();
        me.collapseDirection = me.collapseDirection || me.getHeaderPosition() || Ext.Component.DIRECTION_TOP;

        // Used to track hidden content elements during collapsed state
        me.hiddenOnCollapse = new Ext.dom.CompositeElement();

    },

<span id='Ext-panel-Panel-method-initItems'>    initItems: function() {
</span>        this.callParent();
        this.initDockingItems();
    },

<span id='Ext-panel-Panel-method-initRenderData'>    /**
</span>     * Initialized the renderData to be used when rendering the renderTpl.
     * @return {Object} Object with keys and values that are going to be applied to the renderTpl
     * @private
     */
    initRenderData: function() {
        var me = this,
            data = me.callParent();

        me.initBodyStyles();
        me.protoBody.writeTo(data);
        delete me.protoBody;

        return data;
    },

<span id='Ext-panel-Panel-method-calculateConstrainedPosition'>    /*
</span>     * @private
     * @override
     * Override of Positionable method to calculate constrained position based upon possibly only
     * constraining our header.
     */
    calculateConstrainedPosition: function(constrainTo, proposedPosition, local, proposedSize) {
        var me = this,
            header = me.header,
            lastBox, fp;

        // If we are only constraining the header, ask the header for its constrained position
        // based upon the size the header will take on based upon this panel&#39;s proposedSize
        if (me.constrainHeader) {
            lastBox = header.lastBox;
            if (proposedSize) {
                if (!header.vertical) {
                    proposedSize = [proposedSize[0], lastBox ? lastBox.height : proposedSize[1]];
                } else {
                    proposedSize = [lastBox ? lastBox.width : proposedSize[0], proposedSize[1]];
                }
            } else if (lastBox) {
                proposedSize = [lastBox.width, lastBox.height];
            }
            fp = me.floatParent;
            constrainTo = constrainTo || me.constrainTo || (fp ? fp.getTargetEl() : null) || me.container || me.el.parent();
        }

        return me.callParent([constrainTo, proposedPosition, local, proposedSize]);
    },

<span id='Ext-panel-Panel-method-initTools'>    /**
</span>     * @private
     * Tools are a Panel-specific capabilty.
     * Panel uses initTools. Subclasses may contribute tools by implementing addTools.
     */
    initTools: function() {
        var me = this,
            tools = me.tools,
            i, tool;

        me.tools = [];
        for (i = tools &amp;&amp; tools.length; i; ) {
            --i;
            me.tools[i] = tool = tools[i];
            tool.toolOwner = me;
        }

        // Add a collapse tool unless configured to not show a collapse tool
        // or to not even show a header.
        if (me.collapsible &amp;&amp; !(me.hideCollapseTool || me.header === false || me.preventHeader)) {
            me.updateCollapseTool();
            // Prepend collapse tool is configured to do so.
            if (me.collapseFirst) {
                me.tools.unshift(me.collapseTool);
            }
        }

        // Add subclass-specific tools.
        me.addTools();

        if (me.pinnable) {
            me.initPinnable();
        }

        // Make Panel closable.
        if (me.closable) {
            me.addClsWithUI(&#39;closable&#39;);
            me.addTool({
                xtype : &#39;tool&#39;,
                type: &#39;close&#39;,
                scope: me,
                handler: me.close
            });
        }

        // Append collapse tool if needed.
        if (me.collapseTool &amp;&amp; !me.collapseFirst) {
            me.addTool(me.collapseTool);
        }
    },

<span id='Ext-panel-Panel-method-isLayoutRoot'>    isLayoutRoot: function() {
</span>        if (this.floatedFromCollapse) {
            return true;
        }
        return this.callParent();
    },

<span id='Ext-panel-Panel-method-isPlaceHolderCollapse'>    isPlaceHolderCollapse: function(){
</span>        return this.collapseMode == &#39;placeholder&#39;;
    },

<span id='Ext-panel-Panel-method-isVisible'>    isVisible: function(deep){
</span>        var me = this;
        if (me.collapsed &amp;&amp; me.placeholder) {
            return me.placeholder.isVisible(deep);
        }
        return me.callParent(arguments);
    },

<span id='Ext-panel-Panel-method-onBoxReady'>    onBoxReady: function(){
</span>        this.callParent(arguments);
        if (this.collapsed) {
            this.setHiddenDocked();
        }
    },

<span id='Ext-panel-Panel-method-onHide'>    onHide: function(animateTarget, cb, scope) {
</span>        var me = this,
            dd = me.dd;

        if (me.floatedFromCollapse) {
            me.slideOutFloatedPanel(true);
        }

        if (me.draggable &amp;&amp; dd) {
            // Panels w/o headers won&#39;t have a Component Dragger.
            dd.endDrag();
        }

        if (me.collapsed &amp;&amp; me.placeholder) {
            me.placeholder.hide();
        } else {
            me.callParent([animateTarget, cb, scope]);
        }
    },

<span id='Ext-panel-Panel-method-onMouseEnterFloated'>    onMouseEnterFloated: function(e) {
</span>        this.slideOutTask.cancel();
    },

<span id='Ext-panel-Panel-method-onMouseLeaveFloated'>    onMouseLeaveFloated: function(e) {
</span>        this.slideOutTask.delay(500);
    },

<span id='Ext-panel-Panel-method-onRemoved'>    onRemoved: function(destroying) {
</span>        var me = this;

        // If we are removed but not being destroyed, ensure our placeholder is also removed but not destroyed
        // If we are being destroyed, our destroy processing will destroy the placeholder.
        // Must run before callParent because that breaks the ownerCt link
        if (me.placeholder &amp;&amp; !destroying) {
            me.ownerCt.remove(me.placeholder, false);
        }

        me.callParent(arguments);
    },

<span id='Ext-panel-Panel-method-onShow'>    onShow: function() {
</span>        var me = this;
        if (me.collapsed &amp;&amp; me.isPlaceHolderCollapse()) {
            // force hidden back to true, since this gets set by the layout
            me.setHiddenState(true);
            me.placeholderCollapse();
        } else {
            me.callParent(arguments);
        }
    },

<span id='Ext-panel-Panel-method-placeholderCollapse'>    placeholderCollapse: function(direction, animate) {
</span>        var me = this,
            ownerCt = me.ownerCt,
            collapseDir = direction || me.collapseDirection,
            floatCls = Ext.baseCSSPrefix + &#39;border-region-slide-in&#39;,
            placeholder = me.getPlaceholder(collapseDir),
            slideInDirection;

        me.isCollapsingOrExpanding = 1;

        // Upcoming layout run will ignore this Component
        me.setHiddenState(true);
        me.collapsed = collapseDir;

        if (placeholder.rendered) {
            // We may have been added to another Container from that in which we rendered the placeholder
            if (placeholder.el.dom.parentNode !== me.el.dom.parentNode) {
                me.el.dom.parentNode.insertBefore(placeholder.el.dom, me.el.dom);
            }

            placeholder.hidden = false;
            placeholder.setHiddenState(false);
            placeholder.el.show();
            ownerCt.updateLayout();
        } else {
            ownerCt.insert(ownerCt.items.indexOf(me), placeholder);
        }

        if (me.rendered) {
            // We MUST NOT hide using display because that resets all scroll information.
            me.el.setVisibilityMode(me.placeholderCollapseHideMode);
            if (animate) {
                me.el.addCls(floatCls);
                placeholder.el.hide();
                slideInDirection = me.convertCollapseDir(collapseDir);

                me.el.slideOut(slideInDirection, {
                    preserveScroll: true,
                    duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: function() {
                            me.el.removeCls(floatCls);
                            /* We need to show the element so that slideIn will work correctly. However, if we leave it
                               visible then it can be seen before the animation starts, causing a flicker. The solution,
                               borrowed from date picker, is to hide it using display none. The slideIn effect includes
                               a call to fixDisplay() that will undo the display none at the appropriate time.
                             */
                            placeholder.el.show().setStyle(&#39;display&#39;, &#39;none&#39;).slideIn(slideInDirection, {
                                easing: &#39;linear&#39;,
                                duration: 100,
                                listeners: {
                                    afteranimate: function() {
                                        placeholder.focus();
                                        placeholder.setHiddenState(false);
                                        me.isCollapsingOrExpanding = 0;
                                        me.fireEvent(&#39;collapse&#39;, me);
                                    }
                                }
                            });
                        }
                    }
                });
            } else {
                me.el.hide();
                placeholder.setHiddenState(false);
                me.isCollapsingOrExpanding = 0;
                me.fireEvent(&#39;collapse&#39;, me);
            }
        } else {
            me.isCollapsingOrExpanding = 0;
            if (!me.preventCollapseFire) {
                me.fireEvent(&#39;collapse&#39;, me);
            }
        }

        return me;
    },

<span id='Ext-panel-Panel-method-placeholderExpand'>    placeholderExpand: function(animate) {
</span>        var me = this,
            collapseDir = me.collapsed,
            floatCls = Ext.baseCSSPrefix + &#39;border-region-slide-in&#39;,
            finalPos,
            floatedPos,
            center = me.ownerLayout ? me.ownerLayout.centerRegion: null;

        // Layouts suspended - don&#39;t bother with animation shenanigans
        if (Ext.Component.layoutSuspendCount) {
            animate = false;
        }

        if (me.floatedFromCollapse) {
            floatedPos = me.getPosition(true);
            // these are the same cleanups performed by the normal slideOut mechanism:
            me.slideOutFloatedPanelBegin();
            me.slideOutFloatedPanelEnd();
            me.floated = false;
        }

        if (animate) {
            // Expand me and hide the placeholder
            Ext.suspendLayouts();
            me.placeholder.hide();
            me.el.show();
            me.collapsed = false;
            me.setHiddenState(false);

            // Stop the center region from moving when layed out without the placeholder there.
            // Unless we are expanding from a floated out situation. In that case, it&#39;s layed out immediately.
            if (center &amp;&amp; !floatedPos) {
                center.hidden = true;
            }

            Ext.resumeLayouts(true);
            center.hidden = false;
            me.el.addCls(floatCls);

            // At this point, this Panel is arranged in its correct, expanded layout.
            // The center region has not been affected because it has been flagged as hidden.
            //
            // If we are proceeding from floated, the center region has also been arranged
            // in its new layout to accommodate this expansion, so no further layout is needed, just
            // element animation.
            //
            // If we are proceeding from fully collapsed, the center region has *not* been relayed out because
            // the UI look and feel dictates that it stays stable until the expanding panel has slid in all the
            // way, and *then* it snaps into place.

            me.isCollapsingOrExpanding = 2;

            // Floated, move it back to the floated pos, and thence into the correct place
            if (floatedPos) {
                finalPos = me.getXY();
                me.setLocalXY(floatedPos[0], floatedPos[1]);
                me.setXY([finalPos[0], finalPos[1]], {
                    duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: function() {
                            me.el.removeCls(floatCls);
                            me.isCollapsingOrExpanding = 0;
                            me.fireEvent(&#39;expand&#39;, me);
                        }
                    }
                });
            }
            // Not floated, slide it in to the correct place
            else {
                me.el.hide();
                me.placeholder.el.show();
                me.placeholder.hidden = false;

                // Slide this Component&#39;s el back into place, after which we lay out AGAIN
                me.setHiddenState(false);
                me.el.slideIn(me.convertCollapseDir(collapseDir), {
                    preserveScroll: true,
                    duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: function() {
                            // the ordering of these two lines appears to be important in
                            // IE9.  There is an odd expand issue in IE 9 in the border layout
                            // example that causes the index1 child of the south dock region
                            // to get &#39;hidden&#39; after a collapse / expand cycle.  See
                            // EXTJSIV-5318 for details
                            me.el.removeCls(floatCls);
                            me.placeholder.hide();

                            // The center region has been left in its larger size, so a layout is needed now
                            me.updateLayout();

                            me.isCollapsingOrExpanding = 0;
                            me.fireEvent(&#39;expand&#39;, me);
                        }
                    }
                });
            }

        } else {
            me.floated = me.collapsed = false;
            me.el.removeCls(floatCls);
            Ext.suspendLayouts();
            me.placeholder.hide();
            me.show();
            Ext.resumeLayouts(true);
            me.fireEvent(&#39;expand&#39;, me);
        }

        return me;
    },

<span id='Ext-panel-Panel-method-removeBodyCls'>    /**
</span>     * Removes a CSS class from the body element.
     * @param {String} cls The class to remove
     * @return {Ext.panel.Panel} this
     */
    removeBodyCls: function(cls) {
        var me = this,
            body = me.rendered ? me.body : me.getProtoBody();

        body.removeCls(cls);
        return me;
    },

<span id='Ext-panel-Panel-method-removeUIClsFromElement'>    removeUIClsFromElement: function(cls) {
</span>        var me = this,
            result = me.callParent(arguments);

        me.removeBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + &#39;-body-&#39; + cls, me.baseCls + &#39;-body-&#39; + me.ui + &#39;-&#39; + cls]);
        return result;
    },

<span id='Ext-panel-Panel-method-restoreDimension'>    restoreDimension: function(){
</span>        var dir = this.collapseDirection;
        // If we&#39;re collapsing top/bottom, we want to restore the height
        // If we&#39;re collapsing left/right, we want to restore the width
        return (dir === &#39;top&#39; || dir === &#39;bottom&#39;) ? &#39;height&#39; : &#39;width&#39;;
    },

<span id='Ext-panel-Panel-method-restoreHiddenDocked'>    restoreHiddenDocked: function(){
</span>        var toShow = this.hiddenOnCollapse;
        // Re-show Panel content which was hidden after collapse.
        toShow.setStyle(&#39;visibility&#39;, &#39;&#39;);
        toShow.clear();
    },

<span id='Ext-panel-Panel-method-setBodyStyle'>    /**
</span>     * Sets the body style according to the passed parameters.
     * @param {Mixed} style A full style specification string, or object, or the name of a style property to set.
     * @param {String} value If the first param was a style property name, the style property value.
     * @return {Ext.panel.Panel} this
     */
    setBodyStyle: function(style, value) {
        var me = this,
            body = me.rendered ? me.body : me.getProtoBody();

        if (Ext.isFunction(style)) {
            style = style();
        }
        if (arguments.length == 1) {
            if (Ext.isString(style)) {
                style = Ext.Element.parseStyles(style);
            }
            body.setStyle(style);
        } else {
            body.setStyle(style, value);
        }
        return me;
    },

<span id='Ext-panel-Panel-method-setBorder'>    // @inheritdoc
</span>    setBorder: function(border, targetEl) {
        if (targetEl) {
            // skip out here, the panel will set the border on the body/header during rendering
            return;
        }

        var me = this,
            header = me.header;

        if (!border) {
            border = 0;
        } else if (border === true) {
            border = &#39;1px&#39;;
        } else {
            border = me.unitizeBox(border);
        }

        if (header) {
            if (header.isHeader) {
                header.setBorder(border);
            } else {
                header.border = border;
            }
        }

        if (me.rendered &amp;&amp; me.bodyBorder !== false) {
            me.body.setStyle(&#39;border-width&#39;, border);
        }
        me.updateLayout();

        me.border = border;
    },

<span id='Ext-panel-Panel-method-setCollapsed'>    /**
</span>     * Collapses or expands the panel.
     * @param {Boolean} collapsed `true` to collapse the panel, `false` to expand it.
     */
    setCollapsed: function(collapsed) {
        this[collapsed ? &#39;collapse&#39; : &#39;expand&#39;]();
    },

<span id='Ext-panel-Panel-method-setGlyph'>    setGlyph: function(glyph) {
</span>        var me = this,
            oldGlyph = me.glyph,
            header = me.header,
            placeholder = me.placeholder;

        if (glyph !== oldGlyph) {
            me.glyph = glyph;

            if (header) {
                if (header.isHeader) {
                    header.setGlyph(glyph);
                } else {
                    header.glyph = glyph;
                }
            } else if (me.rendered|| me.afterHeaderInit) {
                me.updateHeader();
            }

            if (placeholder &amp;&amp; placeholder.setGlyph) {
                placeholder.setGlyph(glyph);
            }

            me.fireEvent(&#39;glyphchange&#39;, me, glyph, oldGlyph);
        }
    },

<span id='Ext-panel-Panel-method-setIcon'>    setIcon: function(icon) {
</span>        var me = this,
            oldIcon = me.icon,
            header = me.header,
            placeholder = me.placeholder;

        if (icon !== oldIcon) {
            me.icon = icon;

            if (header) {
                if (header.isHeader) {
                    header.setIcon(icon);
                } else {
                    header.icon = icon;
                }
            } else if (me.rendered|| me.afterHeaderInit) {
                me.updateHeader();
            }

            if (placeholder &amp;&amp; placeholder.setIcon) {
                placeholder.setIcon(icon);
            }

            me.fireEvent(&#39;iconchange&#39;, me, icon, oldIcon);
        }
    },

<span id='Ext-panel-Panel-method-setIconCls'>    setIconCls: function(iconCls) {
</span>        var me = this,
            oldIconCls = me.iconCls,
            header = me.header,
            placeholder = me.placeholder;

        if (iconCls !== oldIconCls) {
            me.iconCls = iconCls;

            if (header) {
                if (header.isHeader) {
                    header.setIconCls(iconCls);
                } else {
                    header.iconCls = iconCls;
                }
            } else if (me.rendered|| me.afterHeaderInit) {
                me.updateHeader();
            }

            if (placeholder &amp;&amp; placeholder.setIconCls) {
                placeholder.setIconCls(iconCls);
            }

            me.fireEvent(&#39;iconclschange&#39;, me, iconCls, oldIconCls);
        }
    },

<span id='Ext-panel-Panel-method-setTitle'>    setTitle: function(title) {
</span>        var me = this,
            oldTitle = me.title,
            header = me.header,
            reExpander = me.reExpander,
            placeholder = me.placeholder;

        if (title !== oldTitle) {
            me.title = title;

            if (header) {
                if (header.isHeader) {
                    header.setTitle(title);
                }
            } else if (me.rendered || me.afterHeaderInit) {
                me.updateHeader();
            }

            if (reExpander) {
                reExpander.setTitle(title);
            }

            if (placeholder &amp;&amp; placeholder.setTitle) {
                placeholder.setTitle(title);
            }

            me.fireEvent(&#39;titlechange&#39;, me, title, oldTitle);
        }
    },

<span id='Ext-panel-Panel-method-setHiddenDocked'>    setHiddenDocked: function(){
</span>        // Hide Panel content except reExpander using visibility to prevent focusing of contained elements.
        // Track what we hide to re-show on expand
        var me = this,
            toHide = me.hiddenOnCollapse,
            items = me.getDockedItems(),
            len = items.length,
            i = 0,
            item, reExpander;

        if (me.header !== false) {
            reExpander = me.getReExpander();
        }

        toHide.add(me.body);
        for (; i &lt; len; i++) {
            item = items[i];
            if (item &amp;&amp; item !== reExpander &amp;&amp; item.el) {
                toHide.add(item.el);
            }
        }
        toHide.setStyle(&#39;visibility&#39;, &#39;hidden&#39;);
    },

<span id='Ext-panel-Panel-method-setUI'>    // @inheritdoc
</span>    setUI: function(ui) {
        var me = this;

        me.callParent(arguments);

        if (me.header &amp;&amp; me.header.rendered) {
            me.header.setUI(ui);
        }
    },

<span id='Ext-panel-Panel-method-toggleCollapse'>    /**
</span>     * Shortcut for performing an {@link #method-expand} or {@link #method-collapse} based on the current state of the panel.
     * @return {Ext.panel.Panel} this
     */
    toggleCollapse: function() {
        return (this.collapsed || this.floatedFromCollapse) ? this.expand() : this.collapse();
    },

<span id='Ext-panel-Panel-method-updateCollapseTool'>    updateCollapseTool: function () {
</span>        var me = this,
            collapseTool = me.collapseTool;

        if (!collapseTool &amp;&amp; me.collapsible) {
            me.collapseDirection = me.collapseDirection || me.getHeaderPosition() || &#39;top&#39;;
            me.collapseTool = me.expandTool = collapseTool = Ext.widget({
                xtype: &#39;tool&#39;,
                handler: me.toggleCollapse,
                scope: me
            });
        }

        if (collapseTool) {
            if (me.collapsed &amp;&amp; !me.isPlaceHolderCollapse()) {
                collapseTool.setType(&#39;expand-&#39; + me.getOppositeDirection(me.collapseDirection));
            } else {
                collapseTool.setType(&#39;collapse-&#39; + me.collapseDirection);
            }
        }
    },

<span id='Ext-panel-Panel-method-updateHeaderPosition'>    updateHeaderPosition: function(position) {
</span>        var header = this.header;

        if (header &amp;&amp; header.isHeader) {
            header.setDock(position);
        }
    },

<span id='Ext-panel-Panel-method-updateIconAlign'>    updateIconAlign: function(align) {
</span>        var header = this.header;

        if (header &amp;&amp; header.isHeader) {
            header.setIconAlign(align);
        }
    },

<span id='Ext-panel-Panel-method-updateTitleAlign'>    updateTitleAlign: function(align) {
</span>        var header = this.header;

        if (header &amp;&amp; header.isHeader) {
            header.setTitleAlign(align);
        }
    },

<span id='Ext-panel-Panel-method-updateTitleRotation'>    updateTitleRotation: function(rotation) {
</span>        var header = this.header;

        if (header &amp;&amp; header.isHeader) {
            header.setTitleRotation(rotation);
        }
    },

<span id='Ext-panel-Panel-method-unghost'>    // @private
</span>    unghost: function(show, matchPosition, focus) {
        var me = this,
            ghostPanel = me.ghostPanel;

        if (!ghostPanel) {
            return;
        }
        if (show !== false) {
            // Show el first, so that position adjustment in setPagePosition
            // will work when relative positioned elements have their XY read.
            me.el.show();
            if (matchPosition !== false) {
                me.setPagePosition(ghostPanel.getXY());
                if (me.hideMode === &#39;offsets&#39;) {
                    // clear the hidden style because we just repositioned
                    delete me.el.hideModeStyles;
                }
            }
            if (focus) {
                me.focus(false, 10);
            }
        }
        ghostPanel.el.hide();
        ghostPanel.setHiddenState(true);
    },

<span id='Ext-panel-Panel-method-updateHeader'>    /**
</span>     * Create, hide, or show the header component as appropriate based on the current config.
     * @private
     * @param {Boolean} force True to force the header to be created
     */
    updateHeader: function(force) {
        var me = this,
            header = me.header,
            title = me.getTitle(),
            tools = me.tools,
            icon = me.getIcon(),
            glyph = me.getGlyph(),
            iconCls = me.getIconCls(),
            hasIcon = glyph || icon || iconCls,

            headerPosition = me.getHeaderPosition(),
            vertical = headerPosition === &#39;left&#39; || headerPosition === &#39;right&#39;;

        if (Ext.isObject(header) || (header !== false &amp;&amp; (force || (title || hasIcon) ||
                (tools &amp;&amp; tools.length) || (me.collapsible &amp;&amp; !me.titleCollapse)))) {
            if (header &amp;&amp; header.isHeader) {
                header.show();
            } else {
                // Apply the header property to the header config
                header = me.header = Ext.widget(Ext.merge({
                    xtype: &#39;header&#39;,
                    title: title,
                    titleAlign: me.getTitleAlign(),
                    vertical: vertical,
                    dock: me.getHeaderPosition() || &#39;top&#39;,
                    titleRotation: me.getTitleRotation(),
                    textCls: me.headerTextCls,
                    iconCls: iconCls,
                    iconAlign: me.getIconAlign(),
                    icon: icon,
                    glyph: glyph,
                    baseCls: me.baseCls + &#39;-header&#39;,
                    tools: tools,
                    ui: me.ui,
                    id: me.id + &#39;_header&#39;,
                    overCls: me.headerOverCls,
                    indicateDrag: me.draggable,
                    frame: (me.frame || me.alwaysFramed) &amp;&amp; me.frameHeader,
                    ignoreParentFrame : me.frame || me.overlapHeader,
                    ignoreBorderManagement: me.frame || me.ignoreHeaderBorderManagement,
                    headerRole: me.headerRole,
                    ownerCt: me,
                    synthetic: true, // not user-defined
                    listeners: me.collapsible &amp;&amp; me.titleCollapse ? {
                        click: me.toggleCollapse,
                        scope: me
                    } : null
                }, me.header));
                // Header&#39;s onAdd mutates the tools array.
                // It replaces tool configs at each index with the instantiated tool
                // It also injects the tool instances as properties keyed by their type.
                me.addDocked(header, 0);
            }
        } else if (header) {
            header.hide();
        }
    },

<span id='Ext-panel-Panel-property-privates'>    // ***********************************************************************************
</span>    // End Methods
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

    privates: {
        addUIToElement: function() {
            var me = this;

            me.callParent(arguments);
            me.addBodyCls(me.baseCls + &#39;-body-&#39; + me.ui);
        },

        applyTargetCls: function(targetCls) {
            this.getProtoBody().addCls(targetCls);
        },

        getDefaultContentTarget: function() {
            return this.body;
        },

        getTargetEl: function() {
            var me = this;
            return me.body || me.protoBody || me.frameBody || me.el;
        },

        // @private
        initDraggable: function() {
            var me = this;

            // For just simple dragging like Windows
            if (me.simpleDrag) {
                me.initSimpleDraggable();
            }
            // For DD package aware dragging of Panels
            else {
<span id='Ext-panel-Panel-property-dd'>                /**
</span>                 * @property {Ext.dd.DragSource/Ext.util.ComponentDragger} dd
                 *
                 * Only present if this Panel has been configured with {@link #cfg-draggable} `true`.
                 *
                 * ##Simple dragging##
                 *
                 * If this Panel is configured {@link #cfg-simpleDrag} `true` (the default is `false`), this property
                 * will reference an instance of {@link Ext.util.ComponentDragger} (A subclass of
                 * {@link Ext.dd.DragTracker DragTracker}) which handles moving the Panel&#39;s DOM Element,
                 * and constraining according to the {@link #constrain} and {@link #constrainHeader} .
                 *
                 * This object fires various events during its lifecycle and during a drag operation.
                 *
                 * ##Complex dragging interacting with other DragDrop instances##
                 *
                 * By default, this property in a {@link #cfg-draggable} Panel will contain an instance of {@link
                    * Ext.dd.DragSource} which handles dragging the Panel.
                 *
                 * The developer must provide implementations of the abstract methods of {@link Ext.dd.DragSource} in order to
                 * supply behaviour for each stage of the drag/drop process. See {@link #cfg-draggable}.
                 */
                me.dd = new Ext.panel.DD(me, Ext.isBoolean(me.draggable) ? null : me.draggable);
            }
        },

        initResizable: function() {
            this.callParent(arguments);
            if (this.collapsed) {
                this.resizer.disable();
            }
        },

<span id='Ext-panel-Panel-method-initSimpleDraggable'>        /**
</span>         * @private
         * Override Component.initDraggable.
         * Panel (and subclasses) use the header element as the delegate.
         */
        initSimpleDraggable: function() {
            var me = this,
                ddConfig, dd;

            if (!me.header) {
                me.updateHeader(true);
            }

            /*
             * Check the header here again. If for whatever reason it wasn&#39;t created in
             * updateHeader (we were configured with header: false) then we&#39;ll just ignore the rest since the
             * header acts as the drag handle.
             */
            if (me.header) {
                ddConfig = Ext.applyIf({
                    el: me.el,
                    delegate: &#39;#&#39; + me.header.id
                }, me.draggable);

                // Add extra configs if Window is specified to be constrained
                if (me.constrain || me.constrainHeader) {
                    ddConfig.constrain = me.constrain;
                    ddConfig.constrainDelegate = me.constrainHeader;
                    ddConfig.constrainTo = me.constrainTo || me.container;
                }

                dd = me.dd = new Ext.util.ComponentDragger(me, ddConfig);
                me.relayEvents(dd, [&#39;dragstart&#39;, &#39;drag&#39;, &#39;dragend&#39;]);
                if (me.maximized) {
                    dd.disable();
                }
            }
        },

        removeUIFromElement: function() {
            var me = this;

            me.callParent(arguments);
            me.removeBodyCls(me.baseCls + &#39;-body-&#39; + me.ui);
        },

        setupRenderTpl: function (renderTpl) {
            this.callParent(arguments);
            this.setupDockingRenderTpl(renderTpl);
        },

        slideOutFloatedPanel: function(preventAnimate) {
            var me = this,
                compEl = me.el,
                collapseDirection;

            if (me.isSliding || me.isDestroyed) {
                return;
            }

            me.isSliding = true;
            me.floated = false;

            me.slideOutFloatedPanelBegin();

            if (typeof me.collapsed == &#39;string&#39;) {
                collapseDirection = me.convertCollapseDir(me.collapsed);
            }

            compEl.slideOut(collapseDirection, {
                preserveScroll: true,
                duration: Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration),
                autoEnd: preventAnimate === true,
                listeners: {
                    afteranimate: function() {
                        me.slideOutFloatedPanelEnd();
                        // this would be in slideOutFloatedPanelEnd except that the only other
                        // caller removes this cls later
                        me.el.removeCls(Ext.baseCSSPrefix + &#39;border-region-slide-in&#39;);
                    }
                }
            });
        },

<span id='Ext-panel-Panel-method-slideOutFloatedPanelBegin'>        /**
</span>         * This method begins the slide out of the floated panel.
         * @private
         */
        slideOutFloatedPanelBegin: function() {
            var me = this,
                placeholderEl = me.placeholder.el,
                el = me.el;

            me.collapsed = me.floatedFromCollapse;
            me.setHiddenState(true);
            me.floatedFromCollapse = null;

            // Remove mouse leave/enter monitors
            placeholderEl.un(&#39;mouseleave&#39;, me.onMouseLeaveFloated, me);
            el.un(&#39;mouseleave&#39;, me.onMouseLeaveFloated, me);
            placeholderEl.un(&#39;mouseenter&#39;, me.onMouseEnterFloated, me);
            el.un(&#39;mouseenter&#39;, me.onMouseEnterFloated, me);
        },

<span id='Ext-panel-Panel-method-slideOutFloatedPanelEnd'>        /**
</span>         * This method cleans up after the slide out of the floated panel.
         * @private
         */
        slideOutFloatedPanelEnd: function(suppressEvents) {
            var me = this;

            if (me.collapseTool) {
                me.collapseTool.el.show();
            }
            me.slideOutTask.cancel();
            me.isSliding = false;
            if (!suppressEvents) {
                me.fireEvent(&#39;unfloat&#39;, me);
            }
        }

    } // private
}, function() {
    var proto = this.prototype;

    proto.animCollapse = Ext.enableFx;
    proto.placeholderCollapseHideMode = Ext.Element.VISIBILITY;
});
</pre>
</body>
</html>
